<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Diagonal</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    {{BASE_TAG}}

    <link rel="stylesheet" href="assets/vendor.css">
    <link rel="stylesheet" href="assets/diagonal.css">
  </head>
  <body>
    <script src="assets/vendor.js"></script>
    <script src="assets/diagonal.js"></script>
    <script>
      window.DiagonalENV = require('diagonal/config/environment')['default'];
      window.EmberENV = window.DiagonalENV.EmberENV;
      window.Diagonal = require('diagonal/app')['default'].create(DiagonalENV.APP);
    </script>

    <div id="main-app"></div>
    <div id="demo-app"></div>
  </body>
  <script type="text/javascript">
  !function() {
    var d3 = {
      version: "3.4.11"
    };
    if (!Date.now) Date.now = function() {
      return +new Date();
    };
    var d3_arraySlice = [].slice, d3_array = function(list) {
      return d3_arraySlice.call(list);
    };
    var d3_document = document, d3_documentElement = d3_document.documentElement, d3_window = window;
    try {
      d3_array(d3_documentElement.childNodes)[0].nodeType;
    } catch (e) {
      d3_array = function(list) {
        var i = list.length, array = new Array(i);
        while (i--) array[i] = list[i];
        return array;
      };
    }
    try {
      d3_document.createElement("div").style.setProperty("opacity", 0, "");
    } catch (error) {
      var d3_element_prototype = d3_window.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = d3_window.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
      d3_element_prototype.setAttribute = function(name, value) {
        d3_element_setAttribute.call(this, name, value + "");
      };
      d3_element_prototype.setAttributeNS = function(space, local, value) {
        d3_element_setAttributeNS.call(this, space, local, value + "");
      };
      d3_style_prototype.setProperty = function(name, value, priority) {
        d3_style_setProperty.call(this, name, value + "", priority);
      };
    }
    d3.ascending = d3_ascending;
    function d3_ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }
    d3.descending = function(a, b) {
      return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    };
    d3.min = function(array, f) {
      var i = -1, n = array.length, a, b;
      if (arguments.length === 1) {
        while (++i < n && !((a = array[i]) != null && a <= a)) a = undefined;
        while (++i < n) if ((b = array[i]) != null && a > b) a = b;
      } else {
        while (++i < n && !((a = f.call(array, array[i], i)) != null && a <= a)) a = undefined;
        while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
      }
      return a;
    };
    d3.max = function(array, f) {
      var i = -1, n = array.length, a, b;
      if (arguments.length === 1) {
        while (++i < n && !((a = array[i]) != null && a <= a)) a = undefined;
        while (++i < n) if ((b = array[i]) != null && b > a) a = b;
      } else {
        while (++i < n && !((a = f.call(array, array[i], i)) != null && a <= a)) a = undefined;
        while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
      }
      return a;
    };
    d3.extent = function(array, f) {
      var i = -1, n = array.length, a, b, c;
      if (arguments.length === 1) {
        while (++i < n && !((a = c = array[i]) != null && a <= a)) a = c = undefined;
        while (++i < n) if ((b = array[i]) != null) {
          if (a > b) a = b;
          if (c < b) c = b;
        }
      } else {
        while (++i < n && !((a = c = f.call(array, array[i], i)) != null && a <= a)) a = undefined;
        while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
          if (a > b) a = b;
          if (c < b) c = b;
        }
      }
      return [ a, c ];
    };
    d3.sum = function(array, f) {
      var s = 0, n = array.length, a, i = -1;
      if (arguments.length === 1) {
        while (++i < n) if (!isNaN(a = +array[i])) s += a;
      } else {
        while (++i < n) if (!isNaN(a = +f.call(array, array[i], i))) s += a;
      }
      return s;
    };
    function d3_number(x) {
      return x != null && !isNaN(x);
    }
    d3.mean = function(array, f) {
      var s = 0, n = array.length, a, i = -1, j = n;
      if (arguments.length === 1) {
        while (++i < n) if (d3_number(a = array[i])) s += a; else --j;
      } else {
        while (++i < n) if (d3_number(a = f.call(array, array[i], i))) s += a; else --j;
      }
      return j ? s / j : undefined;
    };
    d3.quantile = function(values, p) {
      var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
      return e ? v + e * (values[h] - v) : v;
    };
    d3.median = function(array, f) {
      if (arguments.length > 1) array = array.map(f);
      array = array.filter(d3_number);
      return array.length ? d3.quantile(array.sort(d3_ascending), .5) : undefined;
    };
    function d3_bisector(compare) {
      return {
        left: function(a, x, lo, hi) {
          if (arguments.length < 3) lo = 0;
          if (arguments.length < 4) hi = a.length;
          while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
          }
          return lo;
        },
        right: function(a, x, lo, hi) {
          if (arguments.length < 3) lo = 0;
          if (arguments.length < 4) hi = a.length;
          while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
          }
          return lo;
        }
      };
    }
    var d3_bisect = d3_bisector(d3_ascending);
    d3.bisectLeft = d3_bisect.left;
    d3.bisect = d3.bisectRight = d3_bisect.right;
    d3.bisector = function(f) {
      return d3_bisector(f.length === 1 ? function(d, x) {
        return d3_ascending(f(d), x);
      } : f);
    };
    d3.shuffle = function(array) {
      var m = array.length, t, i;
      while (m) {
        i = Math.random() * m-- | 0;
        t = array[m], array[m] = array[i], array[i] = t;
      }
      return array;
    };
    d3.permute = function(array, indexes) {
      var i = indexes.length, permutes = new Array(i);
      while (i--) permutes[i] = array[indexes[i]];
      return permutes;
    };
    d3.pairs = function(array) {
      var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
      while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
      return pairs;
    };
    d3.zip = function() {
      if (!(n = arguments.length)) return [];
      for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; ) {
        for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n; ) {
          zip[j] = arguments[j][i];
        }
      }
      return zips;
    };
    function d3_zipLength(d) {
      return d.length;
    }
    d3.transpose = function(matrix) {
      return d3.zip.apply(d3, matrix);
    };
    d3.keys = function(map) {
      var keys = [];
      for (var key in map) keys.push(key);
      return keys;
    };
    d3.values = function(map) {
      var values = [];
      for (var key in map) values.push(map[key]);
      return values;
    };
    d3.entries = function(map) {
      var entries = [];
      for (var key in map) entries.push({
        key: key,
        value: map[key]
      });
      return entries;
    };
    d3.merge = function(arrays) {
      var n = arrays.length, m, i = -1, j = 0, merged, array;
      while (++i < n) j += arrays[i].length;
      merged = new Array(j);
      while (--n >= 0) {
        array = arrays[n];
        m = array.length;
        while (--m >= 0) {
          merged[--j] = array[m];
        }
      }
      return merged;
    };
    var abs = Math.abs;
    d3.range = function(start, stop, step) {
      if (arguments.length < 3) {
        step = 1;
        if (arguments.length < 2) {
          stop = start;
          start = 0;
        }
      }
      if ((stop - start) / step === Infinity) throw new Error("infinite range");
      var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
      start *= k, stop *= k, step *= k;
      if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
      return range;
    };
    function d3_range_integerScale(x) {
      var k = 1;
      while (x * k % 1) k *= 10;
      return k;
    }
    function d3_class(ctor, properties) {
      try {
        for (var key in properties) {
          Object.defineProperty(ctor.prototype, key, {
            value: properties[key],
            enumerable: false
          });
        }
      } catch (e) {
        ctor.prototype = properties;
      }
    }
    d3.map = function(object) {
      var map = new d3_Map();
      if (object instanceof d3_Map) object.forEach(function(key, value) {
        map.set(key, value);
      }); else for (var key in object) map.set(key, object[key]);
      return map;
    };
    function d3_Map() {}
    d3_class(d3_Map, {
      has: d3_map_has,
      get: function(key) {
        return this[d3_map_prefix + key];
      },
      set: function(key, value) {
        return this[d3_map_prefix + key] = value;
      },
      remove: d3_map_remove,
      keys: d3_map_keys,
      values: function() {
        var values = [];
        this.forEach(function(key, value) {
          values.push(value);
        });
        return values;
      },
      entries: function() {
        var entries = [];
        this.forEach(function(key, value) {
          entries.push({
            key: key,
            value: value
          });
        });
        return entries;
      },
      size: d3_map_size,
      empty: d3_map_empty,
      forEach: function(f) {
        for (var key in this) if (key.charCodeAt(0) === d3_map_prefixCode) f.call(this, key.substring(1), this[key]);
      }
    });
    var d3_map_prefix = "\x00", d3_map_prefixCode = d3_map_prefix.charCodeAt(0);
    function d3_map_has(key) {
      return d3_map_prefix + key in this;
    }
    function d3_map_remove(key) {
      key = d3_map_prefix + key;
      return key in this && delete this[key];
    }
    function d3_map_keys() {
      var keys = [];
      this.forEach(function(key) {
        keys.push(key);
      });
      return keys;
    }
    function d3_map_size() {
      var size = 0;
      for (var key in this) if (key.charCodeAt(0) === d3_map_prefixCode) ++size;
      return size;
    }
    function d3_map_empty() {
      for (var key in this) if (key.charCodeAt(0) === d3_map_prefixCode) return false;
      return true;
    }
    d3.nest = function() {
      var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
      function map(mapType, array, depth) {
        if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
        var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
        while (++i < n) {
          if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
            values.push(object);
          } else {
            valuesByKey.set(keyValue, [ object ]);
          }
        }
        if (mapType) {
          object = mapType();
          setter = function(keyValue, values) {
            object.set(keyValue, map(mapType, values, depth));
          };
        } else {
          object = {};
          setter = function(keyValue, values) {
            object[keyValue] = map(mapType, values, depth);
          };
        }
        valuesByKey.forEach(setter);
        return object;
      }
      function entries(map, depth) {
        if (depth >= keys.length) return map;
        var array = [], sortKey = sortKeys[depth++];
        map.forEach(function(key, keyMap) {
          array.push({
            key: key,
            values: entries(keyMap, depth)
          });
        });
        return sortKey ? array.sort(function(a, b) {
          return sortKey(a.key, b.key);
        }) : array;
      }
      nest.map = function(array, mapType) {
        return map(mapType, array, 0);
      };
      nest.entries = function(array) {
        return entries(map(d3.map, array, 0), 0);
      };
      nest.key = function(d) {
        keys.push(d);
        return nest;
      };
      nest.sortKeys = function(order) {
        sortKeys[keys.length - 1] = order;
        return nest;
      };
      nest.sortValues = function(order) {
        sortValues = order;
        return nest;
      };
      nest.rollup = function(f) {
        rollup = f;
        return nest;
      };
      return nest;
    };
    d3.set = function(array) {
      var set = new d3_Set();
      if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
      return set;
    };
    function d3_Set() {}
    d3_class(d3_Set, {
      has: d3_map_has,
      add: function(value) {
        this[d3_map_prefix + value] = true;
        return value;
      },
      remove: function(value) {
        value = d3_map_prefix + value;
        return value in this && delete this[value];
      },
      values: d3_map_keys,
      size: d3_map_size,
      empty: d3_map_empty,
      forEach: function(f) {
        for (var value in this) if (value.charCodeAt(0) === d3_map_prefixCode) f.call(this, value.substring(1));
      }
    });
    d3.behavior = {};
    d3.rebind = function(target, source) {
      var i = 1, n = arguments.length, method;
      while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
      return target;
    };
    function d3_rebind(target, source, method) {
      return function() {
        var value = method.apply(source, arguments);
        return value === source ? target : value;
      };
    }
    function d3_vendorSymbol(object, name) {
      if (name in object) return name;
      name = name.charAt(0).toUpperCase() + name.substring(1);
      for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
        var prefixName = d3_vendorPrefixes[i] + name;
        if (prefixName in object) return prefixName;
      }
    }
    var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
    function d3_noop() {}
    d3.dispatch = function() {
      var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
      while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
      return dispatch;
    };
    function d3_dispatch() {}
    d3_dispatch.prototype.on = function(type, listener) {
      var i = type.indexOf("."), name = "";
      if (i >= 0) {
        name = type.substring(i + 1);
        type = type.substring(0, i);
      }
      if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
      if (arguments.length === 2) {
        if (listener == null) for (type in this) {
          if (this.hasOwnProperty(type)) this[type].on(name, null);
        }
        return this;
      }
    };
    function d3_dispatch_event(dispatch) {
      var listeners = [], listenerByName = new d3_Map();
      function event() {
        var z = listeners, i = -1, n = z.length, l;
        while (++i < n) if (l = z[i].on) l.apply(this, arguments);
        return dispatch;
      }
      event.on = function(name, listener) {
        var l = listenerByName.get(name), i;
        if (arguments.length < 2) return l && l.on;
        if (l) {
          l.on = null;
          listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
          listenerByName.remove(name);
        }
        if (listener) listeners.push(listenerByName.set(name, {
          on: listener
        }));
        return dispatch;
      };
      return event;
    }
    d3.event = null;
    function d3_eventPreventDefault() {
      d3.event.preventDefault();
    }
    function d3_eventSource() {
      var e = d3.event, s;
      while (s = e.sourceEvent) e = s;
      return e;
    }
    function d3_eventDispatch(target) {
      var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
      while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
      dispatch.of = function(thiz, argumentz) {
        return function(e1) {
          try {
            var e0 = e1.sourceEvent = d3.event;
            e1.target = target;
            d3.event = e1;
            dispatch[e1.type].apply(thiz, argumentz);
          } finally {
            d3.event = e0;
          }
        };
      };
      return dispatch;
    }
    d3.requote = function(s) {
      return s.replace(d3_requote_re, "\\$&");
    };
    var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
    var d3_subclass = {}.__proto__ ? function(object, prototype) {
      object.__proto__ = prototype;
    } : function(object, prototype) {
      for (var property in prototype) object[property] = prototype[property];
    };
    function d3_selection(groups) {
      d3_subclass(groups, d3_selectionPrototype);
      return groups;
    }
    var d3_select = function(s, n) {
      return n.querySelector(s);
    }, d3_selectAll = function(s, n) {
      return n.querySelectorAll(s);
    }, d3_selectMatcher = d3_documentElement.matches || d3_documentElement[d3_vendorSymbol(d3_documentElement, "matchesSelector")], d3_selectMatches = function(n, s) {
      return d3_selectMatcher.call(n, s);
    };
    if (typeof Sizzle === "function") {
      d3_select = function(s, n) {
        return Sizzle(s, n)[0] || null;
      };
      d3_selectAll = Sizzle;
      d3_selectMatches = Sizzle.matchesSelector;
    }
    d3.selection = function() {
      return d3_selectionRoot;
    };
    var d3_selectionPrototype = d3.selection.prototype = [];
    d3_selectionPrototype.select = function(selector) {
      var subgroups = [], subgroup, subnode, group, node;
      selector = d3_selection_selector(selector);
      for (var j = -1, m = this.length; ++j < m; ) {
        subgroups.push(subgroup = []);
        subgroup.parentNode = (group = this[j]).parentNode;
        for (var i = -1, n = group.length; ++i < n; ) {
          if (node = group[i]) {
            subgroup.push(subnode = selector.call(node, node.__data__, i, j));
            if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
          } else {
            subgroup.push(null);
          }
        }
      }
      return d3_selection(subgroups);
    };
    function d3_selection_selector(selector) {
      return typeof selector === "function" ? selector : function() {
        return d3_select(selector, this);
      };
    }
    d3_selectionPrototype.selectAll = function(selector) {
      var subgroups = [], subgroup, node;
      selector = d3_selection_selectorAll(selector);
      for (var j = -1, m = this.length; ++j < m; ) {
        for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
          if (node = group[i]) {
            subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
            subgroup.parentNode = node;
          }
        }
      }
      return d3_selection(subgroups);
    };
    function d3_selection_selectorAll(selector) {
      return typeof selector === "function" ? selector : function() {
        return d3_selectAll(selector, this);
      };
    }
    var d3_nsPrefix = {
      svg: "http://www.w3.org/2000/svg",
      xhtml: "http://www.w3.org/1999/xhtml",
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };
    d3.ns = {
      prefix: d3_nsPrefix,
      qualify: function(name) {
        var i = name.indexOf(":"), prefix = name;
        if (i >= 0) {
          prefix = name.substring(0, i);
          name = name.substring(i + 1);
        }
        return d3_nsPrefix.hasOwnProperty(prefix) ? {
          space: d3_nsPrefix[prefix],
          local: name
        } : name;
      }
    };
    d3_selectionPrototype.attr = function(name, value) {
      if (arguments.length < 2) {
        if (typeof name === "string") {
          var node = this.node();
          name = d3.ns.qualify(name);
          return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
        }
        for (value in name) this.each(d3_selection_attr(value, name[value]));
        return this;
      }
      return this.each(d3_selection_attr(name, value));
    };
    function d3_selection_attr(name, value) {
      name = d3.ns.qualify(name);
      function attrNull() {
        this.removeAttribute(name);
      }
      function attrNullNS() {
        this.removeAttributeNS(name.space, name.local);
      }
      function attrConstant() {
        this.setAttribute(name, value);
      }
      function attrConstantNS() {
        this.setAttributeNS(name.space, name.local, value);
      }
      function attrFunction() {
        var x = value.apply(this, arguments);
        if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
      }
      function attrFunctionNS() {
        var x = value.apply(this, arguments);
        if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
      }
      return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
    }
    function d3_collapse(s) {
      return s.trim().replace(/\s+/g, " ");
    }
    d3_selectionPrototype.classed = function(name, value) {
      if (arguments.length < 2) {
        if (typeof name === "string") {
          var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
          if (value = node.classList) {
            while (++i < n) if (!value.contains(name[i])) return false;
          } else {
            value = node.getAttribute("class");
            while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
          }
          return true;
        }
        for (value in name) this.each(d3_selection_classed(value, name[value]));
        return this;
      }
      return this.each(d3_selection_classed(name, value));
    };
    function d3_selection_classedRe(name) {
      return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
    }
    function d3_selection_classes(name) {
      return (name + "").trim().split(/^|\s+/);
    }
    function d3_selection_classed(name, value) {
      name = d3_selection_classes(name).map(d3_selection_classedName);
      var n = name.length;
      function classedConstant() {
        var i = -1;
        while (++i < n) name[i](this, value);
      }
      function classedFunction() {
        var i = -1, x = value.apply(this, arguments);
        while (++i < n) name[i](this, x);
      }
      return typeof value === "function" ? classedFunction : classedConstant;
    }
    function d3_selection_classedName(name) {
      var re = d3_selection_classedRe(name);
      return function(node, value) {
        if (c = node.classList) return value ? c.add(name) : c.remove(name);
        var c = node.getAttribute("class") || "";
        if (value) {
          re.lastIndex = 0;
          if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
        } else {
          node.setAttribute("class", d3_collapse(c.replace(re, " ")));
        }
      };
    }
    d3_selectionPrototype.style = function(name, value, priority) {
      var n = arguments.length;
      if (n < 3) {
        if (typeof name !== "string") {
          if (n < 2) value = "";
          for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
          return this;
        }
        if (n < 2) return d3_window.getComputedStyle(this.node(), null).getPropertyValue(name);
        priority = "";
      }
      return this.each(d3_selection_style(name, value, priority));
    };
    function d3_selection_style(name, value, priority) {
      function styleNull() {
        this.style.removeProperty(name);
      }
      function styleConstant() {
        this.style.setProperty(name, value, priority);
      }
      function styleFunction() {
        var x = value.apply(this, arguments);
        if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
      }
      return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
    }
    d3_selectionPrototype.property = function(name, value) {
      if (arguments.length < 2) {
        if (typeof name === "string") return this.node()[name];
        for (value in name) this.each(d3_selection_property(value, name[value]));
        return this;
      }
      return this.each(d3_selection_property(name, value));
    };
    function d3_selection_property(name, value) {
      function propertyNull() {
        delete this[name];
      }
      function propertyConstant() {
        this[name] = value;
      }
      function propertyFunction() {
        var x = value.apply(this, arguments);
        if (x == null) delete this[name]; else this[name] = x;
      }
      return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
    }
    d3_selectionPrototype.text = function(value) {
      return arguments.length ? this.each(typeof value === "function" ? function() {
        var v = value.apply(this, arguments);
        this.textContent = v == null ? "" : v;
      } : value == null ? function() {
        this.textContent = "";
      } : function() {
        this.textContent = value;
      }) : this.node().textContent;
    };
    d3_selectionPrototype.html = function(value) {
      return arguments.length ? this.each(typeof value === "function" ? function() {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
      } : value == null ? function() {
        this.innerHTML = "";
      } : function() {
        this.innerHTML = value;
      }) : this.node().innerHTML;
    };
    d3_selectionPrototype.append = function(name) {
      name = d3_selection_creator(name);
      return this.select(function() {
        return this.appendChild(name.apply(this, arguments));
      });
    };
    function d3_selection_creator(name) {
      return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? function() {
        return this.ownerDocument.createElementNS(name.space, name.local);
      } : function() {
        return this.ownerDocument.createElementNS(this.namespaceURI, name);
      };
    }
    d3_selectionPrototype.insert = function(name, before) {
      name = d3_selection_creator(name);
      before = d3_selection_selector(before);
      return this.select(function() {
        return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
      });
    };
    d3_selectionPrototype.remove = function() {
      return this.each(function() {
        var parent = this.parentNode;
        if (parent) parent.removeChild(this);
      });
    };
    d3_selectionPrototype.data = function(value, key) {
      var i = -1, n = this.length, group, node;
      if (!arguments.length) {
        value = new Array(n = (group = this[0]).length);
        while (++i < n) {
          if (node = group[i]) {
            value[i] = node.__data__;
          }
        }
        return value;
      }
      function bind(group, groupData) {
        var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
        if (key) {
          var nodeByKeyValue = new d3_Map(), dataByKeyValue = new d3_Map(), keyValues = [], keyValue;
          for (i = -1; ++i < n; ) {
            keyValue = key.call(node = group[i], node.__data__, i);
            if (nodeByKeyValue.has(keyValue)) {
              exitNodes[i] = node;
            } else {
              nodeByKeyValue.set(keyValue, node);
            }
            keyValues.push(keyValue);
          }
          for (i = -1; ++i < m; ) {
            keyValue = key.call(groupData, nodeData = groupData[i], i);
            if (node = nodeByKeyValue.get(keyValue)) {
              updateNodes[i] = node;
              node.__data__ = nodeData;
            } else if (!dataByKeyValue.has(keyValue)) {
              enterNodes[i] = d3_selection_dataNode(nodeData);
            }
            dataByKeyValue.set(keyValue, nodeData);
            nodeByKeyValue.remove(keyValue);
          }
          for (i = -1; ++i < n; ) {
            if (nodeByKeyValue.has(keyValues[i])) {
              exitNodes[i] = group[i];
            }
          }
        } else {
          for (i = -1; ++i < n0; ) {
            node = group[i];
            nodeData = groupData[i];
            if (node) {
              node.__data__ = nodeData;
              updateNodes[i] = node;
            } else {
              enterNodes[i] = d3_selection_dataNode(nodeData);
            }
          }
          for (;i < m; ++i) {
            enterNodes[i] = d3_selection_dataNode(groupData[i]);
          }
          for (;i < n; ++i) {
            exitNodes[i] = group[i];
          }
        }
        enterNodes.update = updateNodes;
        enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
        enter.push(enterNodes);
        update.push(updateNodes);
        exit.push(exitNodes);
      }
      var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
      if (typeof value === "function") {
        while (++i < n) {
          bind(group = this[i], value.call(group, group.parentNode.__data__, i));
        }
      } else {
        while (++i < n) {
          bind(group = this[i], value);
        }
      }
      update.enter = function() {
        return enter;
      };
      update.exit = function() {
        return exit;
      };
      return update;
    };
    function d3_selection_dataNode(data) {
      return {
        __data__: data
      };
    }
    d3_selectionPrototype.datum = function(value) {
      return arguments.length ? this.property("__data__", value) : this.property("__data__");
    };
    d3_selectionPrototype.filter = function(filter) {
      var subgroups = [], subgroup, group, node;
      if (typeof filter !== "function") filter = d3_selection_filter(filter);
      for (var j = 0, m = this.length; j < m; j++) {
        subgroups.push(subgroup = []);
        subgroup.parentNode = (group = this[j]).parentNode;
        for (var i = 0, n = group.length; i < n; i++) {
          if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
            subgroup.push(node);
          }
        }
      }
      return d3_selection(subgroups);
    };
    function d3_selection_filter(selector) {
      return function() {
        return d3_selectMatches(this, selector);
      };
    }
    d3_selectionPrototype.order = function() {
      for (var j = -1, m = this.length; ++j < m; ) {
        for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
          if (node = group[i]) {
            if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
            next = node;
          }
        }
      }
      return this;
    };
    d3_selectionPrototype.sort = function(comparator) {
      comparator = d3_selection_sortComparator.apply(this, arguments);
      for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
      return this.order();
    };
    function d3_selection_sortComparator(comparator) {
      if (!arguments.length) comparator = d3_ascending;
      return function(a, b) {
        return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
      };
    }
    d3_selectionPrototype.each = function(callback) {
      return d3_selection_each(this, function(node, i, j) {
        callback.call(node, node.__data__, i, j);
      });
    };
    function d3_selection_each(groups, callback) {
      for (var j = 0, m = groups.length; j < m; j++) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
          if (node = group[i]) callback(node, i, j);
        }
      }
      return groups;
    }
    d3_selectionPrototype.call = function(callback) {
      var args = d3_array(arguments);
      callback.apply(args[0] = this, args);
      return this;
    };
    d3_selectionPrototype.empty = function() {
      return !this.node();
    };
    d3_selectionPrototype.node = function() {
      for (var j = 0, m = this.length; j < m; j++) {
        for (var group = this[j], i = 0, n = group.length; i < n; i++) {
          var node = group[i];
          if (node) return node;
        }
      }
      return null;
    };
    d3_selectionPrototype.size = function() {
      var n = 0;
      this.each(function() {
        ++n;
      });
      return n;
    };
    function d3_selection_enter(selection) {
      d3_subclass(selection, d3_selection_enterPrototype);
      return selection;
    }
    var d3_selection_enterPrototype = [];
    d3.selection.enter = d3_selection_enter;
    d3.selection.enter.prototype = d3_selection_enterPrototype;
    d3_selection_enterPrototype.append = d3_selectionPrototype.append;
    d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
    d3_selection_enterPrototype.node = d3_selectionPrototype.node;
    d3_selection_enterPrototype.call = d3_selectionPrototype.call;
    d3_selection_enterPrototype.size = d3_selectionPrototype.size;
    d3_selection_enterPrototype.select = function(selector) {
      var subgroups = [], subgroup, subnode, upgroup, group, node;
      for (var j = -1, m = this.length; ++j < m; ) {
        upgroup = (group = this[j]).update;
        subgroups.push(subgroup = []);
        subgroup.parentNode = group.parentNode;
        for (var i = -1, n = group.length; ++i < n; ) {
          if (node = group[i]) {
            subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
            subnode.__data__ = node.__data__;
          } else {
            subgroup.push(null);
          }
        }
      }
      return d3_selection(subgroups);
    };
    d3_selection_enterPrototype.insert = function(name, before) {
      if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
      return d3_selectionPrototype.insert.call(this, name, before);
    };
    function d3_selection_enterInsertBefore(enter) {
      var i0, j0;
      return function(d, i, j) {
        var group = enter[j].update, n = group.length, node;
        if (j != j0) j0 = j, i0 = 0;
        if (i >= i0) i0 = i + 1;
        while (!(node = group[i0]) && ++i0 < n) ;
        return node;
      };
    }
    d3_selectionPrototype.transition = function() {
      var id = d3_transitionInheritId || ++d3_transitionId, subgroups = [], subgroup, node, transition = d3_transitionInherit || {
        time: Date.now(),
        ease: d3_ease_cubicInOut,
        delay: 0,
        duration: 250
      };
      for (var j = -1, m = this.length; ++j < m; ) {
        subgroups.push(subgroup = []);
        for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
          if (node = group[i]) d3_transitionNode(node, i, id, transition);
          subgroup.push(node);
        }
      }
      return d3_transition(subgroups, id);
    };
    d3_selectionPrototype.interrupt = function() {
      return this.each(d3_selection_interrupt);
    };
    function d3_selection_interrupt() {
      var lock = this.__transition__;
      if (lock) ++lock.active;
    }
    d3.select = function(node) {
      var group = [ typeof node === "string" ? d3_select(node, d3_document) : node ];
      group.parentNode = d3_documentElement;
      return d3_selection([ group ]);
    };
    d3.selectAll = function(nodes) {
      var group = d3_array(typeof nodes === "string" ? d3_selectAll(nodes, d3_document) : nodes);
      group.parentNode = d3_documentElement;
      return d3_selection([ group ]);
    };
    var d3_selectionRoot = d3.select(d3_documentElement);
    d3_selectionPrototype.on = function(type, listener, capture) {
      var n = arguments.length;
      if (n < 3) {
        if (typeof type !== "string") {
          if (n < 2) listener = false;
          for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
          return this;
        }
        if (n < 2) return (n = this.node()["__on" + type]) && n._;
        capture = false;
      }
      return this.each(d3_selection_on(type, listener, capture));
    };
    function d3_selection_on(type, listener, capture) {
      var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
      if (i > 0) type = type.substring(0, i);
      var filter = d3_selection_onFilters.get(type);
      if (filter) type = filter, wrap = d3_selection_onFilter;
      function onRemove() {
        var l = this[name];
        if (l) {
          this.removeEventListener(type, l, l.$);
          delete this[name];
        }
      }
      function onAdd() {
        var l = wrap(listener, d3_array(arguments));
        onRemove.call(this);
        this.addEventListener(type, this[name] = l, l.$ = capture);
        l._ = listener;
      }
      function removeAll() {
        var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
        for (var name in this) {
          if (match = name.match(re)) {
            var l = this[name];
            this.removeEventListener(match[1], l, l.$);
            delete this[name];
          }
        }
      }
      return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
    }
    var d3_selection_onFilters = d3.map({
      mouseenter: "mouseover",
      mouseleave: "mouseout"
    });
    d3_selection_onFilters.forEach(function(k) {
      if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
    });
    function d3_selection_onListener(listener, argumentz) {
      return function(e) {
        var o = d3.event;
        d3.event = e;
        argumentz[0] = this.__data__;
        try {
          listener.apply(this, argumentz);
        } finally {
          d3.event = o;
        }
      };
    }
    function d3_selection_onFilter(listener, argumentz) {
      var l = d3_selection_onListener(listener, argumentz);
      return function(e) {
        var target = this, related = e.relatedTarget;
        if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
          l.call(target, e);
        }
      };
    }
    var d3_event_dragSelect = "onselectstart" in d3_document ? null : d3_vendorSymbol(d3_documentElement.style, "userSelect"), d3_event_dragId = 0;
    function d3_event_dragSuppress() {
      var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
      if (d3_event_dragSelect) {
        var style = d3_documentElement.style, select = style[d3_event_dragSelect];
        style[d3_event_dragSelect] = "none";
      }
      return function(suppressClick) {
        w.on(name, null);
        if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
        if (suppressClick) {
          function off() {
            w.on(click, null);
          }
          w.on(click, function() {
            d3_eventPreventDefault();
            off();
          }, true);
          setTimeout(off, 0);
        }
      };
    }
    d3.mouse = function(container) {
      return d3_mousePoint(container, d3_eventSource());
    };
    var d3_mouse_bug44083 = /WebKit/.test(d3_window.navigator.userAgent) ? -1 : 0;
    function d3_mousePoint(container, e) {
      if (e.changedTouches) e = e.changedTouches[0];
      var svg = container.ownerSVGElement || container;
      if (svg.createSVGPoint) {
        var point = svg.createSVGPoint();
        if (d3_mouse_bug44083 < 0 && (d3_window.scrollX || d3_window.scrollY)) {
          svg = d3.select("body").append("svg").style({
            position: "absolute",
            top: 0,
            left: 0,
            margin: 0,
            padding: 0,
            border: "none"
          }, "important");
          var ctm = svg[0][0].getScreenCTM();
          d3_mouse_bug44083 = !(ctm.f || ctm.e);
          svg.remove();
        }
        if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
        point.y = e.clientY;
        point = point.matrixTransform(container.getScreenCTM().inverse());
        return [ point.x, point.y ];
      }
      var rect = container.getBoundingClientRect();
      return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
    }
    d3.touches = function(container, touches) {
      if (arguments.length < 2) touches = d3_eventSource().touches;
      return touches ? d3_array(touches).map(function(touch) {
        var point = d3_mousePoint(container, touch);
        point.identifier = touch.identifier;
        return point;
      }) : [];
    };
    d3.behavior.drag = function() {
      var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_behavior_dragMouseSubject, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_behavior_dragTouchSubject, "touchmove", "touchend");
      function drag() {
        this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
      }
      function dragstart(id, position, subject, move, end) {
        return function() {
          var that = this, target = d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject()).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(), position0 = position(parent, dragId);
          if (origin) {
            dragOffset = origin.apply(that, arguments);
            dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
          } else {
            dragOffset = [ 0, 0 ];
          }
          dispatch({
            type: "dragstart"
          });
          function moved() {
            var position1 = position(parent, dragId), dx, dy;
            if (!position1) return;
            dx = position1[0] - position0[0];
            dy = position1[1] - position0[1];
            dragged |= dx | dy;
            position0 = position1;
            dispatch({
              type: "drag",
              x: position1[0] + dragOffset[0],
              y: position1[1] + dragOffset[1],
              dx: dx,
              dy: dy
            });
          }
          function ended() {
            if (!position(parent, dragId)) return;
            dragSubject.on(move + dragName, null).on(end + dragName, null);
            dragRestore(dragged && d3.event.target === target);
            dispatch({
              type: "dragend"
            });
          }
        };
      }
      drag.origin = function(x) {
        if (!arguments.length) return origin;
        origin = x;
        return drag;
      };
      return d3.rebind(drag, event, "on");
    };
    function d3_behavior_dragTouchId() {
      return d3.event.changedTouches[0].identifier;
    }
    function d3_behavior_dragTouchSubject() {
      return d3.event.target;
    }
    function d3_behavior_dragMouseSubject() {
      return d3_window;
    }
    var π = Math.PI, τ = 2 * π, halfπ = π / 2, ε = 1e-6, ε2 = ε * ε, d3_radians = π / 180, d3_degrees = 180 / π;
    function d3_sgn(x) {
      return x > 0 ? 1 : x < 0 ? -1 : 0;
    }
    function d3_cross2d(a, b, c) {
      return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
    }
    function d3_acos(x) {
      return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
    }
    function d3_asin(x) {
      return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
    }
    function d3_sinh(x) {
      return ((x = Math.exp(x)) - 1 / x) / 2;
    }
    function d3_cosh(x) {
      return ((x = Math.exp(x)) + 1 / x) / 2;
    }
    function d3_tanh(x) {
      return ((x = Math.exp(2 * x)) - 1) / (x + 1);
    }
    function d3_haversin(x) {
      return (x = Math.sin(x / 2)) * x;
    }
    var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;
    d3.interpolateZoom = function(p0, p1) {
      var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2];
      var dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1), dr = r1 - r0, S = (dr || Math.log(w1 / w0)) / ρ;
      function interpolate(t) {
        var s = t * S;
        if (dr) {
          var coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
          return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];
        }
        return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * s) ];
      }
      interpolate.duration = S * 1e3;
      return interpolate;
    };
    d3.behavior.zoom = function() {
      var view = {
        x: 0,
        y: 0,
        k: 1
      }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
      function zoom(g) {
        g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
      }
      zoom.event = function(g) {
        g.each(function() {
          var dispatch = event.of(this, arguments), view1 = view;
          if (d3_transitionInheritId) {
            d3.select(this).transition().each("start.zoom", function() {
              view = this.__chart__ || {
                x: 0,
                y: 0,
                k: 1
              };
              zoomstarted(dispatch);
            }).tween("zoom:zoom", function() {
              var dx = size[0], dy = size[1], cx = dx / 2, cy = dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
              return function(t) {
                var l = i(t), k = dx / l[2];
                this.__chart__ = view = {
                  x: cx - l[0] * k,
                  y: cy - l[1] * k,
                  k: k
                };
                zoomed(dispatch);
              };
            }).each("end.zoom", function() {
              zoomended(dispatch);
            });
          } else {
            this.__chart__ = view;
            zoomstarted(dispatch);
            zoomed(dispatch);
            zoomended(dispatch);
          }
        });
      };
      zoom.translate = function(_) {
        if (!arguments.length) return [ view.x, view.y ];
        view = {
          x: +_[0],
          y: +_[1],
          k: view.k
        };
        rescale();
        return zoom;
      };
      zoom.scale = function(_) {
        if (!arguments.length) return view.k;
        view = {
          x: view.x,
          y: view.y,
          k: +_
        };
        rescale();
        return zoom;
      };
      zoom.scaleExtent = function(_) {
        if (!arguments.length) return scaleExtent;
        scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
        return zoom;
      };
      zoom.center = function(_) {
        if (!arguments.length) return center;
        center = _ && [ +_[0], +_[1] ];
        return zoom;
      };
      zoom.size = function(_) {
        if (!arguments.length) return size;
        size = _ && [ +_[0], +_[1] ];
        return zoom;
      };
      zoom.x = function(z) {
        if (!arguments.length) return x1;
        x1 = z;
        x0 = z.copy();
        view = {
          x: 0,
          y: 0,
          k: 1
        };
        return zoom;
      };
      zoom.y = function(z) {
        if (!arguments.length) return y1;
        y1 = z;
        y0 = z.copy();
        view = {
          x: 0,
          y: 0,
          k: 1
        };
        return zoom;
      };
      function location(p) {
        return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
      }
      function point(l) {
        return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
      }
      function scaleTo(s) {
        view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
      }
      function translateTo(p, l) {
        l = point(l);
        view.x += p[0] - l[0];
        view.y += p[1] - l[1];
      }
      function rescale() {
        if (x1) x1.domain(x0.range().map(function(x) {
          return (x - view.x) / view.k;
        }).map(x0.invert));
        if (y1) y1.domain(y0.range().map(function(y) {
          return (y - view.y) / view.k;
        }).map(y0.invert));
      }
      function zoomstarted(dispatch) {
        dispatch({
          type: "zoomstart"
        });
      }
      function zoomed(dispatch) {
        rescale();
        dispatch({
          type: "zoom",
          scale: view.k,
          translate: [ view.x, view.y ]
        });
      }
      function zoomended(dispatch) {
        dispatch({
          type: "zoomend"
        });
      }
      function mousedowned() {
        var that = this, target = d3.event.target, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress();
        d3_selection_interrupt.call(that);
        zoomstarted(dispatch);
        function moved() {
          dragged = 1;
          translateTo(d3.mouse(that), location0);
          zoomed(dispatch);
        }
        function ended() {
          subject.on(mousemove, null).on(mouseup, null);
          dragRestore(dragged && d3.event.target === target);
          zoomended(dispatch);
        }
      }
      function touchstarted() {
        var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that).on(mousedown, null).on(touchstart, started), dragRestore = d3_event_dragSuppress();
        d3_selection_interrupt.call(that);
        started();
        zoomstarted(dispatch);
        function relocate() {
          var touches = d3.touches(that);
          scale0 = view.k;
          touches.forEach(function(t) {
            if (t.identifier in locations0) locations0[t.identifier] = location(t);
          });
          return touches;
        }
        function started() {
          var target = d3.event.target;
          d3.select(target).on(touchmove, moved).on(touchend, ended);
          targets.push(target);
          var changed = d3.event.changedTouches;
          for (var i = 0, n = changed.length; i < n; ++i) {
            locations0[changed[i].identifier] = null;
          }
          var touches = relocate(), now = Date.now();
          if (touches.length === 1) {
            if (now - touchtime < 500) {
              var p = touches[0], l = locations0[p.identifier];
              scaleTo(view.k * 2);
              translateTo(p, l);
              d3_eventPreventDefault();
              zoomed(dispatch);
            }
            touchtime = now;
          } else if (touches.length > 1) {
            var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
            distance0 = dx * dx + dy * dy;
          }
        }
        function moved() {
          var touches = d3.touches(that), p0, l0, p1, l1;
          for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
            p1 = touches[i];
            if (l1 = locations0[p1.identifier]) {
              if (l0) break;
              p0 = p1, l0 = l1;
            }
          }
          if (l1) {
            var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
            p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
            l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
            scaleTo(scale1 * scale0);
          }
          touchtime = null;
          translateTo(p0, l0);
          zoomed(dispatch);
        }
        function ended() {
          if (d3.event.touches.length) {
            var changed = d3.event.changedTouches;
            for (var i = 0, n = changed.length; i < n; ++i) {
              delete locations0[changed[i].identifier];
            }
            for (var identifier in locations0) {
              return void relocate();
            }
          }
          d3.selectAll(targets).on(zoomName, null);
          subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
          dragRestore();
          zoomended(dispatch);
        }
      }
      function mousewheeled() {
        var dispatch = event.of(this, arguments);
        if (mousewheelTimer) clearTimeout(mousewheelTimer); else translate0 = location(center0 = center || d3.mouse(this)), 
        d3_selection_interrupt.call(this), zoomstarted(dispatch);
        mousewheelTimer = setTimeout(function() {
          mousewheelTimer = null;
          zoomended(dispatch);
        }, 50);
        d3_eventPreventDefault();
        scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
        translateTo(center0, translate0);
        zoomed(dispatch);
      }
      function dblclicked() {
        var dispatch = event.of(this, arguments), p = d3.mouse(this), l = location(p), k = Math.log(view.k) / Math.LN2;
        zoomstarted(dispatch);
        scaleTo(Math.pow(2, d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1));
        translateTo(p, l);
        zoomed(dispatch);
        zoomended(dispatch);
      }
      return d3.rebind(zoom, event, "on");
    };
    var d3_behavior_zoomInfinity = [ 0, Infinity ];
    var d3_behavior_zoomDelta, d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
      return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
    }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
      return d3.event.wheelDelta;
    }, "mousewheel") : (d3_behavior_zoomDelta = function() {
      return -d3.event.detail;
    }, "MozMousePixelScroll");
    d3.color = d3_color;
    function d3_color() {}
    d3_color.prototype.toString = function() {
      return this.rgb() + "";
    };
    d3.hsl = d3_hsl;
    function d3_hsl(h, s, l) {
      return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
    }
    var d3_hslPrototype = d3_hsl.prototype = new d3_color();
    d3_hslPrototype.brighter = function(k) {
      k = Math.pow(.7, arguments.length ? k : 1);
      return new d3_hsl(this.h, this.s, this.l / k);
    };
    d3_hslPrototype.darker = function(k) {
      k = Math.pow(.7, arguments.length ? k : 1);
      return new d3_hsl(this.h, this.s, k * this.l);
    };
    d3_hslPrototype.rgb = function() {
      return d3_hsl_rgb(this.h, this.s, this.l);
    };
    function d3_hsl_rgb(h, s, l) {
      var m1, m2;
      h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
      s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
      l = l < 0 ? 0 : l > 1 ? 1 : l;
      m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
      m1 = 2 * l - m2;
      function v(h) {
        if (h > 360) h -= 360; else if (h < 0) h += 360;
        if (h < 60) return m1 + (m2 - m1) * h / 60;
        if (h < 180) return m2;
        if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
        return m1;
      }
      function vv(h) {
        return Math.round(v(h) * 255);
      }
      return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
    }
    d3.hcl = d3_hcl;
    function d3_hcl(h, c, l) {
      return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
    }
    var d3_hclPrototype = d3_hcl.prototype = new d3_color();
    d3_hclPrototype.brighter = function(k) {
      return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
    };
    d3_hclPrototype.darker = function(k) {
      return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
    };
    d3_hclPrototype.rgb = function() {
      return d3_hcl_lab(this.h, this.c, this.l).rgb();
    };
    function d3_hcl_lab(h, c, l) {
      if (isNaN(h)) h = 0;
      if (isNaN(c)) c = 0;
      return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
    }
    d3.lab = d3_lab;
    function d3_lab(l, a, b) {
      return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.l, l.c, l.h) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
    }
    var d3_lab_K = 18;
    var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
    var d3_labPrototype = d3_lab.prototype = new d3_color();
    d3_labPrototype.brighter = function(k) {
      return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
    };
    d3_labPrototype.darker = function(k) {
      return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
    };
    d3_labPrototype.rgb = function() {
      return d3_lab_rgb(this.l, this.a, this.b);
    };
    function d3_lab_rgb(l, a, b) {
      var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
      x = d3_lab_xyz(x) * d3_lab_X;
      y = d3_lab_xyz(y) * d3_lab_Y;
      z = d3_lab_xyz(z) * d3_lab_Z;
      return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
    }
    function d3_lab_hcl(l, a, b) {
      return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
    }
    function d3_lab_xyz(x) {
      return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
    }
    function d3_xyz_lab(x) {
      return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
    }
    function d3_xyz_rgb(r) {
      return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
    }
    d3.rgb = d3_rgb;
    function d3_rgb(r, g, b) {
      return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
    }
    function d3_rgbNumber(value) {
      return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
    }
    function d3_rgbString(value) {
      return d3_rgbNumber(value) + "";
    }
    var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
    d3_rgbPrototype.brighter = function(k) {
      k = Math.pow(.7, arguments.length ? k : 1);
      var r = this.r, g = this.g, b = this.b, i = 30;
      if (!r && !g && !b) return new d3_rgb(i, i, i);
      if (r && r < i) r = i;
      if (g && g < i) g = i;
      if (b && b < i) b = i;
      return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
    };
    d3_rgbPrototype.darker = function(k) {
      k = Math.pow(.7, arguments.length ? k : 1);
      return new d3_rgb(k * this.r, k * this.g, k * this.b);
    };
    d3_rgbPrototype.hsl = function() {
      return d3_rgb_hsl(this.r, this.g, this.b);
    };
    d3_rgbPrototype.toString = function() {
      return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
    };
    function d3_rgb_hex(v) {
      return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
    }
    function d3_rgb_parse(format, rgb, hsl) {
      var r = 0, g = 0, b = 0, m1, m2, color;
      m1 = /([a-z]+)\((.*)\)/i.exec(format);
      if (m1) {
        m2 = m1[2].split(",");
        switch (m1[1]) {
         case "hsl":
          {
            return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
          }

         case "rgb":
          {
            return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
          }
        }
      }
      if (color = d3_rgb_names.get(format)) return rgb(color.r, color.g, color.b);
      if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.substring(1), 16))) {
        if (format.length === 4) {
          r = (color & 3840) >> 4;
          r = r >> 4 | r;
          g = color & 240;
          g = g >> 4 | g;
          b = color & 15;
          b = b << 4 | b;
        } else if (format.length === 7) {
          r = (color & 16711680) >> 16;
          g = (color & 65280) >> 8;
          b = color & 255;
        }
      }
      return rgb(r, g, b);
    }
    function d3_rgb_hsl(r, g, b) {
      var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
      if (d) {
        s = l < .5 ? d / (max + min) : d / (2 - max - min);
        if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
        h *= 60;
      } else {
        h = NaN;
        s = l > 0 && l < 1 ? 0 : h;
      }
      return new d3_hsl(h, s, l);
    }
    function d3_rgb_lab(r, g, b) {
      r = d3_rgb_xyz(r);
      g = d3_rgb_xyz(g);
      b = d3_rgb_xyz(b);
      var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
      return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
    }
    function d3_rgb_xyz(r) {
      return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
    }
    function d3_rgb_parseNumber(c) {
      var f = parseFloat(c);
      return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
    }
    var d3_rgb_names = d3.map({
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    });
    d3_rgb_names.forEach(function(key, value) {
      d3_rgb_names.set(key, d3_rgbNumber(value));
    });
    function d3_functor(v) {
      return typeof v === "function" ? v : function() {
        return v;
      };
    }
    d3.functor = d3_functor;
    function d3_identity(d) {
      return d;
    }
    d3.xhr = d3_xhrType(d3_identity);
    function d3_xhrType(response) {
      return function(url, mimeType, callback) {
        if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
        mimeType = null;
        return d3_xhr(url, mimeType, response, callback);
      };
    }
    function d3_xhr(url, mimeType, response, callback) {
      var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
      if (d3_window.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
      "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
        request.readyState > 3 && respond();
      };
      function respond() {
        var status = request.status, result;
        if (!status && request.responseText || status >= 200 && status < 300 || status === 304) {
          try {
            result = response.call(xhr, request);
          } catch (e) {
            dispatch.error.call(xhr, e);
            return;
          }
          dispatch.load.call(xhr, result);
        } else {
          dispatch.error.call(xhr, request);
        }
      }
      request.onprogress = function(event) {
        var o = d3.event;
        d3.event = event;
        try {
          dispatch.progress.call(xhr, request);
        } finally {
          d3.event = o;
        }
      };
      xhr.header = function(name, value) {
        name = (name + "").toLowerCase();
        if (arguments.length < 2) return headers[name];
        if (value == null) delete headers[name]; else headers[name] = value + "";
        return xhr;
      };
      xhr.mimeType = function(value) {
        if (!arguments.length) return mimeType;
        mimeType = value == null ? null : value + "";
        return xhr;
      };
      xhr.responseType = function(value) {
        if (!arguments.length) return responseType;
        responseType = value;
        return xhr;
      };
      xhr.response = function(value) {
        response = value;
        return xhr;
      };
      [ "get", "post" ].forEach(function(method) {
        xhr[method] = function() {
          return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
        };
      });
      xhr.send = function(method, data, callback) {
        if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
        request.open(method, url, true);
        if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
        if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
        if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
        if (responseType != null) request.responseType = responseType;
        if (callback != null) xhr.on("error", callback).on("load", function(request) {
          callback(null, request);
        });
        dispatch.beforesend.call(xhr, request);
        request.send(data == null ? null : data);
        return xhr;
      };
      xhr.abort = function() {
        request.abort();
        return xhr;
      };
      d3.rebind(xhr, dispatch, "on");
      return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
    }
    function d3_xhr_fixCallback(callback) {
      return callback.length === 1 ? function(error, request) {
        callback(error == null ? request : null);
      } : callback;
    }
    d3.dsv = function(delimiter, mimeType) {
      var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
      function dsv(url, row, callback) {
        if (arguments.length < 3) callback = row, row = null;
        var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
        xhr.row = function(_) {
          return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
        };
        return xhr;
      }
      function response(request) {
        return dsv.parse(request.responseText);
      }
      function typedResponse(f) {
        return function(request) {
          return dsv.parse(request.responseText, f);
        };
      }
      dsv.parse = function(text, f) {
        var o;
        return dsv.parseRows(text, function(row, i) {
          if (o) return o(row, i - 1);
          var a = new Function("d", "return {" + row.map(function(name, i) {
            return JSON.stringify(name) + ": d[" + i + "]";
          }).join(",") + "}");
          o = f ? function(row, i) {
            return f(a(row), i);
          } : a;
        });
      };
      dsv.parseRows = function(text, f) {
        var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
        function token() {
          if (I >= N) return EOF;
          if (eol) return eol = false, EOL;
          var j = I;
          if (text.charCodeAt(j) === 34) {
            var i = j;
            while (i++ < N) {
              if (text.charCodeAt(i) === 34) {
                if (text.charCodeAt(i + 1) !== 34) break;
                ++i;
              }
            }
            I = i + 2;
            var c = text.charCodeAt(i + 1);
            if (c === 13) {
              eol = true;
              if (text.charCodeAt(i + 2) === 10) ++I;
            } else if (c === 10) {
              eol = true;
            }
            return text.substring(j + 1, i).replace(/""/g, '"');
          }
          while (I < N) {
            var c = text.charCodeAt(I++), k = 1;
            if (c === 10) eol = true; else if (c === 13) {
              eol = true;
              if (text.charCodeAt(I) === 10) ++I, ++k;
            } else if (c !== delimiterCode) continue;
            return text.substring(j, I - k);
          }
          return text.substring(j);
        }
        while ((t = token()) !== EOF) {
          var a = [];
          while (t !== EOL && t !== EOF) {
            a.push(t);
            t = token();
          }
          if (f && !(a = f(a, n++))) continue;
          rows.push(a);
        }
        return rows;
      };
      dsv.format = function(rows) {
        if (Array.isArray(rows[0])) return dsv.formatRows(rows);
        var fieldSet = new d3_Set(), fields = [];
        rows.forEach(function(row) {
          for (var field in row) {
            if (!fieldSet.has(field)) {
              fields.push(fieldSet.add(field));
            }
          }
        });
        return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
          return fields.map(function(field) {
            return formatValue(row[field]);
          }).join(delimiter);
        })).join("\n");
      };
      dsv.formatRows = function(rows) {
        return rows.map(formatRow).join("\n");
      };
      function formatRow(row) {
        return row.map(formatValue).join(delimiter);
      }
      function formatValue(text) {
        return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
      }
      return dsv;
    };
    d3.csv = d3.dsv(",", "text/csv");
    d3.tsv = d3.dsv(" ", "text/tab-separated-values");
    d3.touch = function(container, touches, identifier) {
      if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
      if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
        if ((touch = touches[i]).identifier === identifier) {
          return d3_mousePoint(container, touch);
        }
      }
    };
    var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_active, d3_timer_frame = d3_window[d3_vendorSymbol(d3_window, "requestAnimationFrame")] || function(callback) {
      setTimeout(callback, 17);
    };
    d3.timer = function(callback, delay, then) {
      var n = arguments.length;
      if (n < 2) delay = 0;
      if (n < 3) then = Date.now();
      var time = then + delay, timer = {
        c: callback,
        t: time,
        f: false,
        n: null
      };
      if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
      d3_timer_queueTail = timer;
      if (!d3_timer_interval) {
        d3_timer_timeout = clearTimeout(d3_timer_timeout);
        d3_timer_interval = 1;
        d3_timer_frame(d3_timer_step);
      }
    };
    function d3_timer_step() {
      var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
      if (delay > 24) {
        if (isFinite(delay)) {
          clearTimeout(d3_timer_timeout);
          d3_timer_timeout = setTimeout(d3_timer_step, delay);
        }
        d3_timer_interval = 0;
      } else {
        d3_timer_interval = 1;
        d3_timer_frame(d3_timer_step);
      }
    }
    d3.timer.flush = function() {
      d3_timer_mark();
      d3_timer_sweep();
    };
    function d3_timer_mark() {
      var now = Date.now();
      d3_timer_active = d3_timer_queueHead;
      while (d3_timer_active) {
        if (now >= d3_timer_active.t) d3_timer_active.f = d3_timer_active.c(now - d3_timer_active.t);
        d3_timer_active = d3_timer_active.n;
      }
      return now;
    }
    function d3_timer_sweep() {
      var t0, t1 = d3_timer_queueHead, time = Infinity;
      while (t1) {
        if (t1.f) {
          t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
        } else {
          if (t1.t < time) time = t1.t;
          t1 = (t0 = t1).n;
        }
      }
      d3_timer_queueTail = t0;
      return time;
    }
    function d3_format_precision(x, p) {
      return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
    }
    d3.round = function(x, n) {
      return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
    };
    var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
    d3.formatPrefix = function(value, precision) {
      var i = 0;
      if (value) {
        if (value < 0) value *= -1;
        if (precision) value = d3.round(value, d3_format_precision(value, precision));
        i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
        i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
      }
      return d3_formatPrefixes[8 + i / 3];
    };
    function d3_formatPrefix(d, i) {
      var k = Math.pow(10, abs(8 - i) * 3);
      return {
        scale: i > 8 ? function(d) {
          return d / k;
        } : function(d) {
          return d * k;
        },
        symbol: d
      };
    }
    function d3_locale_numberFormat(locale) {
      var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping ? function(value) {
        var i = value.length, t = [], j = 0, g = locale_grouping[0];
        while (i > 0 && g > 0) {
          t.push(value.substring(i -= g, i + g));
          g = locale_grouping[j = (j + 1) % locale_grouping.length];
        }
        return t.reverse().join(locale_thousands);
      } : d3_identity;
      return function(specifier) {
        var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false;
        if (precision) precision = +precision.substring(1);
        if (zfill || fill === "0" && align === "=") {
          zfill = fill = "0";
          align = "=";
          if (comma) width -= Math.floor((width - 1) / 4);
        }
        switch (type) {
         case "n":
          comma = true;
          type = "g";
          break;

         case "%":
          scale = 100;
          suffix = "%";
          type = "f";
          break;

         case "p":
          scale = 100;
          suffix = "%";
          type = "r";
          break;

         case "b":
         case "o":
         case "x":
         case "X":
          if (symbol === "#") prefix = "0" + type.toLowerCase();

         case "c":
         case "d":
          integer = true;
          precision = 0;
          break;

         case "s":
          scale = -1;
          type = "r";
          break;
        }
        if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
        if (type == "r" && !precision) type = "g";
        if (precision != null) {
          if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
        }
        type = d3_format_types.get(type) || d3_format_typeDefault;
        var zcomma = zfill && comma;
        return function(value) {
          var fullSuffix = suffix;
          if (integer && value % 1) return "";
          var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign;
          if (scale < 0) {
            var unit = d3.formatPrefix(value, precision);
            value = unit.scale(value);
            fullSuffix = unit.symbol + suffix;
          } else {
            value *= scale;
          }
          value = type(value, precision);
          var i = value.lastIndexOf("."), before = i < 0 ? value : value.substring(0, i), after = i < 0 ? "" : locale_decimal + value.substring(i + 1);
          if (!zfill && comma) before = formatGroup(before);
          var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
          if (zcomma) before = formatGroup(padding + before);
          negative += prefix;
          value = before + after;
          return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
        };
      };
    }
    var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
    var d3_format_types = d3.map({
      b: function(x) {
        return x.toString(2);
      },
      c: function(x) {
        return String.fromCharCode(x);
      },
      o: function(x) {
        return x.toString(8);
      },
      x: function(x) {
        return x.toString(16);
      },
      X: function(x) {
        return x.toString(16).toUpperCase();
      },
      g: function(x, p) {
        return x.toPrecision(p);
      },
      e: function(x, p) {
        return x.toExponential(p);
      },
      f: function(x, p) {
        return x.toFixed(p);
      },
      r: function(x, p) {
        return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
      }
    });
    function d3_format_typeDefault(x) {
      return x + "";
    }
    var d3_time = d3.time = {}, d3_date = Date;
    function d3_date_utc() {
      this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
    }
    d3_date_utc.prototype = {
      getDate: function() {
        return this._.getUTCDate();
      },
      getDay: function() {
        return this._.getUTCDay();
      },
      getFullYear: function() {
        return this._.getUTCFullYear();
      },
      getHours: function() {
        return this._.getUTCHours();
      },
      getMilliseconds: function() {
        return this._.getUTCMilliseconds();
      },
      getMinutes: function() {
        return this._.getUTCMinutes();
      },
      getMonth: function() {
        return this._.getUTCMonth();
      },
      getSeconds: function() {
        return this._.getUTCSeconds();
      },
      getTime: function() {
        return this._.getTime();
      },
      getTimezoneOffset: function() {
        return 0;
      },
      valueOf: function() {
        return this._.valueOf();
      },
      setDate: function() {
        d3_time_prototype.setUTCDate.apply(this._, arguments);
      },
      setDay: function() {
        d3_time_prototype.setUTCDay.apply(this._, arguments);
      },
      setFullYear: function() {
        d3_time_prototype.setUTCFullYear.apply(this._, arguments);
      },
      setHours: function() {
        d3_time_prototype.setUTCHours.apply(this._, arguments);
      },
      setMilliseconds: function() {
        d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
      },
      setMinutes: function() {
        d3_time_prototype.setUTCMinutes.apply(this._, arguments);
      },
      setMonth: function() {
        d3_time_prototype.setUTCMonth.apply(this._, arguments);
      },
      setSeconds: function() {
        d3_time_prototype.setUTCSeconds.apply(this._, arguments);
      },
      setTime: function() {
        d3_time_prototype.setTime.apply(this._, arguments);
      }
    };
    var d3_time_prototype = Date.prototype;
    function d3_time_interval(local, step, number) {
      function round(date) {
        var d0 = local(date), d1 = offset(d0, 1);
        return date - d0 < d1 - date ? d0 : d1;
      }
      function ceil(date) {
        step(date = local(new d3_date(date - 1)), 1);
        return date;
      }
      function offset(date, k) {
        step(date = new d3_date(+date), k);
        return date;
      }
      function range(t0, t1, dt) {
        var time = ceil(t0), times = [];
        if (dt > 1) {
          while (time < t1) {
            if (!(number(time) % dt)) times.push(new Date(+time));
            step(time, 1);
          }
        } else {
          while (time < t1) times.push(new Date(+time)), step(time, 1);
        }
        return times;
      }
      function range_utc(t0, t1, dt) {
        try {
          d3_date = d3_date_utc;
          var utc = new d3_date_utc();
          utc._ = t0;
          return range(utc, t1, dt);
        } finally {
          d3_date = Date;
        }
      }
      local.floor = local;
      local.round = round;
      local.ceil = ceil;
      local.offset = offset;
      local.range = range;
      var utc = local.utc = d3_time_interval_utc(local);
      utc.floor = utc;
      utc.round = d3_time_interval_utc(round);
      utc.ceil = d3_time_interval_utc(ceil);
      utc.offset = d3_time_interval_utc(offset);
      utc.range = range_utc;
      return local;
    }
    function d3_time_interval_utc(method) {
      return function(date, k) {
        try {
          d3_date = d3_date_utc;
          var utc = new d3_date_utc();
          utc._ = date;
          return method(utc, k)._;
        } finally {
          d3_date = Date;
        }
      };
    }
    d3_time.year = d3_time_interval(function(date) {
      date = d3_time.day(date);
      date.setMonth(0, 1);
      return date;
    }, function(date, offset) {
      date.setFullYear(date.getFullYear() + offset);
    }, function(date) {
      return date.getFullYear();
    });
    d3_time.years = d3_time.year.range;
    d3_time.years.utc = d3_time.year.utc.range;
    d3_time.day = d3_time_interval(function(date) {
      var day = new d3_date(2e3, 0);
      day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
      return day;
    }, function(date, offset) {
      date.setDate(date.getDate() + offset);
    }, function(date) {
      return date.getDate() - 1;
    });
    d3_time.days = d3_time.day.range;
    d3_time.days.utc = d3_time.day.utc.range;
    d3_time.dayOfYear = function(date) {
      var year = d3_time.year(date);
      return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
    };
    [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
      i = 7 - i;
      var interval = d3_time[day] = d3_time_interval(function(date) {
        (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
        return date;
      }, function(date, offset) {
        date.setDate(date.getDate() + Math.floor(offset) * 7);
      }, function(date) {
        var day = d3_time.year(date).getDay();
        return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
      });
      d3_time[day + "s"] = interval.range;
      d3_time[day + "s"].utc = interval.utc.range;
      d3_time[day + "OfYear"] = function(date) {
        var day = d3_time.year(date).getDay();
        return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
      };
    });
    d3_time.week = d3_time.sunday;
    d3_time.weeks = d3_time.sunday.range;
    d3_time.weeks.utc = d3_time.sunday.utc.range;
    d3_time.weekOfYear = d3_time.sundayOfYear;
    function d3_locale_timeFormat(locale) {
      var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
      function d3_time_format(template) {
        var n = template.length;
        function format(date) {
          var string = [], i = -1, j = 0, c, p, f;
          while (++i < n) {
            if (template.charCodeAt(i) === 37) {
              string.push(template.substring(j, i));
              if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
              if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
              string.push(c);
              j = i + 1;
            }
          }
          string.push(template.substring(j, i));
          return string.join("");
        }
        format.parse = function(string) {
          var d = {
            y: 1900,
            m: 0,
            d: 1,
            H: 0,
            M: 0,
            S: 0,
            L: 0,
            Z: null
          }, i = d3_time_parse(d, template, string, 0);
          if (i != string.length) return null;
          if ("p" in d) d.H = d.H % 12 + d.p * 12;
          var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
          if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("w" in d && ("W" in d || "U" in d)) {
            date.setFullYear(d.y, 0, 1);
            date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
          } else date.setFullYear(d.y, d.m, d.d);
          date.setHours(d.H + Math.floor(d.Z / 100), d.M + d.Z % 100, d.S, d.L);
          return localZ ? date._ : date;
        };
        format.toString = function() {
          return template;
        };
        return format;
      }
      function d3_time_parse(date, template, string, j) {
        var c, p, t, i = 0, n = template.length, m = string.length;
        while (i < n) {
          if (j >= m) return -1;
          c = template.charCodeAt(i++);
          if (c === 37) {
            t = template.charAt(i++);
            p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
            if (!p || (j = p(date, string, j)) < 0) return -1;
          } else if (c != string.charCodeAt(j++)) {
            return -1;
          }
        }
        return j;
      }
      d3_time_format.utc = function(template) {
        var local = d3_time_format(template);
        function format(date) {
          try {
            d3_date = d3_date_utc;
            var utc = new d3_date();
            utc._ = date;
            return local(utc);
          } finally {
            d3_date = Date;
          }
        }
        format.parse = function(string) {
          try {
            d3_date = d3_date_utc;
            var date = local.parse(string);
            return date && date._;
          } finally {
            d3_date = Date;
          }
        };
        format.toString = local.toString;
        return format;
      };
      d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
      var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
      locale_periods.forEach(function(p, i) {
        d3_time_periodLookup.set(p.toLowerCase(), i);
      });
      var d3_time_formats = {
        a: function(d) {
          return locale_shortDays[d.getDay()];
        },
        A: function(d) {
          return locale_days[d.getDay()];
        },
        b: function(d) {
          return locale_shortMonths[d.getMonth()];
        },
        B: function(d) {
          return locale_months[d.getMonth()];
        },
        c: d3_time_format(locale_dateTime),
        d: function(d, p) {
          return d3_time_formatPad(d.getDate(), p, 2);
        },
        e: function(d, p) {
          return d3_time_formatPad(d.getDate(), p, 2);
        },
        H: function(d, p) {
          return d3_time_formatPad(d.getHours(), p, 2);
        },
        I: function(d, p) {
          return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
        },
        j: function(d, p) {
          return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
        },
        L: function(d, p) {
          return d3_time_formatPad(d.getMilliseconds(), p, 3);
        },
        m: function(d, p) {
          return d3_time_formatPad(d.getMonth() + 1, p, 2);
        },
        M: function(d, p) {
          return d3_time_formatPad(d.getMinutes(), p, 2);
        },
        p: function(d) {
          return locale_periods[+(d.getHours() >= 12)];
        },
        S: function(d, p) {
          return d3_time_formatPad(d.getSeconds(), p, 2);
        },
        U: function(d, p) {
          return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
        },
        w: function(d) {
          return d.getDay();
        },
        W: function(d, p) {
          return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
        },
        x: d3_time_format(locale_date),
        X: d3_time_format(locale_time),
        y: function(d, p) {
          return d3_time_formatPad(d.getFullYear() % 100, p, 2);
        },
        Y: function(d, p) {
          return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
        },
        Z: d3_time_zone,
        "%": function() {
          return "%";
        }
      };
      var d3_time_parsers = {
        a: d3_time_parseWeekdayAbbrev,
        A: d3_time_parseWeekday,
        b: d3_time_parseMonthAbbrev,
        B: d3_time_parseMonth,
        c: d3_time_parseLocaleFull,
        d: d3_time_parseDay,
        e: d3_time_parseDay,
        H: d3_time_parseHour24,
        I: d3_time_parseHour24,
        j: d3_time_parseDayOfYear,
        L: d3_time_parseMilliseconds,
        m: d3_time_parseMonthNumber,
        M: d3_time_parseMinutes,
        p: d3_time_parseAmPm,
        S: d3_time_parseSeconds,
        U: d3_time_parseWeekNumberSunday,
        w: d3_time_parseWeekdayNumber,
        W: d3_time_parseWeekNumberMonday,
        x: d3_time_parseLocaleDate,
        X: d3_time_parseLocaleTime,
        y: d3_time_parseYear,
        Y: d3_time_parseFullYear,
        Z: d3_time_parseZone,
        "%": d3_time_parseLiteralPercent
      };
      function d3_time_parseWeekdayAbbrev(date, string, i) {
        d3_time_dayAbbrevRe.lastIndex = 0;
        var n = d3_time_dayAbbrevRe.exec(string.substring(i));
        return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }
      function d3_time_parseWeekday(date, string, i) {
        d3_time_dayRe.lastIndex = 0;
        var n = d3_time_dayRe.exec(string.substring(i));
        return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }
      function d3_time_parseMonthAbbrev(date, string, i) {
        d3_time_monthAbbrevRe.lastIndex = 0;
        var n = d3_time_monthAbbrevRe.exec(string.substring(i));
        return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }
      function d3_time_parseMonth(date, string, i) {
        d3_time_monthRe.lastIndex = 0;
        var n = d3_time_monthRe.exec(string.substring(i));
        return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }
      function d3_time_parseLocaleFull(date, string, i) {
        return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
      }
      function d3_time_parseLocaleDate(date, string, i) {
        return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
      }
      function d3_time_parseLocaleTime(date, string, i) {
        return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
      }
      function d3_time_parseAmPm(date, string, i) {
        var n = d3_time_periodLookup.get(string.substring(i, i += 2).toLowerCase());
        return n == null ? -1 : (date.p = n, i);
      }
      return d3_time_format;
    }
    var d3_time_formatPads = {
      "-": "",
      _: " ",
      "0": "0"
    }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
    function d3_time_formatPad(value, fill, width) {
      var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
      return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }
    function d3_time_formatRe(names) {
      return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
    }
    function d3_time_formatLookup(names) {
      var map = new d3_Map(), i = -1, n = names.length;
      while (++i < n) map.set(names[i].toLowerCase(), i);
      return map;
    }
    function d3_time_parseWeekdayNumber(date, string, i) {
      d3_time_numberRe.lastIndex = 0;
      var n = d3_time_numberRe.exec(string.substring(i, i + 1));
      return n ? (date.w = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseWeekNumberSunday(date, string, i) {
      d3_time_numberRe.lastIndex = 0;
      var n = d3_time_numberRe.exec(string.substring(i));
      return n ? (date.U = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseWeekNumberMonday(date, string, i) {
      d3_time_numberRe.lastIndex = 0;
      var n = d3_time_numberRe.exec(string.substring(i));
      return n ? (date.W = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseFullYear(date, string, i) {
      d3_time_numberRe.lastIndex = 0;
      var n = d3_time_numberRe.exec(string.substring(i, i + 4));
      return n ? (date.y = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseYear(date, string, i) {
      d3_time_numberRe.lastIndex = 0;
      var n = d3_time_numberRe.exec(string.substring(i, i + 2));
      return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
    }
    function d3_time_parseZone(date, string, i) {
      return /^[+-]\d{4}$/.test(string = string.substring(i, i + 5)) ? (date.Z = -string, 
      i + 5) : -1;
    }
    function d3_time_expandYear(d) {
      return d + (d > 68 ? 1900 : 2e3);
    }
    function d3_time_parseMonthNumber(date, string, i) {
      d3_time_numberRe.lastIndex = 0;
      var n = d3_time_numberRe.exec(string.substring(i, i + 2));
      return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
    }
    function d3_time_parseDay(date, string, i) {
      d3_time_numberRe.lastIndex = 0;
      var n = d3_time_numberRe.exec(string.substring(i, i + 2));
      return n ? (date.d = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseDayOfYear(date, string, i) {
      d3_time_numberRe.lastIndex = 0;
      var n = d3_time_numberRe.exec(string.substring(i, i + 3));
      return n ? (date.j = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseHour24(date, string, i) {
      d3_time_numberRe.lastIndex = 0;
      var n = d3_time_numberRe.exec(string.substring(i, i + 2));
      return n ? (date.H = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseMinutes(date, string, i) {
      d3_time_numberRe.lastIndex = 0;
      var n = d3_time_numberRe.exec(string.substring(i, i + 2));
      return n ? (date.M = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseSeconds(date, string, i) {
      d3_time_numberRe.lastIndex = 0;
      var n = d3_time_numberRe.exec(string.substring(i, i + 2));
      return n ? (date.S = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseMilliseconds(date, string, i) {
      d3_time_numberRe.lastIndex = 0;
      var n = d3_time_numberRe.exec(string.substring(i, i + 3));
      return n ? (date.L = +n[0], i + n[0].length) : -1;
    }
    function d3_time_zone(d) {
      var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = ~~(abs(z) / 60), zm = abs(z) % 60;
      return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
    }
    function d3_time_parseLiteralPercent(date, string, i) {
      d3_time_percentRe.lastIndex = 0;
      var n = d3_time_percentRe.exec(string.substring(i, i + 1));
      return n ? i + n[0].length : -1;
    }
    function d3_time_formatMulti(formats) {
      var n = formats.length, i = -1;
      while (++i < n) formats[i][0] = this(formats[i][0]);
      return function(date) {
        var i = 0, f = formats[i];
        while (!f[1](date)) f = formats[++i];
        return f[0](date);
      };
    }
    d3.locale = function(locale) {
      return {
        numberFormat: d3_locale_numberFormat(locale),
        timeFormat: d3_locale_timeFormat(locale)
      };
    };
    var d3_locale_enUS = d3.locale({
      decimal: ".",
      thousands: ",",
      grouping: [ 3 ],
      currency: [ "$", "" ],
      dateTime: "%a %b %e %X %Y",
      date: "%m/%d/%Y",
      time: "%H:%M:%S",
      periods: [ "AM", "PM" ],
      days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
      shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
      months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
      shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
    });
    d3.format = d3_locale_enUS.numberFormat;
    d3.geo = {};
    function d3_adder() {}
    d3_adder.prototype = {
      s: 0,
      t: 0,
      add: function(y) {
        d3_adderSum(y, this.t, d3_adderTemp);
        d3_adderSum(d3_adderTemp.s, this.s, this);
        if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
      },
      reset: function() {
        this.s = this.t = 0;
      },
      valueOf: function() {
        return this.s;
      }
    };
    var d3_adderTemp = new d3_adder();
    function d3_adderSum(a, b, o) {
      var x = o.s = a + b, bv = x - a, av = x - bv;
      o.t = a - av + (b - bv);
    }
    d3.geo.stream = function(object, listener) {
      if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
        d3_geo_streamObjectType[object.type](object, listener);
      } else {
        d3_geo_streamGeometry(object, listener);
      }
    };
    function d3_geo_streamGeometry(geometry, listener) {
      if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
        d3_geo_streamGeometryType[geometry.type](geometry, listener);
      }
    }
    var d3_geo_streamObjectType = {
      Feature: function(feature, listener) {
        d3_geo_streamGeometry(feature.geometry, listener);
      },
      FeatureCollection: function(object, listener) {
        var features = object.features, i = -1, n = features.length;
        while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
      }
    };
    var d3_geo_streamGeometryType = {
      Sphere: function(object, listener) {
        listener.sphere();
      },
      Point: function(object, listener) {
        object = object.coordinates;
        listener.point(object[0], object[1], object[2]);
      },
      MultiPoint: function(object, listener) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
      },
      LineString: function(object, listener) {
        d3_geo_streamLine(object.coordinates, listener, 0);
      },
      MultiLineString: function(object, listener) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
      },
      Polygon: function(object, listener) {
        d3_geo_streamPolygon(object.coordinates, listener);
      },
      MultiPolygon: function(object, listener) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
      },
      GeometryCollection: function(object, listener) {
        var geometries = object.geometries, i = -1, n = geometries.length;
        while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
      }
    };
    function d3_geo_streamLine(coordinates, listener, closed) {
      var i = -1, n = coordinates.length - closed, coordinate;
      listener.lineStart();
      while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
      listener.lineEnd();
    }
    function d3_geo_streamPolygon(coordinates, listener) {
      var i = -1, n = coordinates.length;
      listener.polygonStart();
      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
      listener.polygonEnd();
    }
    d3.geo.area = function(object) {
      d3_geo_areaSum = 0;
      d3.geo.stream(object, d3_geo_area);
      return d3_geo_areaSum;
    };
    var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
    var d3_geo_area = {
      sphere: function() {
        d3_geo_areaSum += 4 * π;
      },
      point: d3_noop,
      lineStart: d3_noop,
      lineEnd: d3_noop,
      polygonStart: function() {
        d3_geo_areaRingSum.reset();
        d3_geo_area.lineStart = d3_geo_areaRingStart;
      },
      polygonEnd: function() {
        var area = 2 * d3_geo_areaRingSum;
        d3_geo_areaSum += area < 0 ? 4 * π + area : area;
        d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
      }
    };
    function d3_geo_areaRingStart() {
      var λ00, φ00, λ0, cosφ0, sinφ0;
      d3_geo_area.point = function(λ, φ) {
        d3_geo_area.point = nextPoint;
        λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), 
        sinφ0 = Math.sin(φ);
      };
      function nextPoint(λ, φ) {
        λ *= d3_radians;
        φ = φ * d3_radians / 2 + π / 4;
        var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);
        d3_geo_areaRingSum.add(Math.atan2(v, u));
        λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
      }
      d3_geo_area.lineEnd = function() {
        nextPoint(λ00, φ00);
      };
    }
    function d3_geo_cartesian(spherical) {
      var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
      return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
    }
    function d3_geo_cartesianDot(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }
    function d3_geo_cartesianCross(a, b) {
      return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
    }
    function d3_geo_cartesianAdd(a, b) {
      a[0] += b[0];
      a[1] += b[1];
      a[2] += b[2];
    }
    function d3_geo_cartesianScale(vector, k) {
      return [ vector[0] * k, vector[1] * k, vector[2] * k ];
    }
    function d3_geo_cartesianNormalize(d) {
      var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
      d[0] /= l;
      d[1] /= l;
      d[2] /= l;
    }
    function d3_geo_spherical(cartesian) {
      return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
    }
    function d3_geo_sphericalEqual(a, b) {
      return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
    }
    d3.geo.bounds = function() {
      var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
      var bound = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          bound.point = ringPoint;
          bound.lineStart = ringStart;
          bound.lineEnd = ringEnd;
          dλSum = 0;
          d3_geo_area.polygonStart();
        },
        polygonEnd: function() {
          d3_geo_area.polygonEnd();
          bound.point = point;
          bound.lineStart = lineStart;
          bound.lineEnd = lineEnd;
          if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;
          range[0] = λ0, range[1] = λ1;
        }
      };
      function point(λ, φ) {
        ranges.push(range = [ λ0 = λ, λ1 = λ ]);
        if (φ < φ0) φ0 = φ;
        if (φ > φ1) φ1 = φ;
      }
      function linePoint(λ, φ) {
        var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);
        if (p0) {
          var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
          d3_geo_cartesianNormalize(inflection);
          inflection = d3_geo_spherical(inflection);
          var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;
          if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
            var φi = inflection[1] * d3_degrees;
            if (φi > φ1) φ1 = φi;
          } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
            var φi = -inflection[1] * d3_degrees;
            if (φi < φ0) φ0 = φi;
          } else {
            if (φ < φ0) φ0 = φ;
            if (φ > φ1) φ1 = φ;
          }
          if (antimeridian) {
            if (λ < λ_) {
              if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
            } else {
              if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
            }
          } else {
            if (λ1 >= λ0) {
              if (λ < λ0) λ0 = λ;
              if (λ > λ1) λ1 = λ;
            } else {
              if (λ > λ_) {
                if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
              } else {
                if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
              }
            }
          }
        } else {
          point(λ, φ);
        }
        p0 = p, λ_ = λ;
      }
      function lineStart() {
        bound.point = linePoint;
      }
      function lineEnd() {
        range[0] = λ0, range[1] = λ1;
        bound.point = point;
        p0 = null;
      }
      function ringPoint(λ, φ) {
        if (p0) {
          var dλ = λ - λ_;
          dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
        } else λ__ = λ, φ__ = φ;
        d3_geo_area.point(λ, φ);
        linePoint(λ, φ);
      }
      function ringStart() {
        d3_geo_area.lineStart();
      }
      function ringEnd() {
        ringPoint(λ__, φ__);
        d3_geo_area.lineEnd();
        if (abs(dλSum) > ε) λ0 = -(λ1 = 180);
        range[0] = λ0, range[1] = λ1;
        p0 = null;
      }
      function angle(λ0, λ1) {
        return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
      }
      function compareRanges(a, b) {
        return a[0] - b[0];
      }
      function withinRange(x, range) {
        return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
      }
      return function(feature) {
        φ1 = λ1 = -(λ0 = φ0 = Infinity);
        ranges = [];
        d3.geo.stream(feature, bound);
        var n = ranges.length;
        if (n) {
          ranges.sort(compareRanges);
          for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
            b = ranges[i];
            if (withinRange(b[0], a) || withinRange(b[1], a)) {
              if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
              if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
            } else {
              merged.push(a = b);
            }
          }
          var best = -Infinity, dλ;
          for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
            b = merged[i];
            if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
          }
        }
        ranges = range = null;
        return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];
      };
    }();
    d3.geo.centroid = function(object) {
      d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
      d3.geo.stream(object, d3_geo_centroid);
      var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
      if (m < ε2) {
        x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
        if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
        m = x * x + y * y + z * z;
        if (m < ε2) return [ NaN, NaN ];
      }
      return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
    };
    var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
    var d3_geo_centroid = {
      sphere: d3_noop,
      point: d3_geo_centroidPoint,
      lineStart: d3_geo_centroidLineStart,
      lineEnd: d3_geo_centroidLineEnd,
      polygonStart: function() {
        d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
      },
      polygonEnd: function() {
        d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
      }
    };
    function d3_geo_centroidPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
    }
    function d3_geo_centroidPointXYZ(x, y, z) {
      ++d3_geo_centroidW0;
      d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
      d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
      d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
    }
    function d3_geo_centroidLineStart() {
      var x0, y0, z0;
      d3_geo_centroid.point = function(λ, φ) {
        λ *= d3_radians;
        var cosφ = Math.cos(φ *= d3_radians);
        x0 = cosφ * Math.cos(λ);
        y0 = cosφ * Math.sin(λ);
        z0 = Math.sin(φ);
        d3_geo_centroid.point = nextPoint;
        d3_geo_centroidPointXYZ(x0, y0, z0);
      };
      function nextPoint(λ, φ) {
        λ *= d3_radians;
        var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
        d3_geo_centroidW1 += w;
        d3_geo_centroidX1 += w * (x0 + (x0 = x));
        d3_geo_centroidY1 += w * (y0 + (y0 = y));
        d3_geo_centroidZ1 += w * (z0 + (z0 = z));
        d3_geo_centroidPointXYZ(x0, y0, z0);
      }
    }
    function d3_geo_centroidLineEnd() {
      d3_geo_centroid.point = d3_geo_centroidPoint;
    }
    function d3_geo_centroidRingStart() {
      var λ00, φ00, x0, y0, z0;
      d3_geo_centroid.point = function(λ, φ) {
        λ00 = λ, φ00 = φ;
        d3_geo_centroid.point = nextPoint;
        λ *= d3_radians;
        var cosφ = Math.cos(φ *= d3_radians);
        x0 = cosφ * Math.cos(λ);
        y0 = cosφ * Math.sin(λ);
        z0 = Math.sin(φ);
        d3_geo_centroidPointXYZ(x0, y0, z0);
      };
      d3_geo_centroid.lineEnd = function() {
        nextPoint(λ00, φ00);
        d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
        d3_geo_centroid.point = d3_geo_centroidPoint;
      };
      function nextPoint(λ, φ) {
        λ *= d3_radians;
        var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
        d3_geo_centroidX2 += v * cx;
        d3_geo_centroidY2 += v * cy;
        d3_geo_centroidZ2 += v * cz;
        d3_geo_centroidW1 += w;
        d3_geo_centroidX1 += w * (x0 + (x0 = x));
        d3_geo_centroidY1 += w * (y0 + (y0 = y));
        d3_geo_centroidZ1 += w * (z0 + (z0 = z));
        d3_geo_centroidPointXYZ(x0, y0, z0);
      }
    }
    function d3_true() {
      return true;
    }
    function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
      var subject = [], clip = [];
      segments.forEach(function(segment) {
        if ((n = segment.length - 1) <= 0) return;
        var n, p0 = segment[0], p1 = segment[n];
        if (d3_geo_sphericalEqual(p0, p1)) {
          listener.lineStart();
          for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
          listener.lineEnd();
          return;
        }
        var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
        a.o = b;
        subject.push(a);
        clip.push(b);
        a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
        b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
        a.o = b;
        subject.push(a);
        clip.push(b);
      });
      clip.sort(compare);
      d3_geo_clipPolygonLinkCircular(subject);
      d3_geo_clipPolygonLinkCircular(clip);
      if (!subject.length) return;
      for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
        clip[i].e = entry = !entry;
      }
      var start = subject[0], points, point;
      while (1) {
        var current = start, isSubject = true;
        while (current.v) if ((current = current.n) === start) return;
        points = current.z;
        listener.lineStart();
        do {
          current.v = current.o.v = true;
          if (current.e) {
            if (isSubject) {
              for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.n.x, 1, listener);
            }
            current = current.n;
          } else {
            if (isSubject) {
              points = current.p.z;
              for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.p.x, -1, listener);
            }
            current = current.p;
          }
          current = current.o;
          points = current.z;
          isSubject = !isSubject;
        } while (!current.v);
        listener.lineEnd();
      }
    }
    function d3_geo_clipPolygonLinkCircular(array) {
      if (!(n = array.length)) return;
      var n, i = 0, a = array[0], b;
      while (++i < n) {
        a.n = b = array[i];
        b.p = a;
        a = b;
      }
      a.n = b = array[0];
      b.p = a;
    }
    function d3_geo_clipPolygonIntersection(point, points, other, entry) {
      this.x = point;
      this.z = points;
      this.o = other;
      this.e = entry;
      this.v = false;
      this.n = this.p = null;
    }
    function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
      return function(rotate, listener) {
        var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
        var clip = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() {
            clip.point = pointRing;
            clip.lineStart = ringStart;
            clip.lineEnd = ringEnd;
            segments = [];
            polygon = [];
          },
          polygonEnd: function() {
            clip.point = point;
            clip.lineStart = lineStart;
            clip.lineEnd = lineEnd;
            segments = d3.merge(segments);
            var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
            if (segments.length) {
              if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
              d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
            } else if (clipStartInside) {
              if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
              listener.lineStart();
              interpolate(null, null, 1, listener);
              listener.lineEnd();
            }
            if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
            segments = polygon = null;
          },
          sphere: function() {
            listener.polygonStart();
            listener.lineStart();
            interpolate(null, null, 1, listener);
            listener.lineEnd();
            listener.polygonEnd();
          }
        };
        function point(λ, φ) {
          var point = rotate(λ, φ);
          if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
        }
        function pointLine(λ, φ) {
          var point = rotate(λ, φ);
          line.point(point[0], point[1]);
        }
        function lineStart() {
          clip.point = pointLine;
          line.lineStart();
        }
        function lineEnd() {
          clip.point = point;
          line.lineEnd();
        }
        var segments;
        var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
        function pointRing(λ, φ) {
          ring.push([ λ, φ ]);
          var point = rotate(λ, φ);
          ringListener.point(point[0], point[1]);
        }
        function ringStart() {
          ringListener.lineStart();
          ring = [];
        }
        function ringEnd() {
          pointRing(ring[0][0], ring[0][1]);
          ringListener.lineEnd();
          var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
          ring.pop();
          polygon.push(ring);
          ring = null;
          if (!n) return;
          if (clean & 1) {
            segment = ringSegments[0];
            var n = segment.length - 1, i = -1, point;
            if (n > 0) {
              if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
              listener.lineStart();
              while (++i < n) listener.point((point = segment[i])[0], point[1]);
              listener.lineEnd();
            }
            return;
          }
          if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
          segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
        }
        return clip;
      };
    }
    function d3_geo_clipSegmentLength1(segment) {
      return segment.length > 1;
    }
    function d3_geo_clipBufferListener() {
      var lines = [], line;
      return {
        lineStart: function() {
          lines.push(line = []);
        },
        point: function(λ, φ) {
          line.push([ λ, φ ]);
        },
        lineEnd: d3_noop,
        buffer: function() {
          var buffer = lines;
          lines = [];
          line = null;
          return buffer;
        },
        rejoin: function() {
          if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
        }
      };
    }
    function d3_geo_clipSort(a, b) {
      return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
    }
    function d3_geo_pointInPolygon(point, polygon) {
      var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
      d3_geo_areaRingSum.reset();
      for (var i = 0, n = polygon.length; i < n; ++i) {
        var ring = polygon[i], m = ring.length;
        if (!m) continue;
        var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;
        while (true) {
          if (j === m) j = 0;
          point = ring[j];
          var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;
          d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
          polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
          if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
            var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
            d3_geo_cartesianNormalize(arc);
            var intersection = d3_geo_cartesianCross(meridianNormal, arc);
            d3_geo_cartesianNormalize(intersection);
            var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
            if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
              winding += antimeridian ^ dλ >= 0 ? 1 : -1;
            }
          }
          if (!j++) break;
          λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
        }
      }
      return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < 0) ^ winding & 1;
    }
    var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);
    function d3_geo_clipAntimeridianLine(listener) {
      var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
      return {
        lineStart: function() {
          listener.lineStart();
          clean = 1;
        },
        point: function(λ1, φ1) {
          var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);
          if (abs(dλ - π) < ε) {
            listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
            listener.point(sλ0, φ0);
            listener.lineEnd();
            listener.lineStart();
            listener.point(sλ1, φ0);
            listener.point(λ1, φ0);
            clean = 0;
          } else if (sλ0 !== sλ1 && dλ >= π) {
            if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
            if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
            φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
            listener.point(sλ0, φ0);
            listener.lineEnd();
            listener.lineStart();
            listener.point(sλ1, φ0);
            clean = 0;
          }
          listener.point(λ0 = λ1, φ0 = φ1);
          sλ0 = sλ1;
        },
        lineEnd: function() {
          listener.lineEnd();
          λ0 = φ0 = NaN;
        },
        clean: function() {
          return 2 - clean;
        }
      };
    }
    function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
      var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
      return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
    }
    function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
      var φ;
      if (from == null) {
        φ = direction * halfπ;
        listener.point(-π, φ);
        listener.point(0, φ);
        listener.point(π, φ);
        listener.point(π, 0);
        listener.point(π, -φ);
        listener.point(0, -φ);
        listener.point(-π, -φ);
        listener.point(-π, 0);
        listener.point(-π, φ);
      } else if (abs(from[0] - to[0]) > ε) {
        var s = from[0] < to[0] ? π : -π;
        φ = direction * s / 2;
        listener.point(-s, φ);
        listener.point(0, φ);
        listener.point(s, φ);
      } else {
        listener.point(to[0], to[1]);
      }
    }
    function d3_geo_clipCircle(radius) {
      var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
      return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);
      function visible(λ, φ) {
        return Math.cos(λ) * Math.cos(φ) > cr;
      }
      function clipLine(listener) {
        var point0, c0, v0, v00, clean;
        return {
          lineStart: function() {
            v00 = v0 = false;
            clean = 1;
          },
          point: function(λ, φ) {
            var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
            if (!point0 && (v00 = v0 = v)) listener.lineStart();
            if (v !== v0) {
              point2 = intersect(point0, point1);
              if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
                point1[0] += ε;
                point1[1] += ε;
                v = visible(point1[0], point1[1]);
              }
            }
            if (v !== v0) {
              clean = 0;
              if (v) {
                listener.lineStart();
                point2 = intersect(point1, point0);
                listener.point(point2[0], point2[1]);
              } else {
                point2 = intersect(point0, point1);
                listener.point(point2[0], point2[1]);
                listener.lineEnd();
              }
              point0 = point2;
            } else if (notHemisphere && point0 && smallRadius ^ v) {
              var t;
              if (!(c & c0) && (t = intersect(point1, point0, true))) {
                clean = 0;
                if (smallRadius) {
                  listener.lineStart();
                  listener.point(t[0][0], t[0][1]);
                  listener.point(t[1][0], t[1][1]);
                  listener.lineEnd();
                } else {
                  listener.point(t[1][0], t[1][1]);
                  listener.lineEnd();
                  listener.lineStart();
                  listener.point(t[0][0], t[0][1]);
                }
              }
            }
            if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
              listener.point(point1[0], point1[1]);
            }
            point0 = point1, v0 = v, c0 = c;
          },
          lineEnd: function() {
            if (v0) listener.lineEnd();
            point0 = null;
          },
          clean: function() {
            return clean | (v00 && v0) << 1;
          }
        };
      }
      function intersect(a, b, two) {
        var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
        var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
        if (!determinant) return !two && a;
        var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
        d3_geo_cartesianAdd(A, B);
        var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
        if (t2 < 0) return;
        var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
        d3_geo_cartesianAdd(q, A);
        q = d3_geo_spherical(q);
        if (!two) return q;
        var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
        if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
        var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;
        if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
        if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
          var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
          d3_geo_cartesianAdd(q1, A);
          return [ q, d3_geo_spherical(q1) ];
        }
      }
      function code(λ, φ) {
        var r = smallRadius ? radius : π - radius, code = 0;
        if (λ < -r) code |= 1; else if (λ > r) code |= 2;
        if (φ < -r) code |= 4; else if (φ > r) code |= 8;
        return code;
      }
    }
    function d3_geom_clipLine(x0, y0, x1, y1) {
      return function(line) {
        var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
        r = x0 - ax;
        if (!dx && r > 0) return;
        r /= dx;
        if (dx < 0) {
          if (r < t0) return;
          if (r < t1) t1 = r;
        } else if (dx > 0) {
          if (r > t1) return;
          if (r > t0) t0 = r;
        }
        r = x1 - ax;
        if (!dx && r < 0) return;
        r /= dx;
        if (dx < 0) {
          if (r > t1) return;
          if (r > t0) t0 = r;
        } else if (dx > 0) {
          if (r < t0) return;
          if (r < t1) t1 = r;
        }
        r = y0 - ay;
        if (!dy && r > 0) return;
        r /= dy;
        if (dy < 0) {
          if (r < t0) return;
          if (r < t1) t1 = r;
        } else if (dy > 0) {
          if (r > t1) return;
          if (r > t0) t0 = r;
        }
        r = y1 - ay;
        if (!dy && r < 0) return;
        r /= dy;
        if (dy < 0) {
          if (r > t1) return;
          if (r > t0) t0 = r;
        } else if (dy > 0) {
          if (r < t0) return;
          if (r < t1) t1 = r;
        }
        if (t0 > 0) line.a = {
          x: ax + t0 * dx,
          y: ay + t0 * dy
        };
        if (t1 < 1) line.b = {
          x: ax + t1 * dx,
          y: ay + t1 * dy
        };
        return line;
      };
    }
    var d3_geo_clipExtentMAX = 1e9;
    d3.geo.clipExtent = function() {
      var x0, y0, x1, y1, stream, clip, clipExtent = {
        stream: function(output) {
          if (stream) stream.valid = false;
          stream = clip(output);
          stream.valid = true;
          return stream;
        },
        extent: function(_) {
          if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
          clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
          if (stream) stream.valid = false, stream = null;
          return clipExtent;
        }
      };
      return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
    };
    function d3_geo_clipExtent(x0, y0, x1, y1) {
      return function(listener) {
        var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
        var clip = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() {
            listener = bufferListener;
            segments = [];
            polygon = [];
            clean = true;
          },
          polygonEnd: function() {
            listener = listener_;
            segments = d3.merge(segments);
            var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
            if (inside || visible) {
              listener.polygonStart();
              if (inside) {
                listener.lineStart();
                interpolate(null, null, 1, listener);
                listener.lineEnd();
              }
              if (visible) {
                d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
              }
              listener.polygonEnd();
            }
            segments = polygon = ring = null;
          }
        };
        function insidePolygon(p) {
          var wn = 0, n = polygon.length, y = p[1];
          for (var i = 0; i < n; ++i) {
            for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
              b = v[j];
              if (a[1] <= y) {
                if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
              } else {
                if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
              }
              a = b;
            }
          }
          return wn !== 0;
        }
        function interpolate(from, to, direction, listener) {
          var a = 0, a1 = 0;
          if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
            do {
              listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
            } while ((a = (a + direction + 4) % 4) !== a1);
          } else {
            listener.point(to[0], to[1]);
          }
        }
        function pointVisible(x, y) {
          return x0 <= x && x <= x1 && y0 <= y && y <= y1;
        }
        function point(x, y) {
          if (pointVisible(x, y)) listener.point(x, y);
        }
        var x__, y__, v__, x_, y_, v_, first, clean;
        function lineStart() {
          clip.point = linePoint;
          if (polygon) polygon.push(ring = []);
          first = true;
          v_ = false;
          x_ = y_ = NaN;
        }
        function lineEnd() {
          if (segments) {
            linePoint(x__, y__);
            if (v__ && v_) bufferListener.rejoin();
            segments.push(bufferListener.buffer());
          }
          clip.point = point;
          if (v_) listener.lineEnd();
        }
        function linePoint(x, y) {
          x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
          y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
          var v = pointVisible(x, y);
          if (polygon) ring.push([ x, y ]);
          if (first) {
            x__ = x, y__ = y, v__ = v;
            first = false;
            if (v) {
              listener.lineStart();
              listener.point(x, y);
            }
          } else {
            if (v && v_) listener.point(x, y); else {
              var l = {
                a: {
                  x: x_,
                  y: y_
                },
                b: {
                  x: x,
                  y: y
                }
              };
              if (clipLine(l)) {
                if (!v_) {
                  listener.lineStart();
                  listener.point(l.a.x, l.a.y);
                }
                listener.point(l.b.x, l.b.y);
                if (!v) listener.lineEnd();
                clean = false;
              } else if (v) {
                listener.lineStart();
                listener.point(x, y);
                clean = false;
              }
            }
          }
          x_ = x, y_ = y, v_ = v;
        }
        return clip;
      };
      function corner(p, direction) {
        return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
      }
      function compare(a, b) {
        return comparePoints(a.x, b.x);
      }
      function comparePoints(a, b) {
        var ca = corner(a, 1), cb = corner(b, 1);
        return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
      }
    }
    function d3_geo_compose(a, b) {
      function compose(x, y) {
        return x = a(x, y), b(x[0], x[1]);
      }
      if (a.invert && b.invert) compose.invert = function(x, y) {
        return x = b.invert(x, y), x && a.invert(x[0], x[1]);
      };
      return compose;
    }
    function d3_geo_conic(projectAt) {
      var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
      p.parallels = function(_) {
        if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];
        return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
      };
      return p;
    }
    function d3_geo_conicEqualArea(φ0, φ1) {
      var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
      function forward(λ, φ) {
        var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
        return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
      }
      forward.invert = function(x, y) {
        var ρ0_y = ρ0 - y;
        return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
      };
      return forward;
    }
    (d3.geo.conicEqualArea = function() {
      return d3_geo_conic(d3_geo_conicEqualArea);
    }).raw = d3_geo_conicEqualArea;
    d3.geo.albers = function() {
      return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
    };
    d3.geo.albersUsa = function() {
      var lower48 = d3.geo.albers();
      var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
      var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
      var point, pointStream = {
        point: function(x, y) {
          point = [ x, y ];
        }
      }, lower48Point, alaskaPoint, hawaiiPoint;
      function albersUsa(coordinates) {
        var x = coordinates[0], y = coordinates[1];
        point = null;
        (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
        return point;
      }
      albersUsa.invert = function(coordinates) {
        var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
        return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
      };
      albersUsa.stream = function(stream) {
        var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
        return {
          point: function(x, y) {
            lower48Stream.point(x, y);
            alaskaStream.point(x, y);
            hawaiiStream.point(x, y);
          },
          sphere: function() {
            lower48Stream.sphere();
            alaskaStream.sphere();
            hawaiiStream.sphere();
          },
          lineStart: function() {
            lower48Stream.lineStart();
            alaskaStream.lineStart();
            hawaiiStream.lineStart();
          },
          lineEnd: function() {
            lower48Stream.lineEnd();
            alaskaStream.lineEnd();
            hawaiiStream.lineEnd();
          },
          polygonStart: function() {
            lower48Stream.polygonStart();
            alaskaStream.polygonStart();
            hawaiiStream.polygonStart();
          },
          polygonEnd: function() {
            lower48Stream.polygonEnd();
            alaskaStream.polygonEnd();
            hawaiiStream.polygonEnd();
          }
        };
      };
      albersUsa.precision = function(_) {
        if (!arguments.length) return lower48.precision();
        lower48.precision(_);
        alaska.precision(_);
        hawaii.precision(_);
        return albersUsa;
      };
      albersUsa.scale = function(_) {
        if (!arguments.length) return lower48.scale();
        lower48.scale(_);
        alaska.scale(_ * .35);
        hawaii.scale(_);
        return albersUsa.translate(lower48.translate());
      };
      albersUsa.translate = function(_) {
        if (!arguments.length) return lower48.translate();
        var k = lower48.scale(), x = +_[0], y = +_[1];
        lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
        alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
        hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
        return albersUsa;
      };
      return albersUsa.scale(1070);
    };
    var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
      point: d3_noop,
      lineStart: d3_noop,
      lineEnd: d3_noop,
      polygonStart: function() {
        d3_geo_pathAreaPolygon = 0;
        d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
      },
      polygonEnd: function() {
        d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
        d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
      }
    };
    function d3_geo_pathAreaRingStart() {
      var x00, y00, x0, y0;
      d3_geo_pathArea.point = function(x, y) {
        d3_geo_pathArea.point = nextPoint;
        x00 = x0 = x, y00 = y0 = y;
      };
      function nextPoint(x, y) {
        d3_geo_pathAreaPolygon += y0 * x - x0 * y;
        x0 = x, y0 = y;
      }
      d3_geo_pathArea.lineEnd = function() {
        nextPoint(x00, y00);
      };
    }
    var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
    var d3_geo_pathBounds = {
      point: d3_geo_pathBoundsPoint,
      lineStart: d3_noop,
      lineEnd: d3_noop,
      polygonStart: d3_noop,
      polygonEnd: d3_noop
    };
    function d3_geo_pathBoundsPoint(x, y) {
      if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
      if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
      if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
      if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
    }
    function d3_geo_pathBuffer() {
      var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
      var stream = {
        point: point,
        lineStart: function() {
          stream.point = pointLineStart;
        },
        lineEnd: lineEnd,
        polygonStart: function() {
          stream.lineEnd = lineEndPolygon;
        },
        polygonEnd: function() {
          stream.lineEnd = lineEnd;
          stream.point = point;
        },
        pointRadius: function(_) {
          pointCircle = d3_geo_pathBufferCircle(_);
          return stream;
        },
        result: function() {
          if (buffer.length) {
            var result = buffer.join("");
            buffer = [];
            return result;
          }
        }
      };
      function point(x, y) {
        buffer.push("M", x, ",", y, pointCircle);
      }
      function pointLineStart(x, y) {
        buffer.push("M", x, ",", y);
        stream.point = pointLine;
      }
      function pointLine(x, y) {
        buffer.push("L", x, ",", y);
      }
      function lineEnd() {
        stream.point = point;
      }
      function lineEndPolygon() {
        buffer.push("Z");
      }
      return stream;
    }
    function d3_geo_pathBufferCircle(radius) {
      return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
    }
    var d3_geo_pathCentroid = {
      point: d3_geo_pathCentroidPoint,
      lineStart: d3_geo_pathCentroidLineStart,
      lineEnd: d3_geo_pathCentroidLineEnd,
      polygonStart: function() {
        d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
      },
      polygonEnd: function() {
        d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
        d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
        d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
      }
    };
    function d3_geo_pathCentroidPoint(x, y) {
      d3_geo_centroidX0 += x;
      d3_geo_centroidY0 += y;
      ++d3_geo_centroidZ0;
    }
    function d3_geo_pathCentroidLineStart() {
      var x0, y0;
      d3_geo_pathCentroid.point = function(x, y) {
        d3_geo_pathCentroid.point = nextPoint;
        d3_geo_pathCentroidPoint(x0 = x, y0 = y);
      };
      function nextPoint(x, y) {
        var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
        d3_geo_centroidX1 += z * (x0 + x) / 2;
        d3_geo_centroidY1 += z * (y0 + y) / 2;
        d3_geo_centroidZ1 += z;
        d3_geo_pathCentroidPoint(x0 = x, y0 = y);
      }
    }
    function d3_geo_pathCentroidLineEnd() {
      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
    }
    function d3_geo_pathCentroidRingStart() {
      var x00, y00, x0, y0;
      d3_geo_pathCentroid.point = function(x, y) {
        d3_geo_pathCentroid.point = nextPoint;
        d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
      };
      function nextPoint(x, y) {
        var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
        d3_geo_centroidX1 += z * (x0 + x) / 2;
        d3_geo_centroidY1 += z * (y0 + y) / 2;
        d3_geo_centroidZ1 += z;
        z = y0 * x - x0 * y;
        d3_geo_centroidX2 += z * (x0 + x);
        d3_geo_centroidY2 += z * (y0 + y);
        d3_geo_centroidZ2 += z * 3;
        d3_geo_pathCentroidPoint(x0 = x, y0 = y);
      }
      d3_geo_pathCentroid.lineEnd = function() {
        nextPoint(x00, y00);
      };
    }
    function d3_geo_pathContext(context) {
      var pointRadius = 4.5;
      var stream = {
        point: point,
        lineStart: function() {
          stream.point = pointLineStart;
        },
        lineEnd: lineEnd,
        polygonStart: function() {
          stream.lineEnd = lineEndPolygon;
        },
        polygonEnd: function() {
          stream.lineEnd = lineEnd;
          stream.point = point;
        },
        pointRadius: function(_) {
          pointRadius = _;
          return stream;
        },
        result: d3_noop
      };
      function point(x, y) {
        context.moveTo(x, y);
        context.arc(x, y, pointRadius, 0, τ);
      }
      function pointLineStart(x, y) {
        context.moveTo(x, y);
        stream.point = pointLine;
      }
      function pointLine(x, y) {
        context.lineTo(x, y);
      }
      function lineEnd() {
        stream.point = point;
      }
      function lineEndPolygon() {
        context.closePath();
      }
      return stream;
    }
    function d3_geo_resample(project) {
      var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
      function resample(stream) {
        return (maxDepth ? resampleRecursive : resampleNone)(stream);
      }
      function resampleNone(stream) {
        return d3_geo_transformPoint(stream, function(x, y) {
          x = project(x, y);
          stream.point(x[0], x[1]);
        });
      }
      function resampleRecursive(stream) {
        var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
        var resample = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() {
            stream.polygonStart();
            resample.lineStart = ringStart;
          },
          polygonEnd: function() {
            stream.polygonEnd();
            resample.lineStart = lineStart;
          }
        };
        function point(x, y) {
          x = project(x, y);
          stream.point(x[0], x[1]);
        }
        function lineStart() {
          x0 = NaN;
          resample.point = linePoint;
          stream.lineStart();
        }
        function linePoint(λ, φ) {
          var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
          resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
          stream.point(x0, y0);
        }
        function lineEnd() {
          resample.point = point;
          stream.lineEnd();
        }
        function ringStart() {
          lineStart();
          resample.point = ringPoint;
          resample.lineEnd = ringEnd;
        }
        function ringPoint(λ, φ) {
          linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
          resample.point = linePoint;
        }
        function ringEnd() {
          resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
          resample.lineEnd = lineEnd;
          lineEnd();
        }
        return resample;
      }
      function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
        var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
        if (d2 > 4 * δ2 && depth--) {
          var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
          if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
            resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
            stream.point(x2, y2);
            resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
          }
        }
      }
      resample.precision = function(_) {
        if (!arguments.length) return Math.sqrt(δ2);
        maxDepth = (δ2 = _ * _) > 0 && 16;
        return resample;
      };
      return resample;
    }
    d3.geo.path = function() {
      var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
      function path(object) {
        if (object) {
          if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
          if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
          d3.geo.stream(object, cacheStream);
        }
        return contextStream.result();
      }
      path.area = function(object) {
        d3_geo_pathAreaSum = 0;
        d3.geo.stream(object, projectStream(d3_geo_pathArea));
        return d3_geo_pathAreaSum;
      };
      path.centroid = function(object) {
        d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
        d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
        return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
      };
      path.bounds = function(object) {
        d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
        d3.geo.stream(object, projectStream(d3_geo_pathBounds));
        return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
      };
      path.projection = function(_) {
        if (!arguments.length) return projection;
        projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
        return reset();
      };
      path.context = function(_) {
        if (!arguments.length) return context;
        contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
        if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
        return reset();
      };
      path.pointRadius = function(_) {
        if (!arguments.length) return pointRadius;
        pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
        return path;
      };
      function reset() {
        cacheStream = null;
        return path;
      }
      return path.projection(d3.geo.albersUsa()).context(null);
    };
    function d3_geo_pathProjectStream(project) {
      var resample = d3_geo_resample(function(x, y) {
        return project([ x * d3_degrees, y * d3_degrees ]);
      });
      return function(stream) {
        return d3_geo_projectionRadians(resample(stream));
      };
    }
    d3.geo.transform = function(methods) {
      return {
        stream: function(stream) {
          var transform = new d3_geo_transform(stream);
          for (var k in methods) transform[k] = methods[k];
          return transform;
        }
      };
    };
    function d3_geo_transform(stream) {
      this.stream = stream;
    }
    d3_geo_transform.prototype = {
      point: function(x, y) {
        this.stream.point(x, y);
      },
      sphere: function() {
        this.stream.sphere();
      },
      lineStart: function() {
        this.stream.lineStart();
      },
      lineEnd: function() {
        this.stream.lineEnd();
      },
      polygonStart: function() {
        this.stream.polygonStart();
      },
      polygonEnd: function() {
        this.stream.polygonEnd();
      }
    };
    function d3_geo_transformPoint(stream, point) {
      return {
        point: point,
        sphere: function() {
          stream.sphere();
        },
        lineStart: function() {
          stream.lineStart();
        },
        lineEnd: function() {
          stream.lineEnd();
        },
        polygonStart: function() {
          stream.polygonStart();
        },
        polygonEnd: function() {
          stream.polygonEnd();
        }
      };
    }
    d3.geo.projection = d3_geo_projection;
    d3.geo.projectionMutator = d3_geo_projectionMutator;
    function d3_geo_projection(project) {
      return d3_geo_projectionMutator(function() {
        return project;
      })();
    }
    function d3_geo_projectionMutator(projectAt) {
      var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
        x = project(x, y);
        return [ x[0] * k + δx, δy - x[1] * k ];
      }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
      function projection(point) {
        point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
        return [ point[0] * k + δx, δy - point[1] * k ];
      }
      function invert(point) {
        point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
        return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
      }
      projection.stream = function(output) {
        if (stream) stream.valid = false;
        stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
        stream.valid = true;
        return stream;
      };
      projection.clipAngle = function(_) {
        if (!arguments.length) return clipAngle;
        preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
        return invalidate();
      };
      projection.clipExtent = function(_) {
        if (!arguments.length) return clipExtent;
        clipExtent = _;
        postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
        return invalidate();
      };
      projection.scale = function(_) {
        if (!arguments.length) return k;
        k = +_;
        return reset();
      };
      projection.translate = function(_) {
        if (!arguments.length) return [ x, y ];
        x = +_[0];
        y = +_[1];
        return reset();
      };
      projection.center = function(_) {
        if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
        λ = _[0] % 360 * d3_radians;
        φ = _[1] % 360 * d3_radians;
        return reset();
      };
      projection.rotate = function(_) {
        if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
        δλ = _[0] % 360 * d3_radians;
        δφ = _[1] % 360 * d3_radians;
        δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
        return reset();
      };
      d3.rebind(projection, projectResample, "precision");
      function reset() {
        projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
        var center = project(λ, φ);
        δx = x - center[0] * k;
        δy = y + center[1] * k;
        return invalidate();
      }
      function invalidate() {
        if (stream) stream.valid = false, stream = null;
        return projection;
      }
      return function() {
        project = projectAt.apply(this, arguments);
        projection.invert = project.invert && invert;
        return reset();
      };
    }
    function d3_geo_projectionRadians(stream) {
      return d3_geo_transformPoint(stream, function(x, y) {
        stream.point(x * d3_radians, y * d3_radians);
      });
    }
    function d3_geo_equirectangular(λ, φ) {
      return [ λ, φ ];
    }
    (d3.geo.equirectangular = function() {
      return d3_geo_projection(d3_geo_equirectangular);
    }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
    d3.geo.rotation = function(rotate) {
      rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
      function forward(coordinates) {
        coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
        return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
      }
      forward.invert = function(coordinates) {
        coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
        return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
      };
      return forward;
    };
    function d3_geo_identityRotation(λ, φ) {
      return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
    }
    d3_geo_identityRotation.invert = d3_geo_equirectangular;
    function d3_geo_rotation(δλ, δφ, δγ) {
      return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
    }
    function d3_geo_forwardRotationλ(δλ) {
      return function(λ, φ) {
        return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
      };
    }
    function d3_geo_rotationλ(δλ) {
      var rotation = d3_geo_forwardRotationλ(δλ);
      rotation.invert = d3_geo_forwardRotationλ(-δλ);
      return rotation;
    }
    function d3_geo_rotationφγ(δφ, δγ) {
      var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
      function rotation(λ, φ) {
        var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
        return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];
      }
      rotation.invert = function(λ, φ) {
        var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
        return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];
      };
      return rotation;
    }
    d3.geo.circle = function() {
      var origin = [ 0, 0 ], angle, precision = 6, interpolate;
      function circle() {
        var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
        interpolate(null, null, 1, {
          point: function(x, y) {
            ring.push(x = rotate(x, y));
            x[0] *= d3_degrees, x[1] *= d3_degrees;
          }
        });
        return {
          type: "Polygon",
          coordinates: [ ring ]
        };
      }
      circle.origin = function(x) {
        if (!arguments.length) return origin;
        origin = x;
        return circle;
      };
      circle.angle = function(x) {
        if (!arguments.length) return angle;
        interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
        return circle;
      };
      circle.precision = function(_) {
        if (!arguments.length) return precision;
        interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
        return circle;
      };
      return circle.angle(90);
    };
    function d3_geo_circleInterpolate(radius, precision) {
      var cr = Math.cos(radius), sr = Math.sin(radius);
      return function(from, to, direction, listener) {
        var step = direction * precision;
        if (from != null) {
          from = d3_geo_circleAngle(cr, from);
          to = d3_geo_circleAngle(cr, to);
          if (direction > 0 ? from < to : from > to) from += direction * τ;
        } else {
          from = radius + direction * τ;
          to = radius - .5 * step;
        }
        for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
          listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
        }
      };
    }
    function d3_geo_circleAngle(cr, point) {
      var a = d3_geo_cartesian(point);
      a[0] -= cr;
      d3_geo_cartesianNormalize(a);
      var angle = d3_acos(-a[1]);
      return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
    }
    d3.geo.distance = function(a, b) {
      var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
      return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
    };
    d3.geo.graticule = function() {
      var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
      function graticule() {
        return {
          type: "MultiLineString",
          coordinates: lines()
        };
      }
      function lines() {
        return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
          return abs(x % DX) > ε;
        }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
          return abs(y % DY) > ε;
        }).map(y));
      }
      graticule.lines = function() {
        return lines().map(function(coordinates) {
          return {
            type: "LineString",
            coordinates: coordinates
          };
        });
      };
      graticule.outline = function() {
        return {
          type: "Polygon",
          coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
        };
      };
      graticule.extent = function(_) {
        if (!arguments.length) return graticule.minorExtent();
        return graticule.majorExtent(_).minorExtent(_);
      };
      graticule.majorExtent = function(_) {
        if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
        X0 = +_[0][0], X1 = +_[1][0];
        Y0 = +_[0][1], Y1 = +_[1][1];
        if (X0 > X1) _ = X0, X0 = X1, X1 = _;
        if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
        return graticule.precision(precision);
      };
      graticule.minorExtent = function(_) {
        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
        x0 = +_[0][0], x1 = +_[1][0];
        y0 = +_[0][1], y1 = +_[1][1];
        if (x0 > x1) _ = x0, x0 = x1, x1 = _;
        if (y0 > y1) _ = y0, y0 = y1, y1 = _;
        return graticule.precision(precision);
      };
      graticule.step = function(_) {
        if (!arguments.length) return graticule.minorStep();
        return graticule.majorStep(_).minorStep(_);
      };
      graticule.majorStep = function(_) {
        if (!arguments.length) return [ DX, DY ];
        DX = +_[0], DY = +_[1];
        return graticule;
      };
      graticule.minorStep = function(_) {
        if (!arguments.length) return [ dx, dy ];
        dx = +_[0], dy = +_[1];
        return graticule;
      };
      graticule.precision = function(_) {
        if (!arguments.length) return precision;
        precision = +_;
        x = d3_geo_graticuleX(y0, y1, 90);
        y = d3_geo_graticuleY(x0, x1, precision);
        X = d3_geo_graticuleX(Y0, Y1, 90);
        Y = d3_geo_graticuleY(X0, X1, precision);
        return graticule;
      };
      return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);
    };
    function d3_geo_graticuleX(y0, y1, dy) {
      var y = d3.range(y0, y1 - ε, dy).concat(y1);
      return function(x) {
        return y.map(function(y) {
          return [ x, y ];
        });
      };
    }
    function d3_geo_graticuleY(x0, x1, dx) {
      var x = d3.range(x0, x1 - ε, dx).concat(x1);
      return function(y) {
        return x.map(function(x) {
          return [ x, y ];
        });
      };
    }
    function d3_source(d) {
      return d.source;
    }
    function d3_target(d) {
      return d.target;
    }
    d3.geo.greatArc = function() {
      var source = d3_source, source_, target = d3_target, target_;
      function greatArc() {
        return {
          type: "LineString",
          coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
        };
      }
      greatArc.distance = function() {
        return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
      };
      greatArc.source = function(_) {
        if (!arguments.length) return source;
        source = _, source_ = typeof _ === "function" ? null : _;
        return greatArc;
      };
      greatArc.target = function(_) {
        if (!arguments.length) return target;
        target = _, target_ = typeof _ === "function" ? null : _;
        return greatArc;
      };
      greatArc.precision = function() {
        return arguments.length ? greatArc : 0;
      };
      return greatArc;
    };
    d3.geo.interpolate = function(source, target) {
      return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
    };
    function d3_geo_interpolate(x0, y0, x1, y1) {
      var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
      var interpolate = d ? function(t) {
        var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
        return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
      } : function() {
        return [ x0 * d3_degrees, y0 * d3_degrees ];
      };
      interpolate.distance = d;
      return interpolate;
    }
    d3.geo.length = function(object) {
      d3_geo_lengthSum = 0;
      d3.geo.stream(object, d3_geo_length);
      return d3_geo_lengthSum;
    };
    var d3_geo_lengthSum;
    var d3_geo_length = {
      sphere: d3_noop,
      point: d3_noop,
      lineStart: d3_geo_lengthLineStart,
      lineEnd: d3_noop,
      polygonStart: d3_noop,
      polygonEnd: d3_noop
    };
    function d3_geo_lengthLineStart() {
      var λ0, sinφ0, cosφ0;
      d3_geo_length.point = function(λ, φ) {
        λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
        d3_geo_length.point = nextPoint;
      };
      d3_geo_length.lineEnd = function() {
        d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
      };
      function nextPoint(λ, φ) {
        var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
        d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
      }
    }
    function d3_geo_azimuthal(scale, angle) {
      function azimuthal(λ, φ) {
        var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
        return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
      }
      azimuthal.invert = function(x, y) {
        var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
        return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
      };
      return azimuthal;
    }
    var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
      return Math.sqrt(2 / (1 + cosλcosφ));
    }, function(ρ) {
      return 2 * Math.asin(ρ / 2);
    });
    (d3.geo.azimuthalEqualArea = function() {
      return d3_geo_projection(d3_geo_azimuthalEqualArea);
    }).raw = d3_geo_azimuthalEqualArea;
    var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
      var c = Math.acos(cosλcosφ);
      return c && c / Math.sin(c);
    }, d3_identity);
    (d3.geo.azimuthalEquidistant = function() {
      return d3_geo_projection(d3_geo_azimuthalEquidistant);
    }).raw = d3_geo_azimuthalEquidistant;
    function d3_geo_conicConformal(φ0, φ1) {
      var cosφ0 = Math.cos(φ0), t = function(φ) {
        return Math.tan(π / 4 + φ / 2);
      }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
      if (!n) return d3_geo_mercator;
      function forward(λ, φ) {
        if (F > 0) {
          if (φ < -halfπ + ε) φ = -halfπ + ε;
        } else {
          if (φ > halfπ - ε) φ = halfπ - ε;
        }
        var ρ = F / Math.pow(t(φ), n);
        return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];
      }
      forward.invert = function(x, y) {
        var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
        return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];
      };
      return forward;
    }
    (d3.geo.conicConformal = function() {
      return d3_geo_conic(d3_geo_conicConformal);
    }).raw = d3_geo_conicConformal;
    function d3_geo_conicEquidistant(φ0, φ1) {
      var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
      if (abs(n) < ε) return d3_geo_equirectangular;
      function forward(λ, φ) {
        var ρ = G - φ;
        return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];
      }
      forward.invert = function(x, y) {
        var ρ0_y = G - y;
        return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];
      };
      return forward;
    }
    (d3.geo.conicEquidistant = function() {
      return d3_geo_conic(d3_geo_conicEquidistant);
    }).raw = d3_geo_conicEquidistant;
    var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
      return 1 / cosλcosφ;
    }, Math.atan);
    (d3.geo.gnomonic = function() {
      return d3_geo_projection(d3_geo_gnomonic);
    }).raw = d3_geo_gnomonic;
    function d3_geo_mercator(λ, φ) {
      return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];
    }
    d3_geo_mercator.invert = function(x, y) {
      return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];
    };
    function d3_geo_mercatorProjection(project) {
      var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
      m.scale = function() {
        var v = scale.apply(m, arguments);
        return v === m ? clipAuto ? m.clipExtent(null) : m : v;
      };
      m.translate = function() {
        var v = translate.apply(m, arguments);
        return v === m ? clipAuto ? m.clipExtent(null) : m : v;
      };
      m.clipExtent = function(_) {
        var v = clipExtent.apply(m, arguments);
        if (v === m) {
          if (clipAuto = _ == null) {
            var k = π * scale(), t = translate();
            clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
          }
        } else if (clipAuto) {
          v = null;
        }
        return v;
      };
      return m.clipExtent(null);
    }
    (d3.geo.mercator = function() {
      return d3_geo_mercatorProjection(d3_geo_mercator);
    }).raw = d3_geo_mercator;
    var d3_geo_orthographic = d3_geo_azimuthal(function() {
      return 1;
    }, Math.asin);
    (d3.geo.orthographic = function() {
      return d3_geo_projection(d3_geo_orthographic);
    }).raw = d3_geo_orthographic;
    var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
      return 1 / (1 + cosλcosφ);
    }, function(ρ) {
      return 2 * Math.atan(ρ);
    });
    (d3.geo.stereographic = function() {
      return d3_geo_projection(d3_geo_stereographic);
    }).raw = d3_geo_stereographic;
    function d3_geo_transverseMercator(λ, φ) {
      return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];
    }
    d3_geo_transverseMercator.invert = function(x, y) {
      return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];
    };
    (d3.geo.transverseMercator = function() {
      var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
      projection.center = function(_) {
        return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
      };
      projection.rotate = function(_) {
        return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
        [ _[0], _[1], _[2] - 90 ]);
      };
      return rotate([ 0, 0, 90 ]);
    }).raw = d3_geo_transverseMercator;
    d3.geom = {};
    function d3_geom_pointX(d) {
      return d[0];
    }
    function d3_geom_pointY(d) {
      return d[1];
    }
    d3.geom.hull = function(vertices) {
      var x = d3_geom_pointX, y = d3_geom_pointY;
      if (arguments.length) return hull(vertices);
      function hull(data) {
        if (data.length < 3) return [];
        var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
        for (i = 0; i < n; i++) {
          points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
        }
        points.sort(d3_geom_hullOrder);
        for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
        var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
        var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
        for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
        for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
        return polygon;
      }
      hull.x = function(_) {
        return arguments.length ? (x = _, hull) : x;
      };
      hull.y = function(_) {
        return arguments.length ? (y = _, hull) : y;
      };
      return hull;
    };
    function d3_geom_hullUpper(points) {
      var n = points.length, hull = [ 0, 1 ], hs = 2;
      for (var i = 2; i < n; i++) {
        while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
        hull[hs++] = i;
      }
      return hull.slice(0, hs);
    }
    function d3_geom_hullOrder(a, b) {
      return a[0] - b[0] || a[1] - b[1];
    }
    d3.geom.polygon = function(coordinates) {
      d3_subclass(coordinates, d3_geom_polygonPrototype);
      return coordinates;
    };
    var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
    d3_geom_polygonPrototype.area = function() {
      var i = -1, n = this.length, a, b = this[n - 1], area = 0;
      while (++i < n) {
        a = b;
        b = this[i];
        area += a[1] * b[0] - a[0] * b[1];
      }
      return area * .5;
    };
    d3_geom_polygonPrototype.centroid = function(k) {
      var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
      if (!arguments.length) k = -1 / (6 * this.area());
      while (++i < n) {
        a = b;
        b = this[i];
        c = a[0] * b[1] - b[0] * a[1];
        x += (a[0] + b[0]) * c;
        y += (a[1] + b[1]) * c;
      }
      return [ x * k, y * k ];
    };
    d3_geom_polygonPrototype.clip = function(subject) {
      var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
      while (++i < n) {
        input = subject.slice();
        subject.length = 0;
        b = this[i];
        c = input[(m = input.length - closed) - 1];
        j = -1;
        while (++j < m) {
          d = input[j];
          if (d3_geom_polygonInside(d, a, b)) {
            if (!d3_geom_polygonInside(c, a, b)) {
              subject.push(d3_geom_polygonIntersect(c, d, a, b));
            }
            subject.push(d);
          } else if (d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          c = d;
        }
        if (closed) subject.push(subject[0]);
        a = b;
      }
      return subject;
    };
    function d3_geom_polygonInside(p, a, b) {
      return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
    }
    function d3_geom_polygonIntersect(c, d, a, b) {
      var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
      return [ x1 + ua * x21, y1 + ua * y21 ];
    }
    function d3_geom_polygonClosed(coordinates) {
      var a = coordinates[0], b = coordinates[coordinates.length - 1];
      return !(a[0] - b[0] || a[1] - b[1]);
    }
    var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
    function d3_geom_voronoiBeach() {
      d3_geom_voronoiRedBlackNode(this);
      this.edge = this.site = this.circle = null;
    }
    function d3_geom_voronoiCreateBeach(site) {
      var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
      beach.site = site;
      return beach;
    }
    function d3_geom_voronoiDetachBeach(beach) {
      d3_geom_voronoiDetachCircle(beach);
      d3_geom_voronoiBeaches.remove(beach);
      d3_geom_voronoiBeachPool.push(beach);
      d3_geom_voronoiRedBlackNode(beach);
    }
    function d3_geom_voronoiRemoveBeach(beach) {
      var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
        x: x,
        y: y
      }, previous = beach.P, next = beach.N, disappearing = [ beach ];
      d3_geom_voronoiDetachBeach(beach);
      var lArc = previous;
      while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
        previous = lArc.P;
        disappearing.unshift(lArc);
        d3_geom_voronoiDetachBeach(lArc);
        lArc = previous;
      }
      disappearing.unshift(lArc);
      d3_geom_voronoiDetachCircle(lArc);
      var rArc = next;
      while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
        next = rArc.N;
        disappearing.push(rArc);
        d3_geom_voronoiDetachBeach(rArc);
        rArc = next;
      }
      disappearing.push(rArc);
      d3_geom_voronoiDetachCircle(rArc);
      var nArcs = disappearing.length, iArc;
      for (iArc = 1; iArc < nArcs; ++iArc) {
        rArc = disappearing[iArc];
        lArc = disappearing[iArc - 1];
        d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
      }
      lArc = disappearing[0];
      rArc = disappearing[nArcs - 1];
      rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
      d3_geom_voronoiAttachCircle(lArc);
      d3_geom_voronoiAttachCircle(rArc);
    }
    function d3_geom_voronoiAddBeach(site) {
      var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
      while (node) {
        dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
        if (dxl > ε) node = node.L; else {
          dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
          if (dxr > ε) {
            if (!node.R) {
              lArc = node;
              break;
            }
            node = node.R;
          } else {
            if (dxl > -ε) {
              lArc = node.P;
              rArc = node;
            } else if (dxr > -ε) {
              lArc = node;
              rArc = node.N;
            } else {
              lArc = rArc = node;
            }
            break;
          }
        }
      }
      var newArc = d3_geom_voronoiCreateBeach(site);
      d3_geom_voronoiBeaches.insert(lArc, newArc);
      if (!lArc && !rArc) return;
      if (lArc === rArc) {
        d3_geom_voronoiDetachCircle(lArc);
        rArc = d3_geom_voronoiCreateBeach(lArc.site);
        d3_geom_voronoiBeaches.insert(newArc, rArc);
        newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
        return;
      }
      if (!rArc) {
        newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
        return;
      }
      d3_geom_voronoiDetachCircle(lArc);
      d3_geom_voronoiDetachCircle(rArc);
      var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
        x: (cy * hb - by * hc) / d + ax,
        y: (bx * hc - cx * hb) / d + ay
      };
      d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
      newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
      rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
      d3_geom_voronoiAttachCircle(lArc);
      d3_geom_voronoiAttachCircle(rArc);
    }
    function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
      var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
      if (!pby2) return rfocx;
      var lArc = arc.P;
      if (!lArc) return -Infinity;
      site = lArc.site;
      var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
      if (!plby2) return lfocx;
      var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
      if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
      return (rfocx + lfocx) / 2;
    }
    function d3_geom_voronoiRightBreakPoint(arc, directrix) {
      var rArc = arc.N;
      if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
      var site = arc.site;
      return site.y === directrix ? site.x : Infinity;
    }
    function d3_geom_voronoiCell(site) {
      this.site = site;
      this.edges = [];
    }
    d3_geom_voronoiCell.prototype.prepare = function() {
      var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
      while (iHalfEdge--) {
        edge = halfEdges[iHalfEdge].edge;
        if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
      }
      halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
      return halfEdges.length;
    };
    function d3_geom_voronoiCloseCells(extent) {
      var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
      while (iCell--) {
        cell = cells[iCell];
        if (!cell || !cell.prepare()) continue;
        halfEdges = cell.edges;
        nHalfEdges = halfEdges.length;
        iHalfEdge = 0;
        while (iHalfEdge < nHalfEdges) {
          end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
          start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
          if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
            halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
              x: x0,
              y: abs(x2 - x0) < ε ? y2 : y1
            } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
              x: abs(y2 - y1) < ε ? x2 : x1,
              y: y1
            } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
              x: x1,
              y: abs(x2 - x1) < ε ? y2 : y0
            } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
              x: abs(y2 - y0) < ε ? x2 : x0,
              y: y0
            } : null), cell.site, null));
            ++nHalfEdges;
          }
        }
      }
    }
    function d3_geom_voronoiHalfEdgeOrder(a, b) {
      return b.angle - a.angle;
    }
    function d3_geom_voronoiCircle() {
      d3_geom_voronoiRedBlackNode(this);
      this.x = this.y = this.arc = this.site = this.cy = null;
    }
    function d3_geom_voronoiAttachCircle(arc) {
      var lArc = arc.P, rArc = arc.N;
      if (!lArc || !rArc) return;
      var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
      if (lSite === rSite) return;
      var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
      var d = 2 * (ax * cy - ay * cx);
      if (d >= -ε2) return;
      var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
      var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
      circle.arc = arc;
      circle.site = cSite;
      circle.x = x + bx;
      circle.y = cy + Math.sqrt(x * x + y * y);
      circle.cy = cy;
      arc.circle = circle;
      var before = null, node = d3_geom_voronoiCircles._;
      while (node) {
        if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
          if (node.L) node = node.L; else {
            before = node.P;
            break;
          }
        } else {
          if (node.R) node = node.R; else {
            before = node;
            break;
          }
        }
      }
      d3_geom_voronoiCircles.insert(before, circle);
      if (!before) d3_geom_voronoiFirstCircle = circle;
    }
    function d3_geom_voronoiDetachCircle(arc) {
      var circle = arc.circle;
      if (circle) {
        if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
        d3_geom_voronoiCircles.remove(circle);
        d3_geom_voronoiCirclePool.push(circle);
        d3_geom_voronoiRedBlackNode(circle);
        arc.circle = null;
      }
    }
    function d3_geom_voronoiClipEdges(extent) {
      var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
      while (i--) {
        e = edges[i];
        if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
          e.a = e.b = null;
          edges.splice(i, 1);
        }
      }
    }
    function d3_geom_voronoiConnectEdge(edge, extent) {
      var vb = edge.b;
      if (vb) return true;
      var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
      if (ry === ly) {
        if (fx < x0 || fx >= x1) return;
        if (lx > rx) {
          if (!va) va = {
            x: fx,
            y: y0
          }; else if (va.y >= y1) return;
          vb = {
            x: fx,
            y: y1
          };
        } else {
          if (!va) va = {
            x: fx,
            y: y1
          }; else if (va.y < y0) return;
          vb = {
            x: fx,
            y: y0
          };
        }
      } else {
        fm = (lx - rx) / (ry - ly);
        fb = fy - fm * fx;
        if (fm < -1 || fm > 1) {
          if (lx > rx) {
            if (!va) va = {
              x: (y0 - fb) / fm,
              y: y0
            }; else if (va.y >= y1) return;
            vb = {
              x: (y1 - fb) / fm,
              y: y1
            };
          } else {
            if (!va) va = {
              x: (y1 - fb) / fm,
              y: y1
            }; else if (va.y < y0) return;
            vb = {
              x: (y0 - fb) / fm,
              y: y0
            };
          }
        } else {
          if (ly < ry) {
            if (!va) va = {
              x: x0,
              y: fm * x0 + fb
            }; else if (va.x >= x1) return;
            vb = {
              x: x1,
              y: fm * x1 + fb
            };
          } else {
            if (!va) va = {
              x: x1,
              y: fm * x1 + fb
            }; else if (va.x < x0) return;
            vb = {
              x: x0,
              y: fm * x0 + fb
            };
          }
        }
      }
      edge.a = va;
      edge.b = vb;
      return true;
    }
    function d3_geom_voronoiEdge(lSite, rSite) {
      this.l = lSite;
      this.r = rSite;
      this.a = this.b = null;
    }
    function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
      var edge = new d3_geom_voronoiEdge(lSite, rSite);
      d3_geom_voronoiEdges.push(edge);
      if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
      if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
      d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
      d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
      return edge;
    }
    function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
      var edge = new d3_geom_voronoiEdge(lSite, null);
      edge.a = va;
      edge.b = vb;
      d3_geom_voronoiEdges.push(edge);
      return edge;
    }
    function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
      if (!edge.a && !edge.b) {
        edge.a = vertex;
        edge.l = lSite;
        edge.r = rSite;
      } else if (edge.l === rSite) {
        edge.b = vertex;
      } else {
        edge.a = vertex;
      }
    }
    function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
      var va = edge.a, vb = edge.b;
      this.edge = edge;
      this.site = lSite;
      this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
    }
    d3_geom_voronoiHalfEdge.prototype = {
      start: function() {
        return this.edge.l === this.site ? this.edge.a : this.edge.b;
      },
      end: function() {
        return this.edge.l === this.site ? this.edge.b : this.edge.a;
      }
    };
    function d3_geom_voronoiRedBlackTree() {
      this._ = null;
    }
    function d3_geom_voronoiRedBlackNode(node) {
      node.U = node.C = node.L = node.R = node.P = node.N = null;
    }
    d3_geom_voronoiRedBlackTree.prototype = {
      insert: function(after, node) {
        var parent, grandpa, uncle;
        if (after) {
          node.P = after;
          node.N = after.N;
          if (after.N) after.N.P = node;
          after.N = node;
          if (after.R) {
            after = after.R;
            while (after.L) after = after.L;
            after.L = node;
          } else {
            after.R = node;
          }
          parent = after;
        } else if (this._) {
          after = d3_geom_voronoiRedBlackFirst(this._);
          node.P = null;
          node.N = after;
          after.P = after.L = node;
          parent = after;
        } else {
          node.P = node.N = null;
          this._ = node;
          parent = null;
        }
        node.L = node.R = null;
        node.U = parent;
        node.C = true;
        after = node;
        while (parent && parent.C) {
          grandpa = parent.U;
          if (parent === grandpa.L) {
            uncle = grandpa.R;
            if (uncle && uncle.C) {
              parent.C = uncle.C = false;
              grandpa.C = true;
              after = grandpa;
            } else {
              if (after === parent.R) {
                d3_geom_voronoiRedBlackRotateLeft(this, parent);
                after = parent;
                parent = after.U;
              }
              parent.C = false;
              grandpa.C = true;
              d3_geom_voronoiRedBlackRotateRight(this, grandpa);
            }
          } else {
            uncle = grandpa.L;
            if (uncle && uncle.C) {
              parent.C = uncle.C = false;
              grandpa.C = true;
              after = grandpa;
            } else {
              if (after === parent.L) {
                d3_geom_voronoiRedBlackRotateRight(this, parent);
                after = parent;
                parent = after.U;
              }
              parent.C = false;
              grandpa.C = true;
              d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
            }
          }
          parent = after.U;
        }
        this._.C = false;
      },
      remove: function(node) {
        if (node.N) node.N.P = node.P;
        if (node.P) node.P.N = node.N;
        node.N = node.P = null;
        var parent = node.U, sibling, left = node.L, right = node.R, next, red;
        if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
        if (parent) {
          if (parent.L === node) parent.L = next; else parent.R = next;
        } else {
          this._ = next;
        }
        if (left && right) {
          red = next.C;
          next.C = node.C;
          next.L = left;
          left.U = next;
          if (next !== right) {
            parent = next.U;
            next.U = node.U;
            node = next.R;
            parent.L = node;
            next.R = right;
            right.U = next;
          } else {
            next.U = parent;
            parent = next;
            node = next.R;
          }
        } else {
          red = node.C;
          node = next;
        }
        if (node) node.U = parent;
        if (red) return;
        if (node && node.C) {
          node.C = false;
          return;
        }
        do {
          if (node === this._) break;
          if (node === parent.L) {
            sibling = parent.R;
            if (sibling.C) {
              sibling.C = false;
              parent.C = true;
              d3_geom_voronoiRedBlackRotateLeft(this, parent);
              sibling = parent.R;
            }
            if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
              if (!sibling.R || !sibling.R.C) {
                sibling.L.C = false;
                sibling.C = true;
                d3_geom_voronoiRedBlackRotateRight(this, sibling);
                sibling = parent.R;
              }
              sibling.C = parent.C;
              parent.C = sibling.R.C = false;
              d3_geom_voronoiRedBlackRotateLeft(this, parent);
              node = this._;
              break;
            }
          } else {
            sibling = parent.L;
            if (sibling.C) {
              sibling.C = false;
              parent.C = true;
              d3_geom_voronoiRedBlackRotateRight(this, parent);
              sibling = parent.L;
            }
            if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
              if (!sibling.L || !sibling.L.C) {
                sibling.R.C = false;
                sibling.C = true;
                d3_geom_voronoiRedBlackRotateLeft(this, sibling);
                sibling = parent.L;
              }
              sibling.C = parent.C;
              parent.C = sibling.L.C = false;
              d3_geom_voronoiRedBlackRotateRight(this, parent);
              node = this._;
              break;
            }
          }
          sibling.C = true;
          node = parent;
          parent = parent.U;
        } while (!node.C);
        if (node) node.C = false;
      }
    };
    function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
      var p = node, q = node.R, parent = p.U;
      if (parent) {
        if (parent.L === p) parent.L = q; else parent.R = q;
      } else {
        tree._ = q;
      }
      q.U = parent;
      p.U = q;
      p.R = q.L;
      if (p.R) p.R.U = p;
      q.L = p;
    }
    function d3_geom_voronoiRedBlackRotateRight(tree, node) {
      var p = node, q = node.L, parent = p.U;
      if (parent) {
        if (parent.L === p) parent.L = q; else parent.R = q;
      } else {
        tree._ = q;
      }
      q.U = parent;
      p.U = q;
      p.L = q.R;
      if (p.L) p.L.U = p;
      q.R = p;
    }
    function d3_geom_voronoiRedBlackFirst(node) {
      while (node.L) node = node.L;
      return node;
    }
    function d3_geom_voronoi(sites, bbox) {
      var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
      d3_geom_voronoiEdges = [];
      d3_geom_voronoiCells = new Array(sites.length);
      d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
      d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
      while (true) {
        circle = d3_geom_voronoiFirstCircle;
        if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
          if (site.x !== x0 || site.y !== y0) {
            d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
            d3_geom_voronoiAddBeach(site);
            x0 = site.x, y0 = site.y;
          }
          site = sites.pop();
        } else if (circle) {
          d3_geom_voronoiRemoveBeach(circle.arc);
        } else {
          break;
        }
      }
      if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
      var diagram = {
        cells: d3_geom_voronoiCells,
        edges: d3_geom_voronoiEdges
      };
      d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
      return diagram;
    }
    function d3_geom_voronoiVertexOrder(a, b) {
      return b.y - a.y || b.x - a.x;
    }
    d3.geom.voronoi = function(points) {
      var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
      if (points) return voronoi(points);
      function voronoi(data) {
        var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
        d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
          var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
            var s = e.start();
            return [ s.x, s.y ];
          }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
          polygon.point = data[i];
        });
        return polygons;
      }
      function sites(data) {
        return data.map(function(d, i) {
          return {
            x: Math.round(fx(d, i) / ε) * ε,
            y: Math.round(fy(d, i) / ε) * ε,
            i: i
          };
        });
      }
      voronoi.links = function(data) {
        return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
          return edge.l && edge.r;
        }).map(function(edge) {
          return {
            source: data[edge.l.i],
            target: data[edge.r.i]
          };
        });
      };
      voronoi.triangles = function(data) {
        var triangles = [];
        d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
          var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
          while (++j < m) {
            e0 = e1;
            s0 = s1;
            e1 = edges[j].edge;
            s1 = e1.l === site ? e1.r : e1.l;
            if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
              triangles.push([ data[i], data[s0.i], data[s1.i] ]);
            }
          }
        });
        return triangles;
      };
      voronoi.x = function(_) {
        return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
      };
      voronoi.y = function(_) {
        return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
      };
      voronoi.clipExtent = function(_) {
        if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
        clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
        return voronoi;
      };
      voronoi.size = function(_) {
        if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
        return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
      };
      return voronoi;
    };
    var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
    function d3_geom_voronoiTriangleArea(a, b, c) {
      return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
    }
    d3.geom.delaunay = function(vertices) {
      return d3.geom.voronoi().triangles(vertices);
    };
    d3.geom.quadtree = function(points, x1, y1, x2, y2) {
      var x = d3_geom_pointX, y = d3_geom_pointY, compat;
      if (compat = arguments.length) {
        x = d3_geom_quadtreeCompatX;
        y = d3_geom_quadtreeCompatY;
        if (compat === 3) {
          y2 = y1;
          x2 = x1;
          y1 = x1 = 0;
        }
        return quadtree(points);
      }
      function quadtree(data) {
        var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
        if (x1 != null) {
          x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
        } else {
          x2_ = y2_ = -(x1_ = y1_ = Infinity);
          xs = [], ys = [];
          n = data.length;
          if (compat) for (i = 0; i < n; ++i) {
            d = data[i];
            if (d.x < x1_) x1_ = d.x;
            if (d.y < y1_) y1_ = d.y;
            if (d.x > x2_) x2_ = d.x;
            if (d.y > y2_) y2_ = d.y;
            xs.push(d.x);
            ys.push(d.y);
          } else for (i = 0; i < n; ++i) {
            var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
            if (x_ < x1_) x1_ = x_;
            if (y_ < y1_) y1_ = y_;
            if (x_ > x2_) x2_ = x_;
            if (y_ > y2_) y2_ = y_;
            xs.push(x_);
            ys.push(y_);
          }
        }
        var dx = x2_ - x1_, dy = y2_ - y1_;
        if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
        function insert(n, d, x, y, x1, y1, x2, y2) {
          if (isNaN(x) || isNaN(y)) return;
          if (n.leaf) {
            var nx = n.x, ny = n.y;
            if (nx != null) {
              if (abs(nx - x) + abs(ny - y) < .01) {
                insertChild(n, d, x, y, x1, y1, x2, y2);
              } else {
                var nPoint = n.point;
                n.x = n.y = n.point = null;
                insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
                insertChild(n, d, x, y, x1, y1, x2, y2);
              }
            } else {
              n.x = x, n.y = y, n.point = d;
            }
          } else {
            insertChild(n, d, x, y, x1, y1, x2, y2);
          }
        }
        function insertChild(n, d, x, y, x1, y1, x2, y2) {
          var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, right = x >= sx, bottom = y >= sy, i = (bottom << 1) + right;
          n.leaf = false;
          n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
          if (right) x1 = sx; else x2 = sx;
          if (bottom) y1 = sy; else y2 = sy;
          insert(n, d, x, y, x1, y1, x2, y2);
        }
        var root = d3_geom_quadtreeNode();
        root.add = function(d) {
          insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
        };
        root.visit = function(f) {
          d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
        };
        i = -1;
        if (x1 == null) {
          while (++i < n) {
            insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
          }
          --i;
        } else data.forEach(root.add);
        xs = ys = data = d = null;
        return root;
      }
      quadtree.x = function(_) {
        return arguments.length ? (x = _, quadtree) : x;
      };
      quadtree.y = function(_) {
        return arguments.length ? (y = _, quadtree) : y;
      };
      quadtree.extent = function(_) {
        if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
        if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
        y2 = +_[1][1];
        return quadtree;
      };
      quadtree.size = function(_) {
        if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
        if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
        return quadtree;
      };
      return quadtree;
    };
    function d3_geom_quadtreeCompatX(d) {
      return d.x;
    }
    function d3_geom_quadtreeCompatY(d) {
      return d.y;
    }
    function d3_geom_quadtreeNode() {
      return {
        leaf: true,
        nodes: [],
        point: null,
        x: null,
        y: null
      };
    }
    function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
      if (!f(node, x1, y1, x2, y2)) {
        var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
        if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
        if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
        if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
        if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
      }
    }
    d3.interpolateRgb = d3_interpolateRgb;
    function d3_interpolateRgb(a, b) {
      a = d3.rgb(a);
      b = d3.rgb(b);
      var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
      return function(t) {
        return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
      };
    }
    d3.interpolateObject = d3_interpolateObject;
    function d3_interpolateObject(a, b) {
      var i = {}, c = {}, k;
      for (k in a) {
        if (k in b) {
          i[k] = d3_interpolate(a[k], b[k]);
        } else {
          c[k] = a[k];
        }
      }
      for (k in b) {
        if (!(k in a)) {
          c[k] = b[k];
        }
      }
      return function(t) {
        for (k in i) c[k] = i[k](t);
        return c;
      };
    }
    d3.interpolateNumber = d3_interpolateNumber;
    function d3_interpolateNumber(a, b) {
      b -= a = +a;
      return function(t) {
        return a + b * t;
      };
    }
    d3.interpolateString = d3_interpolateString;
    function d3_interpolateString(a, b) {
      var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
      a = a + "", b = b + "";
      while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
        if ((bs = bm.index) > bi) {
          bs = b.substring(bi, bs);
          if (s[i]) s[i] += bs; else s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) {
          if (s[i]) s[i] += bm; else s[++i] = bm;
        } else {
          s[++i] = null;
          q.push({
            i: i,
            x: d3_interpolateNumber(am, bm)
          });
        }
        bi = d3_interpolate_numberB.lastIndex;
      }
      if (bi < b.length) {
        bs = b.substring(bi);
        if (s[i]) s[i] += bs; else s[++i] = bs;
      }
      return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
        return b(t) + "";
      }) : function() {
        return b;
      } : (b = q.length, function(t) {
        for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
        return s.join("");
      });
    }
    var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
    d3.interpolate = d3_interpolate;
    function d3_interpolate(a, b) {
      var i = d3.interpolators.length, f;
      while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
      return f;
    }
    d3.interpolators = [ function(a, b) {
      var t = typeof b;
      return (t === "string" ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
    } ];
    d3.interpolateArray = d3_interpolateArray;
    function d3_interpolateArray(a, b) {
      var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
      for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
      for (;i < na; ++i) c[i] = a[i];
      for (;i < nb; ++i) c[i] = b[i];
      return function(t) {
        for (i = 0; i < n0; ++i) c[i] = x[i](t);
        return c;
      };
    }
    var d3_ease_default = function() {
      return d3_identity;
    };
    var d3_ease = d3.map({
      linear: d3_ease_default,
      poly: d3_ease_poly,
      quad: function() {
        return d3_ease_quad;
      },
      cubic: function() {
        return d3_ease_cubic;
      },
      sin: function() {
        return d3_ease_sin;
      },
      exp: function() {
        return d3_ease_exp;
      },
      circle: function() {
        return d3_ease_circle;
      },
      elastic: d3_ease_elastic,
      back: d3_ease_back,
      bounce: function() {
        return d3_ease_bounce;
      }
    });
    var d3_ease_mode = d3.map({
      "in": d3_identity,
      out: d3_ease_reverse,
      "in-out": d3_ease_reflect,
      "out-in": function(f) {
        return d3_ease_reflect(d3_ease_reverse(f));
      }
    });
    d3.ease = function(name) {
      var i = name.indexOf("-"), t = i >= 0 ? name.substring(0, i) : name, m = i >= 0 ? name.substring(i + 1) : "in";
      t = d3_ease.get(t) || d3_ease_default;
      m = d3_ease_mode.get(m) || d3_identity;
      return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
    };
    function d3_ease_clamp(f) {
      return function(t) {
        return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
      };
    }
    function d3_ease_reverse(f) {
      return function(t) {
        return 1 - f(1 - t);
      };
    }
    function d3_ease_reflect(f) {
      return function(t) {
        return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
      };
    }
    function d3_ease_quad(t) {
      return t * t;
    }
    function d3_ease_cubic(t) {
      return t * t * t;
    }
    function d3_ease_cubicInOut(t) {
      if (t <= 0) return 0;
      if (t >= 1) return 1;
      var t2 = t * t, t3 = t2 * t;
      return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
    }
    function d3_ease_poly(e) {
      return function(t) {
        return Math.pow(t, e);
      };
    }
    function d3_ease_sin(t) {
      return 1 - Math.cos(t * halfπ);
    }
    function d3_ease_exp(t) {
      return Math.pow(2, 10 * (t - 1));
    }
    function d3_ease_circle(t) {
      return 1 - Math.sqrt(1 - t * t);
    }
    function d3_ease_elastic(a, p) {
      var s;
      if (arguments.length < 2) p = .45;
      if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;
      return function(t) {
        return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
      };
    }
    function d3_ease_back(s) {
      if (!s) s = 1.70158;
      return function(t) {
        return t * t * ((s + 1) * t - s);
      };
    }
    function d3_ease_bounce(t) {
      return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
    }
    d3.interpolateHcl = d3_interpolateHcl;
    function d3_interpolateHcl(a, b) {
      a = d3.hcl(a);
      b = d3.hcl(b);
      var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
      if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
      if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
      return function(t) {
        return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
      };
    }
    d3.interpolateHsl = d3_interpolateHsl;
    function d3_interpolateHsl(a, b) {
      a = d3.hsl(a);
      b = d3.hsl(b);
      var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
      if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
      if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
      return function(t) {
        return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
      };
    }
    d3.interpolateLab = d3_interpolateLab;
    function d3_interpolateLab(a, b) {
      a = d3.lab(a);
      b = d3.lab(b);
      var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
      return function(t) {
        return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
      };
    }
    d3.interpolateRound = d3_interpolateRound;
    function d3_interpolateRound(a, b) {
      b -= a;
      return function(t) {
        return Math.round(a + b * t);
      };
    }
    d3.transform = function(string) {
      var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
      return (d3.transform = function(string) {
        if (string != null) {
          g.setAttribute("transform", string);
          var t = g.transform.baseVal.consolidate();
        }
        return new d3_transform(t ? t.matrix : d3_transformIdentity);
      })(string);
    };
    function d3_transform(m) {
      var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
      if (r0[0] * r1[1] < r1[0] * r0[1]) {
        r0[0] *= -1;
        r0[1] *= -1;
        kx *= -1;
        kz *= -1;
      }
      this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
      this.translate = [ m.e, m.f ];
      this.scale = [ kx, ky ];
      this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
    }
    d3_transform.prototype.toString = function() {
      return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
    };
    function d3_transformDot(a, b) {
      return a[0] * b[0] + a[1] * b[1];
    }
    function d3_transformNormalize(a) {
      var k = Math.sqrt(d3_transformDot(a, a));
      if (k) {
        a[0] /= k;
        a[1] /= k;
      }
      return k;
    }
    function d3_transformCombine(a, b, k) {
      a[0] += k * b[0];
      a[1] += k * b[1];
      return a;
    }
    var d3_transformIdentity = {
      a: 1,
      b: 0,
      c: 0,
      d: 1,
      e: 0,
      f: 0
    };
    d3.interpolateTransform = d3_interpolateTransform;
    function d3_interpolateTransform(a, b) {
      var s = [], q = [], n, A = d3.transform(a), B = d3.transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
      if (ta[0] != tb[0] || ta[1] != tb[1]) {
        s.push("translate(", null, ",", null, ")");
        q.push({
          i: 1,
          x: d3_interpolateNumber(ta[0], tb[0])
        }, {
          i: 3,
          x: d3_interpolateNumber(ta[1], tb[1])
        });
      } else if (tb[0] || tb[1]) {
        s.push("translate(" + tb + ")");
      } else {
        s.push("");
      }
      if (ra != rb) {
        if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
        q.push({
          i: s.push(s.pop() + "rotate(", null, ")") - 2,
          x: d3_interpolateNumber(ra, rb)
        });
      } else if (rb) {
        s.push(s.pop() + "rotate(" + rb + ")");
      }
      if (wa != wb) {
        q.push({
          i: s.push(s.pop() + "skewX(", null, ")") - 2,
          x: d3_interpolateNumber(wa, wb)
        });
      } else if (wb) {
        s.push(s.pop() + "skewX(" + wb + ")");
      }
      if (ka[0] != kb[0] || ka[1] != kb[1]) {
        n = s.push(s.pop() + "scale(", null, ",", null, ")");
        q.push({
          i: n - 4,
          x: d3_interpolateNumber(ka[0], kb[0])
        }, {
          i: n - 2,
          x: d3_interpolateNumber(ka[1], kb[1])
        });
      } else if (kb[0] != 1 || kb[1] != 1) {
        s.push(s.pop() + "scale(" + kb + ")");
      }
      n = q.length;
      return function(t) {
        var i = -1, o;
        while (++i < n) s[(o = q[i]).i] = o.x(t);
        return s.join("");
      };
    }
    function d3_uninterpolateNumber(a, b) {
      b = b - (a = +a) ? 1 / (b - a) : 0;
      return function(x) {
        return (x - a) * b;
      };
    }
    function d3_uninterpolateClamp(a, b) {
      b = b - (a = +a) ? 1 / (b - a) : 0;
      return function(x) {
        return Math.max(0, Math.min(1, (x - a) * b));
      };
    }
    d3.layout = {};
    d3.layout.bundle = function() {
      return function(links) {
        var paths = [], i = -1, n = links.length;
        while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
        return paths;
      };
    };
    function d3_layout_bundlePath(link) {
      var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
      while (start !== lca) {
        start = start.parent;
        points.push(start);
      }
      var k = points.length;
      while (end !== lca) {
        points.splice(k, 0, end);
        end = end.parent;
      }
      return points;
    }
    function d3_layout_bundleAncestors(node) {
      var ancestors = [], parent = node.parent;
      while (parent != null) {
        ancestors.push(node);
        node = parent;
        parent = parent.parent;
      }
      ancestors.push(node);
      return ancestors;
    }
    function d3_layout_bundleLeastCommonAncestor(a, b) {
      if (a === b) return a;
      var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
      while (aNode === bNode) {
        sharedNode = aNode;
        aNode = aNodes.pop();
        bNode = bNodes.pop();
      }
      return sharedNode;
    }
    d3.layout.chord = function() {
      var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
      function relayout() {
        var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
        chords = [];
        groups = [];
        k = 0, i = -1;
        while (++i < n) {
          x = 0, j = -1;
          while (++j < n) {
            x += matrix[i][j];
          }
          groupSums.push(x);
          subgroupIndex.push(d3.range(n));
          k += x;
        }
        if (sortGroups) {
          groupIndex.sort(function(a, b) {
            return sortGroups(groupSums[a], groupSums[b]);
          });
        }
        if (sortSubgroups) {
          subgroupIndex.forEach(function(d, i) {
            d.sort(function(a, b) {
              return sortSubgroups(matrix[i][a], matrix[i][b]);
            });
          });
        }
        k = (τ - padding * n) / k;
        x = 0, i = -1;
        while (++i < n) {
          x0 = x, j = -1;
          while (++j < n) {
            var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
            subgroups[di + "-" + dj] = {
              index: di,
              subindex: dj,
              startAngle: a0,
              endAngle: a1,
              value: v
            };
          }
          groups[di] = {
            index: di,
            startAngle: x0,
            endAngle: x,
            value: (x - x0) / k
          };
          x += padding;
        }
        i = -1;
        while (++i < n) {
          j = i - 1;
          while (++j < n) {
            var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
            if (source.value || target.value) {
              chords.push(source.value < target.value ? {
                source: target,
                target: source
              } : {
                source: source,
                target: target
              });
            }
          }
        }
        if (sortChords) resort();
      }
      function resort() {
        chords.sort(function(a, b) {
          return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
        });
      }
      chord.matrix = function(x) {
        if (!arguments.length) return matrix;
        n = (matrix = x) && matrix.length;
        chords = groups = null;
        return chord;
      };
      chord.padding = function(x) {
        if (!arguments.length) return padding;
        padding = x;
        chords = groups = null;
        return chord;
      };
      chord.sortGroups = function(x) {
        if (!arguments.length) return sortGroups;
        sortGroups = x;
        chords = groups = null;
        return chord;
      };
      chord.sortSubgroups = function(x) {
        if (!arguments.length) return sortSubgroups;
        sortSubgroups = x;
        chords = null;
        return chord;
      };
      chord.sortChords = function(x) {
        if (!arguments.length) return sortChords;
        sortChords = x;
        if (chords) resort();
        return chord;
      };
      chord.chords = function() {
        if (!chords) relayout();
        return chords;
      };
      chord.groups = function() {
        if (!groups) relayout();
        return groups;
      };
      return chord;
    };
    d3.layout.force = function() {
      var force = {}, event = d3.dispatch("start", "tick", "end"), size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
      function repulse(node) {
        return function(quad, x1, _, x2) {
          if (quad.point !== node) {
            var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
            if (dw * dw / theta2 < dn) {
              if (dn < chargeDistance2) {
                var k = quad.charge / dn;
                node.px -= dx * k;
                node.py -= dy * k;
              }
              return true;
            }
            if (quad.point && dn && dn < chargeDistance2) {
              var k = quad.pointCharge / dn;
              node.px -= dx * k;
              node.py -= dy * k;
            }
          }
          return !quad.charge;
        };
      }
      force.tick = function() {
        if ((alpha *= .99) < .005) {
          event.end({
            type: "end",
            alpha: alpha = 0
          });
          return true;
        }
        var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
        for (i = 0; i < m; ++i) {
          o = links[i];
          s = o.source;
          t = o.target;
          x = t.x - s.x;
          y = t.y - s.y;
          if (l = x * x + y * y) {
            l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
            x *= l;
            y *= l;
            t.x -= x * (k = s.weight / (t.weight + s.weight));
            t.y -= y * k;
            s.x += x * (k = 1 - k);
            s.y += y * k;
          }
        }
        if (k = alpha * gravity) {
          x = size[0] / 2;
          y = size[1] / 2;
          i = -1;
          if (k) while (++i < n) {
            o = nodes[i];
            o.x += (x - o.x) * k;
            o.y += (y - o.y) * k;
          }
        }
        if (charge) {
          d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
          i = -1;
          while (++i < n) {
            if (!(o = nodes[i]).fixed) {
              q.visit(repulse(o));
            }
          }
        }
        i = -1;
        while (++i < n) {
          o = nodes[i];
          if (o.fixed) {
            o.x = o.px;
            o.y = o.py;
          } else {
            o.x -= (o.px - (o.px = o.x)) * friction;
            o.y -= (o.py - (o.py = o.y)) * friction;
          }
        }
        event.tick({
          type: "tick",
          alpha: alpha
        });
      };
      force.nodes = function(x) {
        if (!arguments.length) return nodes;
        nodes = x;
        return force;
      };
      force.links = function(x) {
        if (!arguments.length) return links;
        links = x;
        return force;
      };
      force.size = function(x) {
        if (!arguments.length) return size;
        size = x;
        return force;
      };
      force.linkDistance = function(x) {
        if (!arguments.length) return linkDistance;
        linkDistance = typeof x === "function" ? x : +x;
        return force;
      };
      force.distance = force.linkDistance;
      force.linkStrength = function(x) {
        if (!arguments.length) return linkStrength;
        linkStrength = typeof x === "function" ? x : +x;
        return force;
      };
      force.friction = function(x) {
        if (!arguments.length) return friction;
        friction = +x;
        return force;
      };
      force.charge = function(x) {
        if (!arguments.length) return charge;
        charge = typeof x === "function" ? x : +x;
        return force;
      };
      force.chargeDistance = function(x) {
        if (!arguments.length) return Math.sqrt(chargeDistance2);
        chargeDistance2 = x * x;
        return force;
      };
      force.gravity = function(x) {
        if (!arguments.length) return gravity;
        gravity = +x;
        return force;
      };
      force.theta = function(x) {
        if (!arguments.length) return Math.sqrt(theta2);
        theta2 = x * x;
        return force;
      };
      force.alpha = function(x) {
        if (!arguments.length) return alpha;
        x = +x;
        if (alpha) {
          if (x > 0) alpha = x; else alpha = 0;
        } else if (x > 0) {
          event.start({
            type: "start",
            alpha: alpha = x
          });
          d3.timer(force.tick);
        }
        return force;
      };
      force.start = function() {
        var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
        for (i = 0; i < n; ++i) {
          (o = nodes[i]).index = i;
          o.weight = 0;
        }
        for (i = 0; i < m; ++i) {
          o = links[i];
          if (typeof o.source == "number") o.source = nodes[o.source];
          if (typeof o.target == "number") o.target = nodes[o.target];
          ++o.source.weight;
          ++o.target.weight;
        }
        for (i = 0; i < n; ++i) {
          o = nodes[i];
          if (isNaN(o.x)) o.x = position("x", w);
          if (isNaN(o.y)) o.y = position("y", h);
          if (isNaN(o.px)) o.px = o.x;
          if (isNaN(o.py)) o.py = o.y;
        }
        distances = [];
        if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
        strengths = [];
        if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
        charges = [];
        if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
        function position(dimension, size) {
          if (!neighbors) {
            neighbors = new Array(n);
            for (j = 0; j < n; ++j) {
              neighbors[j] = [];
            }
            for (j = 0; j < m; ++j) {
              var o = links[j];
              neighbors[o.source.index].push(o.target);
              neighbors[o.target.index].push(o.source);
            }
          }
          var candidates = neighbors[i], j = -1, m = candidates.length, x;
          while (++j < m) if (!isNaN(x = candidates[j][dimension])) return x;
          return Math.random() * size;
        }
        return force.resume();
      };
      force.resume = function() {
        return force.alpha(.1);
      };
      force.stop = function() {
        return force.alpha(0);
      };
      force.drag = function() {
        if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
        if (!arguments.length) return drag;
        this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
      };
      function dragmove(d) {
        d.px = d3.event.x, d.py = d3.event.y;
        force.resume();
      }
      return d3.rebind(force, event, "on");
    };
    function d3_layout_forceDragstart(d) {
      d.fixed |= 2;
    }
    function d3_layout_forceDragend(d) {
      d.fixed &= ~6;
    }
    function d3_layout_forceMouseover(d) {
      d.fixed |= 4;
      d.px = d.x, d.py = d.y;
    }
    function d3_layout_forceMouseout(d) {
      d.fixed &= ~4;
    }
    function d3_layout_forceAccumulate(quad, alpha, charges) {
      var cx = 0, cy = 0;
      quad.charge = 0;
      if (!quad.leaf) {
        var nodes = quad.nodes, n = nodes.length, i = -1, c;
        while (++i < n) {
          c = nodes[i];
          if (c == null) continue;
          d3_layout_forceAccumulate(c, alpha, charges);
          quad.charge += c.charge;
          cx += c.charge * c.cx;
          cy += c.charge * c.cy;
        }
      }
      if (quad.point) {
        if (!quad.leaf) {
          quad.point.x += Math.random() - .5;
          quad.point.y += Math.random() - .5;
        }
        var k = alpha * charges[quad.point.index];
        quad.charge += quad.pointCharge = k;
        cx += k * quad.point.x;
        cy += k * quad.point.y;
      }
      quad.cx = cx / quad.charge;
      quad.cy = cy / quad.charge;
    }
    var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
    d3.layout.hierarchy = function() {
      var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
      function hierarchy(root) {
        var stack = [ root ], nodes = [], node;
        root.depth = 0;
        while ((node = stack.pop()) != null) {
          nodes.push(node);
          if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
            var n, childs, child;
            while (--n >= 0) {
              stack.push(child = childs[n]);
              child.parent = node;
              child.depth = node.depth + 1;
            }
            if (value) node.value = 0;
            node.children = childs;
          } else {
            if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
            delete node.children;
          }
        }
        d3_layout_hierarchyVisitAfter(root, function(node) {
          var childs, parent;
          if (sort && (childs = node.children)) childs.sort(sort);
          if (value && (parent = node.parent)) parent.value += node.value;
        });
        return nodes;
      }
      hierarchy.sort = function(x) {
        if (!arguments.length) return sort;
        sort = x;
        return hierarchy;
      };
      hierarchy.children = function(x) {
        if (!arguments.length) return children;
        children = x;
        return hierarchy;
      };
      hierarchy.value = function(x) {
        if (!arguments.length) return value;
        value = x;
        return hierarchy;
      };
      hierarchy.revalue = function(root) {
        if (value) {
          d3_layout_hierarchyVisitBefore(root, function(node) {
            if (node.children) node.value = 0;
          });
          d3_layout_hierarchyVisitAfter(root, function(node) {
            var parent;
            if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
            if (parent = node.parent) parent.value += node.value;
          });
        }
        return root;
      };
      return hierarchy;
    };
    function d3_layout_hierarchyRebind(object, hierarchy) {
      d3.rebind(object, hierarchy, "sort", "children", "value");
      object.nodes = object;
      object.links = d3_layout_hierarchyLinks;
      return object;
    }
    function d3_layout_hierarchyVisitBefore(node, callback) {
      var nodes = [ node ];
      while ((node = nodes.pop()) != null) {
        callback(node);
        if ((children = node.children) && (n = children.length)) {
          var n, children;
          while (--n >= 0) nodes.push(children[n]);
        }
      }
    }
    function d3_layout_hierarchyVisitAfter(node, callback) {
      var nodes = [ node ], nodes2 = [];
      while ((node = nodes.pop()) != null) {
        nodes2.push(node);
        if ((children = node.children) && (n = children.length)) {
          var i = -1, n, children;
          while (++i < n) nodes.push(children[i]);
        }
      }
      while ((node = nodes2.pop()) != null) {
        callback(node);
      }
    }
    function d3_layout_hierarchyChildren(d) {
      return d.children;
    }
    function d3_layout_hierarchyValue(d) {
      return d.value;
    }
    function d3_layout_hierarchySort(a, b) {
      return b.value - a.value;
    }
    function d3_layout_hierarchyLinks(nodes) {
      return d3.merge(nodes.map(function(parent) {
        return (parent.children || []).map(function(child) {
          return {
            source: parent,
            target: child
          };
        });
      }));
    }
    d3.layout.partition = function() {
      var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
      function position(node, x, dx, dy) {
        var children = node.children;
        node.x = x;
        node.y = node.depth * dy;
        node.dx = dx;
        node.dy = dy;
        if (children && (n = children.length)) {
          var i = -1, n, c, d;
          dx = node.value ? dx / node.value : 0;
          while (++i < n) {
            position(c = children[i], x, d = c.value * dx, dy);
            x += d;
          }
        }
      }
      function depth(node) {
        var children = node.children, d = 0;
        if (children && (n = children.length)) {
          var i = -1, n;
          while (++i < n) d = Math.max(d, depth(children[i]));
        }
        return 1 + d;
      }
      function partition(d, i) {
        var nodes = hierarchy.call(this, d, i);
        position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
        return nodes;
      }
      partition.size = function(x) {
        if (!arguments.length) return size;
        size = x;
        return partition;
      };
      return d3_layout_hierarchyRebind(partition, hierarchy);
    };
    d3.layout.pie = function() {
      var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ;
      function pie(data) {
        var values = data.map(function(d, i) {
          return +value.call(pie, d, i);
        });
        var a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle);
        var k = ((typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a) / d3.sum(values);
        var index = d3.range(data.length);
        if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
          return values[j] - values[i];
        } : function(i, j) {
          return sort(data[i], data[j]);
        });
        var arcs = [];
        index.forEach(function(i) {
          var d;
          arcs[i] = {
            data: data[i],
            value: d = values[i],
            startAngle: a,
            endAngle: a += d * k
          };
        });
        return arcs;
      }
      pie.value = function(x) {
        if (!arguments.length) return value;
        value = x;
        return pie;
      };
      pie.sort = function(x) {
        if (!arguments.length) return sort;
        sort = x;
        return pie;
      };
      pie.startAngle = function(x) {
        if (!arguments.length) return startAngle;
        startAngle = x;
        return pie;
      };
      pie.endAngle = function(x) {
        if (!arguments.length) return endAngle;
        endAngle = x;
        return pie;
      };
      return pie;
    };
    var d3_layout_pieSortByValue = {};
    d3.layout.stack = function() {
      var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
      function stack(data, index) {
        var series = data.map(function(d, i) {
          return values.call(stack, d, i);
        });
        var points = series.map(function(d) {
          return d.map(function(v, i) {
            return [ x.call(stack, v, i), y.call(stack, v, i) ];
          });
        });
        var orders = order.call(stack, points, index);
        series = d3.permute(series, orders);
        points = d3.permute(points, orders);
        var offsets = offset.call(stack, points, index);
        var n = series.length, m = series[0].length, i, j, o;
        for (j = 0; j < m; ++j) {
          out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
          for (i = 1; i < n; ++i) {
            out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
          }
        }
        return data;
      }
      stack.values = function(x) {
        if (!arguments.length) return values;
        values = x;
        return stack;
      };
      stack.order = function(x) {
        if (!arguments.length) return order;
        order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
        return stack;
      };
      stack.offset = function(x) {
        if (!arguments.length) return offset;
        offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
        return stack;
      };
      stack.x = function(z) {
        if (!arguments.length) return x;
        x = z;
        return stack;
      };
      stack.y = function(z) {
        if (!arguments.length) return y;
        y = z;
        return stack;
      };
      stack.out = function(z) {
        if (!arguments.length) return out;
        out = z;
        return stack;
      };
      return stack;
    };
    function d3_layout_stackX(d) {
      return d.x;
    }
    function d3_layout_stackY(d) {
      return d.y;
    }
    function d3_layout_stackOut(d, y0, y) {
      d.y0 = y0;
      d.y = y;
    }
    var d3_layout_stackOrders = d3.map({
      "inside-out": function(data) {
        var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
          return max[a] - max[b];
        }), top = 0, bottom = 0, tops = [], bottoms = [];
        for (i = 0; i < n; ++i) {
          j = index[i];
          if (top < bottom) {
            top += sums[j];
            tops.push(j);
          } else {
            bottom += sums[j];
            bottoms.push(j);
          }
        }
        return bottoms.reverse().concat(tops);
      },
      reverse: function(data) {
        return d3.range(data.length).reverse();
      },
      "default": d3_layout_stackOrderDefault
    });
    var d3_layout_stackOffsets = d3.map({
      silhouette: function(data) {
        var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
        for (j = 0; j < m; ++j) {
          for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
          if (o > max) max = o;
          sums.push(o);
        }
        for (j = 0; j < m; ++j) {
          y0[j] = (max - sums[j]) / 2;
        }
        return y0;
      },
      wiggle: function(data) {
        var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
        y0[0] = o = o0 = 0;
        for (j = 1; j < m; ++j) {
          for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
          for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
            for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
              s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
            }
            s2 += s3 * data[i][j][1];
          }
          y0[j] = o -= s1 ? s2 / s1 * dx : 0;
          if (o < o0) o0 = o;
        }
        for (j = 0; j < m; ++j) y0[j] -= o0;
        return y0;
      },
      expand: function(data) {
        var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
        for (j = 0; j < m; ++j) {
          for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
          if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
        }
        for (j = 0; j < m; ++j) y0[j] = 0;
        return y0;
      },
      zero: d3_layout_stackOffsetZero
    });
    function d3_layout_stackOrderDefault(data) {
      return d3.range(data.length);
    }
    function d3_layout_stackOffsetZero(data) {
      var j = -1, m = data[0].length, y0 = [];
      while (++j < m) y0[j] = 0;
      return y0;
    }
    function d3_layout_stackMaxIndex(array) {
      var i = 1, j = 0, v = array[0][1], k, n = array.length;
      for (;i < n; ++i) {
        if ((k = array[i][1]) > v) {
          j = i;
          v = k;
        }
      }
      return j;
    }
    function d3_layout_stackReduceSum(d) {
      return d.reduce(d3_layout_stackSum, 0);
    }
    function d3_layout_stackSum(p, d) {
      return p + d[1];
    }
    d3.layout.histogram = function() {
      var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
      function histogram(data, i) {
        var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
        while (++i < m) {
          bin = bins[i] = [];
          bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
          bin.y = 0;
        }
        if (m > 0) {
          i = -1;
          while (++i < n) {
            x = values[i];
            if (x >= range[0] && x <= range[1]) {
              bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
              bin.y += k;
              bin.push(data[i]);
            }
          }
        }
        return bins;
      }
      histogram.value = function(x) {
        if (!arguments.length) return valuer;
        valuer = x;
        return histogram;
      };
      histogram.range = function(x) {
        if (!arguments.length) return ranger;
        ranger = d3_functor(x);
        return histogram;
      };
      histogram.bins = function(x) {
        if (!arguments.length) return binner;
        binner = typeof x === "number" ? function(range) {
          return d3_layout_histogramBinFixed(range, x);
        } : d3_functor(x);
        return histogram;
      };
      histogram.frequency = function(x) {
        if (!arguments.length) return frequency;
        frequency = !!x;
        return histogram;
      };
      return histogram;
    };
    function d3_layout_histogramBinSturges(range, values) {
      return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
    }
    function d3_layout_histogramBinFixed(range, n) {
      var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
      while (++x <= n) f[x] = m * x + b;
      return f;
    }
    function d3_layout_histogramRange(values) {
      return [ d3.min(values), d3.max(values) ];
    }
    d3.layout.pack = function() {
      var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
      function pack(d, i) {
        var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
          return radius;
        };
        root.x = root.y = 0;
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r = +r(d.value);
        });
        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
        if (padding) {
          var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
          d3_layout_hierarchyVisitAfter(root, function(d) {
            d.r += dr;
          });
          d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
          d3_layout_hierarchyVisitAfter(root, function(d) {
            d.r -= dr;
          });
        }
        d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
        return nodes;
      }
      pack.size = function(_) {
        if (!arguments.length) return size;
        size = _;
        return pack;
      };
      pack.radius = function(_) {
        if (!arguments.length) return radius;
        radius = _ == null || typeof _ === "function" ? _ : +_;
        return pack;
      };
      pack.padding = function(_) {
        if (!arguments.length) return padding;
        padding = +_;
        return pack;
      };
      return d3_layout_hierarchyRebind(pack, hierarchy);
    };
    function d3_layout_packSort(a, b) {
      return a.value - b.value;
    }
    function d3_layout_packInsert(a, b) {
      var c = a._pack_next;
      a._pack_next = b;
      b._pack_prev = a;
      b._pack_next = c;
      c._pack_prev = b;
    }
    function d3_layout_packSplice(a, b) {
      a._pack_next = b;
      b._pack_prev = a;
    }
    function d3_layout_packIntersects(a, b) {
      var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
      return .999 * dr * dr > dx * dx + dy * dy;
    }
    function d3_layout_packSiblings(node) {
      if (!(nodes = node.children) || !(n = nodes.length)) return;
      var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
      function bound(node) {
        xMin = Math.min(node.x - node.r, xMin);
        xMax = Math.max(node.x + node.r, xMax);
        yMin = Math.min(node.y - node.r, yMin);
        yMax = Math.max(node.y + node.r, yMax);
      }
      nodes.forEach(d3_layout_packLink);
      a = nodes[0];
      a.x = -a.r;
      a.y = 0;
      bound(a);
      if (n > 1) {
        b = nodes[1];
        b.x = b.r;
        b.y = 0;
        bound(b);
        if (n > 2) {
          c = nodes[2];
          d3_layout_packPlace(a, b, c);
          bound(c);
          d3_layout_packInsert(a, c);
          a._pack_prev = c;
          d3_layout_packInsert(c, b);
          b = a._pack_next;
          for (i = 3; i < n; i++) {
            d3_layout_packPlace(a, b, c = nodes[i]);
            var isect = 0, s1 = 1, s2 = 1;
            for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
              if (d3_layout_packIntersects(j, c)) {
                isect = 1;
                break;
              }
            }
            if (isect == 1) {
              for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
                if (d3_layout_packIntersects(k, c)) {
                  break;
                }
              }
            }
            if (isect) {
              if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
              i--;
            } else {
              d3_layout_packInsert(a, c);
              b = c;
              bound(c);
            }
          }
        }
      }
      var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
      for (i = 0; i < n; i++) {
        c = nodes[i];
        c.x -= cx;
        c.y -= cy;
        cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
      }
      node.r = cr;
      nodes.forEach(d3_layout_packUnlink);
    }
    function d3_layout_packLink(node) {
      node._pack_next = node._pack_prev = node;
    }
    function d3_layout_packUnlink(node) {
      delete node._pack_next;
      delete node._pack_prev;
    }
    function d3_layout_packTransform(node, x, y, k) {
      var children = node.children;
      node.x = x += k * node.x;
      node.y = y += k * node.y;
      node.r *= k;
      if (children) {
        var i = -1, n = children.length;
        while (++i < n) d3_layout_packTransform(children[i], x, y, k);
      }
    }
    function d3_layout_packPlace(a, b, c) {
      var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
      if (db && (dx || dy)) {
        var da = b.r + c.r, dc = dx * dx + dy * dy;
        da *= da;
        db *= db;
        var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
        c.x = a.x + x * dx + y * dy;
        c.y = a.y + x * dy - y * dx;
      } else {
        c.x = a.x + db;
        c.y = a.y;
      }
    }
    d3.layout.tree = function() {
      var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
      function tree(d, i) {
        var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
        d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
        d3_layout_hierarchyVisitBefore(root1, secondWalk);
        if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
          var left = root0, right = root0, bottom = root0;
          d3_layout_hierarchyVisitBefore(root0, function(node) {
            if (node.x < left.x) left = node;
            if (node.x > right.x) right = node;
            if (node.depth > bottom.depth) bottom = node;
          });
          var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
          d3_layout_hierarchyVisitBefore(root0, function(node) {
            node.x = (node.x + tx) * kx;
            node.y = node.depth * ky;
          });
        }
        return nodes;
      }
      function wrapTree(root0) {
        var root1 = {
          A: null,
          children: [ root0 ]
        }, queue = [ root1 ], node1;
        while ((node1 = queue.pop()) != null) {
          for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
            queue.push((children[i] = child = {
              _: children[i],
              parent: node1,
              children: (child = children[i].children) && child.slice() || [],
              A: null,
              a: null,
              z: 0,
              m: 0,
              c: 0,
              s: 0,
              t: null,
              i: i
            }).a = child);
          }
        }
        return root1.children[0];
      }
      function firstWalk(v) {
        var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
        if (children.length) {
          d3_layout_treeShift(v);
          var midpoint = (children[0].z + children[children.length - 1].z) / 2;
          if (w) {
            v.z = w.z + separation(v._, w._);
            v.m = v.z - midpoint;
          } else {
            v.z = midpoint;
          }
        } else if (w) {
          v.z = w.z + separation(v._, w._);
        }
        v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
      }
      function secondWalk(v) {
        v._.x = v.z + v.parent.m;
        v.m += v.parent.m;
      }
      function apportion(v, w, ancestor) {
        if (w) {
          var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
          while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
            vom = d3_layout_treeLeft(vom);
            vop = d3_layout_treeRight(vop);
            vop.a = v;
            shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
            if (shift > 0) {
              d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
              sip += shift;
              sop += shift;
            }
            sim += vim.m;
            sip += vip.m;
            som += vom.m;
            sop += vop.m;
          }
          if (vim && !d3_layout_treeRight(vop)) {
            vop.t = vim;
            vop.m += sim - sop;
          }
          if (vip && !d3_layout_treeLeft(vom)) {
            vom.t = vip;
            vom.m += sip - som;
            ancestor = v;
          }
        }
        return ancestor;
      }
      function sizeNode(node) {
        node.x *= size[0];
        node.y = node.depth * size[1];
      }
      tree.separation = function(x) {
        if (!arguments.length) return separation;
        separation = x;
        return tree;
      };
      tree.size = function(x) {
        if (!arguments.length) return nodeSize ? null : size;
        nodeSize = (size = x) == null ? sizeNode : null;
        return tree;
      };
      tree.nodeSize = function(x) {
        if (!arguments.length) return nodeSize ? size : null;
        nodeSize = (size = x) == null ? null : sizeNode;
        return tree;
      };
      return d3_layout_hierarchyRebind(tree, hierarchy);
    };
    function d3_layout_treeSeparation(a, b) {
      return a.parent == b.parent ? 1 : 2;
    }
    function d3_layout_treeLeft(v) {
      var children = v.children;
      return children.length ? children[0] : v.t;
    }
    function d3_layout_treeRight(v) {
      var children = v.children, n;
      return (n = children.length) ? children[n - 1] : v.t;
    }
    function d3_layout_treeMove(wm, wp, shift) {
      var change = shift / (wp.i - wm.i);
      wp.c -= change;
      wp.s += shift;
      wm.c += change;
      wp.z += shift;
      wp.m += shift;
    }
    function d3_layout_treeShift(v) {
      var shift = 0, change = 0, children = v.children, i = children.length, w;
      while (--i >= 0) {
        w = children[i];
        w.z += shift;
        w.m += shift;
        shift += w.s + (change += w.c);
      }
    }
    function d3_layout_treeAncestor(vim, v, ancestor) {
      return vim.a.parent === v.parent ? vim.a : ancestor;
    }
    d3.layout.cluster = function() {
      var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
      function cluster(d, i) {
        var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
        d3_layout_hierarchyVisitAfter(root, function(node) {
          var children = node.children;
          if (children && children.length) {
            node.x = d3_layout_clusterX(children);
            node.y = d3_layout_clusterY(children);
          } else {
            node.x = previousNode ? x += separation(node, previousNode) : 0;
            node.y = 0;
            previousNode = node;
          }
        });
        var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
        d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
          node.x = (node.x - root.x) * size[0];
          node.y = (root.y - node.y) * size[1];
        } : function(node) {
          node.x = (node.x - x0) / (x1 - x0) * size[0];
          node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
        });
        return nodes;
      }
      cluster.separation = function(x) {
        if (!arguments.length) return separation;
        separation = x;
        return cluster;
      };
      cluster.size = function(x) {
        if (!arguments.length) return nodeSize ? null : size;
        nodeSize = (size = x) == null;
        return cluster;
      };
      cluster.nodeSize = function(x) {
        if (!arguments.length) return nodeSize ? size : null;
        nodeSize = (size = x) != null;
        return cluster;
      };
      return d3_layout_hierarchyRebind(cluster, hierarchy);
    };
    function d3_layout_clusterY(children) {
      return 1 + d3.max(children, function(child) {
        return child.y;
      });
    }
    function d3_layout_clusterX(children) {
      return children.reduce(function(x, child) {
        return x + child.x;
      }, 0) / children.length;
    }
    function d3_layout_clusterLeft(node) {
      var children = node.children;
      return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
    }
    function d3_layout_clusterRight(node) {
      var children = node.children, n;
      return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
    }
    d3.layout.treemap = function() {
      var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
      function scale(children, k) {
        var i = -1, n = children.length, child, area;
        while (++i < n) {
          area = (child = children[i]).value * (k < 0 ? 0 : k);
          child.area = isNaN(area) || area <= 0 ? 0 : area;
        }
      }
      function squarify(node) {
        var children = node.children;
        if (children && children.length) {
          var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
          scale(remaining, rect.dx * rect.dy / node.value);
          row.area = 0;
          while ((n = remaining.length) > 0) {
            row.push(child = remaining[n - 1]);
            row.area += child.area;
            if (mode !== "squarify" || (score = worst(row, u)) <= best) {
              remaining.pop();
              best = score;
            } else {
              row.area -= row.pop().area;
              position(row, u, rect, false);
              u = Math.min(rect.dx, rect.dy);
              row.length = row.area = 0;
              best = Infinity;
            }
          }
          if (row.length) {
            position(row, u, rect, true);
            row.length = row.area = 0;
          }
          children.forEach(squarify);
        }
      }
      function stickify(node) {
        var children = node.children;
        if (children && children.length) {
          var rect = pad(node), remaining = children.slice(), child, row = [];
          scale(remaining, rect.dx * rect.dy / node.value);
          row.area = 0;
          while (child = remaining.pop()) {
            row.push(child);
            row.area += child.area;
            if (child.z != null) {
              position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
              row.length = row.area = 0;
            }
          }
          children.forEach(stickify);
        }
      }
      function worst(row, u) {
        var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
        while (++i < n) {
          if (!(r = row[i].area)) continue;
          if (r < rmin) rmin = r;
          if (r > rmax) rmax = r;
        }
        s *= s;
        u *= u;
        return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
      }
      function position(row, u, rect, flush) {
        var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
        if (u == rect.dx) {
          if (flush || v > rect.dy) v = rect.dy;
          while (++i < n) {
            o = row[i];
            o.x = x;
            o.y = y;
            o.dy = v;
            x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
          }
          o.z = true;
          o.dx += rect.x + rect.dx - x;
          rect.y += v;
          rect.dy -= v;
        } else {
          if (flush || v > rect.dx) v = rect.dx;
          while (++i < n) {
            o = row[i];
            o.x = x;
            o.y = y;
            o.dx = v;
            y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
          }
          o.z = false;
          o.dy += rect.y + rect.dy - y;
          rect.x += v;
          rect.dx -= v;
        }
      }
      function treemap(d) {
        var nodes = stickies || hierarchy(d), root = nodes[0];
        root.x = 0;
        root.y = 0;
        root.dx = size[0];
        root.dy = size[1];
        if (stickies) hierarchy.revalue(root);
        scale([ root ], root.dx * root.dy / root.value);
        (stickies ? stickify : squarify)(root);
        if (sticky) stickies = nodes;
        return nodes;
      }
      treemap.size = function(x) {
        if (!arguments.length) return size;
        size = x;
        return treemap;
      };
      treemap.padding = function(x) {
        if (!arguments.length) return padding;
        function padFunction(node) {
          var p = x.call(treemap, node, node.depth);
          return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
        }
        function padConstant(node) {
          return d3_layout_treemapPad(node, x);
        }
        var type;
        pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
        padConstant) : padConstant;
        return treemap;
      };
      treemap.round = function(x) {
        if (!arguments.length) return round != Number;
        round = x ? Math.round : Number;
        return treemap;
      };
      treemap.sticky = function(x) {
        if (!arguments.length) return sticky;
        sticky = x;
        stickies = null;
        return treemap;
      };
      treemap.ratio = function(x) {
        if (!arguments.length) return ratio;
        ratio = x;
        return treemap;
      };
      treemap.mode = function(x) {
        if (!arguments.length) return mode;
        mode = x + "";
        return treemap;
      };
      return d3_layout_hierarchyRebind(treemap, hierarchy);
    };
    function d3_layout_treemapPadNull(node) {
      return {
        x: node.x,
        y: node.y,
        dx: node.dx,
        dy: node.dy
      };
    }
    function d3_layout_treemapPad(node, padding) {
      var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
      if (dx < 0) {
        x += dx / 2;
        dx = 0;
      }
      if (dy < 0) {
        y += dy / 2;
        dy = 0;
      }
      return {
        x: x,
        y: y,
        dx: dx,
        dy: dy
      };
    }
    d3.random = {
      normal: function(µ, σ) {
        var n = arguments.length;
        if (n < 2) σ = 1;
        if (n < 1) µ = 0;
        return function() {
          var x, y, r;
          do {
            x = Math.random() * 2 - 1;
            y = Math.random() * 2 - 1;
            r = x * x + y * y;
          } while (!r || r > 1);
          return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
        };
      },
      logNormal: function() {
        var random = d3.random.normal.apply(d3, arguments);
        return function() {
          return Math.exp(random());
        };
      },
      bates: function(m) {
        var random = d3.random.irwinHall(m);
        return function() {
          return random() / m;
        };
      },
      irwinHall: function(m) {
        return function() {
          for (var s = 0, j = 0; j < m; j++) s += Math.random();
          return s;
        };
      }
    };
    d3.scale = {};
    function d3_scaleExtent(domain) {
      var start = domain[0], stop = domain[domain.length - 1];
      return start < stop ? [ start, stop ] : [ stop, start ];
    }
    function d3_scaleRange(scale) {
      return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
    }
    function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
      var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
      return function(x) {
        return i(u(x));
      };
    }
    function d3_scale_nice(domain, nice) {
      var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
      if (x1 < x0) {
        dx = i0, i0 = i1, i1 = dx;
        dx = x0, x0 = x1, x1 = dx;
      }
      domain[i0] = nice.floor(x0);
      domain[i1] = nice.ceil(x1);
      return domain;
    }
    function d3_scale_niceStep(step) {
      return step ? {
        floor: function(x) {
          return Math.floor(x / step) * step;
        },
        ceil: function(x) {
          return Math.ceil(x / step) * step;
        }
      } : d3_scale_niceIdentity;
    }
    var d3_scale_niceIdentity = {
      floor: d3_identity,
      ceil: d3_identity
    };
    function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
      var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
      if (domain[k] < domain[0]) {
        domain = domain.slice().reverse();
        range = range.slice().reverse();
      }
      while (++j <= k) {
        u.push(uninterpolate(domain[j - 1], domain[j]));
        i.push(interpolate(range[j - 1], range[j]));
      }
      return function(x) {
        var j = d3.bisect(domain, x, 1, k) - 1;
        return i[j](u[j](x));
      };
    }
    d3.scale.linear = function() {
      return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
    };
    function d3_scale_linear(domain, range, interpolate, clamp) {
      var output, input;
      function rescale() {
        var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
        output = linear(domain, range, uninterpolate, interpolate);
        input = linear(range, domain, uninterpolate, d3_interpolate);
        return scale;
      }
      function scale(x) {
        return output(x);
      }
      scale.invert = function(y) {
        return input(y);
      };
      scale.domain = function(x) {
        if (!arguments.length) return domain;
        domain = x.map(Number);
        return rescale();
      };
      scale.range = function(x) {
        if (!arguments.length) return range;
        range = x;
        return rescale();
      };
      scale.rangeRound = function(x) {
        return scale.range(x).interpolate(d3_interpolateRound);
      };
      scale.clamp = function(x) {
        if (!arguments.length) return clamp;
        clamp = x;
        return rescale();
      };
      scale.interpolate = function(x) {
        if (!arguments.length) return interpolate;
        interpolate = x;
        return rescale();
      };
      scale.ticks = function(m) {
        return d3_scale_linearTicks(domain, m);
      };
      scale.tickFormat = function(m, format) {
        return d3_scale_linearTickFormat(domain, m, format);
      };
      scale.nice = function(m) {
        d3_scale_linearNice(domain, m);
        return rescale();
      };
      scale.copy = function() {
        return d3_scale_linear(domain, range, interpolate, clamp);
      };
      return rescale();
    }
    function d3_scale_linearRebind(scale, linear) {
      return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
    }
    function d3_scale_linearNice(domain, m) {
      return d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
    }
    function d3_scale_linearTickRange(domain, m) {
      if (m == null) m = 10;
      var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
      if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
      extent[0] = Math.ceil(extent[0] / step) * step;
      extent[1] = Math.floor(extent[1] / step) * step + step * .5;
      extent[2] = step;
      return extent;
    }
    function d3_scale_linearTicks(domain, m) {
      return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
    }
    function d3_scale_linearTickFormat(domain, m, format) {
      var range = d3_scale_linearTickRange(domain, m);
      if (format) {
        var match = d3_format_re.exec(format);
        match.shift();
        if (match[8] === "s") {
          var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
          if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
          match[8] = "f";
          format = d3.format(match.join(""));
          return function(d) {
            return format(prefix.scale(d)) + prefix.symbol;
          };
        }
        if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
        format = match.join("");
      } else {
        format = ",." + d3_scale_linearPrecision(range[2]) + "f";
      }
      return d3.format(format);
    }
    var d3_scale_linearFormatSignificant = {
      s: 1,
      g: 1,
      p: 1,
      r: 1,
      e: 1
    };
    function d3_scale_linearPrecision(value) {
      return -Math.floor(Math.log(value) / Math.LN10 + .01);
    }
    function d3_scale_linearFormatPrecision(type, range) {
      var p = d3_scale_linearPrecision(range[2]);
      return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
    }
    d3.scale.log = function() {
      return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
    };
    function d3_scale_log(linear, base, positive, domain) {
      function log(x) {
        return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
      }
      function pow(x) {
        return positive ? Math.pow(base, x) : -Math.pow(base, -x);
      }
      function scale(x) {
        return linear(log(x));
      }
      scale.invert = function(x) {
        return pow(linear.invert(x));
      };
      scale.domain = function(x) {
        if (!arguments.length) return domain;
        positive = x[0] >= 0;
        linear.domain((domain = x.map(Number)).map(log));
        return scale;
      };
      scale.base = function(_) {
        if (!arguments.length) return base;
        base = +_;
        linear.domain(domain.map(log));
        return scale;
      };
      scale.nice = function() {
        var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
        linear.domain(niced);
        domain = niced.map(pow);
        return scale;
      };
      scale.ticks = function() {
        var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
        if (isFinite(j - i)) {
          if (positive) {
            for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
            ticks.push(pow(i));
          } else {
            ticks.push(pow(i));
            for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
          }
          for (i = 0; ticks[i] < u; i++) {}
          for (j = ticks.length; ticks[j - 1] > v; j--) {}
          ticks = ticks.slice(i, j);
        }
        return ticks;
      };
      scale.tickFormat = function(n, format) {
        if (!arguments.length) return d3_scale_logFormat;
        if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
        var k = Math.max(.1, n / scale.ticks().length), f = positive ? (e = 1e-12, Math.ceil) : (e = -1e-12, 
        Math.floor), e;
        return function(d) {
          return d / pow(f(log(d) + e)) <= k ? format(d) : "";
        };
      };
      scale.copy = function() {
        return d3_scale_log(linear.copy(), base, positive, domain);
      };
      return d3_scale_linearRebind(scale, linear);
    }
    var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
      floor: function(x) {
        return -Math.ceil(-x);
      },
      ceil: function(x) {
        return -Math.floor(-x);
      }
    };
    d3.scale.pow = function() {
      return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
    };
    function d3_scale_pow(linear, exponent, domain) {
      var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
      function scale(x) {
        return linear(powp(x));
      }
      scale.invert = function(x) {
        return powb(linear.invert(x));
      };
      scale.domain = function(x) {
        if (!arguments.length) return domain;
        linear.domain((domain = x.map(Number)).map(powp));
        return scale;
      };
      scale.ticks = function(m) {
        return d3_scale_linearTicks(domain, m);
      };
      scale.tickFormat = function(m, format) {
        return d3_scale_linearTickFormat(domain, m, format);
      };
      scale.nice = function(m) {
        return scale.domain(d3_scale_linearNice(domain, m));
      };
      scale.exponent = function(x) {
        if (!arguments.length) return exponent;
        powp = d3_scale_powPow(exponent = x);
        powb = d3_scale_powPow(1 / exponent);
        linear.domain(domain.map(powp));
        return scale;
      };
      scale.copy = function() {
        return d3_scale_pow(linear.copy(), exponent, domain);
      };
      return d3_scale_linearRebind(scale, linear);
    }
    function d3_scale_powPow(e) {
      return function(x) {
        return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
      };
    }
    d3.scale.sqrt = function() {
      return d3.scale.pow().exponent(.5);
    };
    d3.scale.ordinal = function() {
      return d3_scale_ordinal([], {
        t: "range",
        a: [ [] ]
      });
    };
    function d3_scale_ordinal(domain, ranger) {
      var index, range, rangeBand;
      function scale(x) {
        return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
      }
      function steps(start, step) {
        return d3.range(domain.length).map(function(i) {
          return start + step * i;
        });
      }
      scale.domain = function(x) {
        if (!arguments.length) return domain;
        domain = [];
        index = new d3_Map();
        var i = -1, n = x.length, xi;
        while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
        return scale[ranger.t].apply(scale, ranger.a);
      };
      scale.range = function(x) {
        if (!arguments.length) return range;
        range = x;
        rangeBand = 0;
        ranger = {
          t: "range",
          a: arguments
        };
        return scale;
      };
      scale.rangePoints = function(x, padding) {
        if (arguments.length < 2) padding = 0;
        var start = x[0], stop = x[1], step = (stop - start) / (Math.max(1, domain.length - 1) + padding);
        range = steps(domain.length < 2 ? (start + stop) / 2 : start + step * padding / 2, step);
        rangeBand = 0;
        ranger = {
          t: "rangePoints",
          a: arguments
        };
        return scale;
      };
      scale.rangeBands = function(x, padding, outerPadding) {
        if (arguments.length < 2) padding = 0;
        if (arguments.length < 3) outerPadding = padding;
        var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
        range = steps(start + step * outerPadding, step);
        if (reverse) range.reverse();
        rangeBand = step * (1 - padding);
        ranger = {
          t: "rangeBands",
          a: arguments
        };
        return scale;
      };
      scale.rangeRoundBands = function(x, padding, outerPadding) {
        if (arguments.length < 2) padding = 0;
        if (arguments.length < 3) outerPadding = padding;
        var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding)), error = stop - start - (domain.length - padding) * step;
        range = steps(start + Math.round(error / 2), step);
        if (reverse) range.reverse();
        rangeBand = Math.round(step * (1 - padding));
        ranger = {
          t: "rangeRoundBands",
          a: arguments
        };
        return scale;
      };
      scale.rangeBand = function() {
        return rangeBand;
      };
      scale.rangeExtent = function() {
        return d3_scaleExtent(ranger.a[0]);
      };
      scale.copy = function() {
        return d3_scale_ordinal(domain, ranger);
      };
      return scale.domain(domain);
    }
    d3.scale.category10 = function() {
      return d3.scale.ordinal().range(d3_category10);
    };
    d3.scale.category20 = function() {
      return d3.scale.ordinal().range(d3_category20);
    };
    d3.scale.category20b = function() {
      return d3.scale.ordinal().range(d3_category20b);
    };
    d3.scale.category20c = function() {
      return d3.scale.ordinal().range(d3_category20c);
    };
    var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
    var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
    var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
    var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
    d3.scale.quantile = function() {
      return d3_scale_quantile([], []);
    };
    function d3_scale_quantile(domain, range) {
      var thresholds;
      function rescale() {
        var k = 0, q = range.length;
        thresholds = [];
        while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
        return scale;
      }
      function scale(x) {
        if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
      }
      scale.domain = function(x) {
        if (!arguments.length) return domain;
        domain = x.filter(d3_number).sort(d3_ascending);
        return rescale();
      };
      scale.range = function(x) {
        if (!arguments.length) return range;
        range = x;
        return rescale();
      };
      scale.quantiles = function() {
        return thresholds;
      };
      scale.invertExtent = function(y) {
        y = range.indexOf(y);
        return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
      };
      scale.copy = function() {
        return d3_scale_quantile(domain, range);
      };
      return rescale();
    }
    d3.scale.quantize = function() {
      return d3_scale_quantize(0, 1, [ 0, 1 ]);
    };
    function d3_scale_quantize(x0, x1, range) {
      var kx, i;
      function scale(x) {
        return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
      }
      function rescale() {
        kx = range.length / (x1 - x0);
        i = range.length - 1;
        return scale;
      }
      scale.domain = function(x) {
        if (!arguments.length) return [ x0, x1 ];
        x0 = +x[0];
        x1 = +x[x.length - 1];
        return rescale();
      };
      scale.range = function(x) {
        if (!arguments.length) return range;
        range = x;
        return rescale();
      };
      scale.invertExtent = function(y) {
        y = range.indexOf(y);
        y = y < 0 ? NaN : y / kx + x0;
        return [ y, y + 1 / kx ];
      };
      scale.copy = function() {
        return d3_scale_quantize(x0, x1, range);
      };
      return rescale();
    }
    d3.scale.threshold = function() {
      return d3_scale_threshold([ .5 ], [ 0, 1 ]);
    };
    function d3_scale_threshold(domain, range) {
      function scale(x) {
        if (x <= x) return range[d3.bisect(domain, x)];
      }
      scale.domain = function(_) {
        if (!arguments.length) return domain;
        domain = _;
        return scale;
      };
      scale.range = function(_) {
        if (!arguments.length) return range;
        range = _;
        return scale;
      };
      scale.invertExtent = function(y) {
        y = range.indexOf(y);
        return [ domain[y - 1], domain[y] ];
      };
      scale.copy = function() {
        return d3_scale_threshold(domain, range);
      };
      return scale;
    }
    d3.scale.identity = function() {
      return d3_scale_identity([ 0, 1 ]);
    };
    function d3_scale_identity(domain) {
      function identity(x) {
        return +x;
      }
      identity.invert = identity;
      identity.domain = identity.range = function(x) {
        if (!arguments.length) return domain;
        domain = x.map(identity);
        return identity;
      };
      identity.ticks = function(m) {
        return d3_scale_linearTicks(domain, m);
      };
      identity.tickFormat = function(m, format) {
        return d3_scale_linearTickFormat(domain, m, format);
      };
      identity.copy = function() {
        return d3_scale_identity(domain);
      };
      return identity;
    }
    d3.svg = {};
    d3.svg.arc = function() {
      var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
      function arc() {
        var r0 = innerRadius.apply(this, arguments), r1 = outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) + d3_svg_arcOffset, a1 = endAngle.apply(this, arguments) + d3_svg_arcOffset, da = (a1 < a0 && (da = a0, 
        a0 = a1, a1 = da), a1 - a0), df = da < π ? "0" : "1", c0 = Math.cos(a0), s0 = Math.sin(a0), c1 = Math.cos(a1), s1 = Math.sin(a1);
        return da >= d3_svg_arcMax ? r0 ? "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "M0," + r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + -r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + r0 + "Z" : "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "Z" : r0 ? "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L" + r0 * c1 + "," + r0 * s1 + "A" + r0 + "," + r0 + " 0 " + df + ",0 " + r0 * c0 + "," + r0 * s0 + "Z" : "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L0,0" + "Z";
      }
      arc.innerRadius = function(v) {
        if (!arguments.length) return innerRadius;
        innerRadius = d3_functor(v);
        return arc;
      };
      arc.outerRadius = function(v) {
        if (!arguments.length) return outerRadius;
        outerRadius = d3_functor(v);
        return arc;
      };
      arc.startAngle = function(v) {
        if (!arguments.length) return startAngle;
        startAngle = d3_functor(v);
        return arc;
      };
      arc.endAngle = function(v) {
        if (!arguments.length) return endAngle;
        endAngle = d3_functor(v);
        return arc;
      };
      arc.centroid = function() {
        var r = (innerRadius.apply(this, arguments) + outerRadius.apply(this, arguments)) / 2, a = (startAngle.apply(this, arguments) + endAngle.apply(this, arguments)) / 2 + d3_svg_arcOffset;
        return [ Math.cos(a) * r, Math.sin(a) * r ];
      };
      return arc;
    };
    var d3_svg_arcOffset = -halfπ, d3_svg_arcMax = τ - ε;
    function d3_svg_arcInnerRadius(d) {
      return d.innerRadius;
    }
    function d3_svg_arcOuterRadius(d) {
      return d.outerRadius;
    }
    function d3_svg_arcStartAngle(d) {
      return d.startAngle;
    }
    function d3_svg_arcEndAngle(d) {
      return d.endAngle;
    }
    function d3_svg_line(projection) {
      var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
      function line(data) {
        var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
        function segment() {
          segments.push("M", interpolate(projection(points), tension));
        }
        while (++i < n) {
          if (defined.call(this, d = data[i], i)) {
            points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
          } else if (points.length) {
            segment();
            points = [];
          }
        }
        if (points.length) segment();
        return segments.length ? segments.join("") : null;
      }
      line.x = function(_) {
        if (!arguments.length) return x;
        x = _;
        return line;
      };
      line.y = function(_) {
        if (!arguments.length) return y;
        y = _;
        return line;
      };
      line.defined = function(_) {
        if (!arguments.length) return defined;
        defined = _;
        return line;
      };
      line.interpolate = function(_) {
        if (!arguments.length) return interpolateKey;
        if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
        return line;
      };
      line.tension = function(_) {
        if (!arguments.length) return tension;
        tension = _;
        return line;
      };
      return line;
    }
    d3.svg.line = function() {
      return d3_svg_line(d3_identity);
    };
    var d3_svg_lineInterpolators = d3.map({
      linear: d3_svg_lineLinear,
      "linear-closed": d3_svg_lineLinearClosed,
      step: d3_svg_lineStep,
      "step-before": d3_svg_lineStepBefore,
      "step-after": d3_svg_lineStepAfter,
      basis: d3_svg_lineBasis,
      "basis-open": d3_svg_lineBasisOpen,
      "basis-closed": d3_svg_lineBasisClosed,
      bundle: d3_svg_lineBundle,
      cardinal: d3_svg_lineCardinal,
      "cardinal-open": d3_svg_lineCardinalOpen,
      "cardinal-closed": d3_svg_lineCardinalClosed,
      monotone: d3_svg_lineMonotone
    });
    d3_svg_lineInterpolators.forEach(function(key, value) {
      value.key = key;
      value.closed = /-closed$/.test(key);
    });
    function d3_svg_lineLinear(points) {
      return points.join("L");
    }
    function d3_svg_lineLinearClosed(points) {
      return d3_svg_lineLinear(points) + "Z";
    }
    function d3_svg_lineStep(points) {
      var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
      while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
      if (n > 1) path.push("H", p[0]);
      return path.join("");
    }
    function d3_svg_lineStepBefore(points) {
      var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
      while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
      return path.join("");
    }
    function d3_svg_lineStepAfter(points) {
      var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
      while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
      return path.join("");
    }
    function d3_svg_lineCardinalOpen(points, tension) {
      return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, points.length - 1), d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineCardinalClosed(points, tension) {
      return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
      points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
    }
    function d3_svg_lineCardinal(points, tension) {
      return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineHermite(points, tangents) {
      if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
        return d3_svg_lineLinear(points);
      }
      var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
      if (quad) {
        path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
        p0 = points[1];
        pi = 2;
      }
      if (tangents.length > 1) {
        t = tangents[1];
        p = points[pi];
        pi++;
        path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
        for (var i = 2; i < tangents.length; i++, pi++) {
          p = points[pi];
          t = tangents[i];
          path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
        }
      }
      if (quad) {
        var lp = points[pi];
        path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
      }
      return path;
    }
    function d3_svg_lineCardinalTangents(points, tension) {
      var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
      while (++i < n) {
        p0 = p1;
        p1 = p2;
        p2 = points[i];
        tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
      }
      return tangents;
    }
    function d3_svg_lineBasis(points) {
      if (points.length < 3) return d3_svg_lineLinear(points);
      var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
      points.push(points[n - 1]);
      while (++i <= n) {
        pi = points[i];
        px.shift();
        px.push(pi[0]);
        py.shift();
        py.push(pi[1]);
        d3_svg_lineBasisBezier(path, px, py);
      }
      points.pop();
      path.push("L", pi);
      return path.join("");
    }
    function d3_svg_lineBasisOpen(points) {
      if (points.length < 4) return d3_svg_lineLinear(points);
      var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
      while (++i < 3) {
        pi = points[i];
        px.push(pi[0]);
        py.push(pi[1]);
      }
      path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
      --i;
      while (++i < n) {
        pi = points[i];
        px.shift();
        px.push(pi[0]);
        py.shift();
        py.push(pi[1]);
        d3_svg_lineBasisBezier(path, px, py);
      }
      return path.join("");
    }
    function d3_svg_lineBasisClosed(points) {
      var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
      while (++i < 4) {
        pi = points[i % n];
        px.push(pi[0]);
        py.push(pi[1]);
      }
      path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
      --i;
      while (++i < m) {
        pi = points[i % n];
        px.shift();
        px.push(pi[0]);
        py.shift();
        py.push(pi[1]);
        d3_svg_lineBasisBezier(path, px, py);
      }
      return path.join("");
    }
    function d3_svg_lineBundle(points, tension) {
      var n = points.length - 1;
      if (n) {
        var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
        while (++i <= n) {
          p = points[i];
          t = i / n;
          p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
          p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
        }
      }
      return d3_svg_lineBasis(points);
    }
    function d3_svg_lineDot4(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
    }
    var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
    function d3_svg_lineBasisBezier(path, x, y) {
      path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
    }
    function d3_svg_lineSlope(p0, p1) {
      return (p1[1] - p0[1]) / (p1[0] - p0[0]);
    }
    function d3_svg_lineFiniteDifferences(points) {
      var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
      while (++i < j) {
        m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
      }
      m[i] = d;
      return m;
    }
    function d3_svg_lineMonotoneTangents(points) {
      var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
      while (++i < j) {
        d = d3_svg_lineSlope(points[i], points[i + 1]);
        if (abs(d) < ε) {
          m[i] = m[i + 1] = 0;
        } else {
          a = m[i] / d;
          b = m[i + 1] / d;
          s = a * a + b * b;
          if (s > 9) {
            s = d * 3 / Math.sqrt(s);
            m[i] = s * a;
            m[i + 1] = s * b;
          }
        }
      }
      i = -1;
      while (++i <= j) {
        s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
        tangents.push([ s || 0, m[i] * s || 0 ]);
      }
      return tangents;
    }
    function d3_svg_lineMonotone(points) {
      return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
    }
    d3.svg.line.radial = function() {
      var line = d3_svg_line(d3_svg_lineRadial);
      line.radius = line.x, delete line.x;
      line.angle = line.y, delete line.y;
      return line;
    };
    function d3_svg_lineRadial(points) {
      var point, i = -1, n = points.length, r, a;
      while (++i < n) {
        point = points[i];
        r = point[0];
        a = point[1] + d3_svg_arcOffset;
        point[0] = r * Math.cos(a);
        point[1] = r * Math.sin(a);
      }
      return points;
    }
    function d3_svg_area(projection) {
      var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
      function area(data) {
        var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
          return x;
        } : d3_functor(x1), fy1 = y0 === y1 ? function() {
          return y;
        } : d3_functor(y1), x, y;
        function segment() {
          segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
        }
        while (++i < n) {
          if (defined.call(this, d = data[i], i)) {
            points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
            points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
          } else if (points0.length) {
            segment();
            points0 = [];
            points1 = [];
          }
        }
        if (points0.length) segment();
        return segments.length ? segments.join("") : null;
      }
      area.x = function(_) {
        if (!arguments.length) return x1;
        x0 = x1 = _;
        return area;
      };
      area.x0 = function(_) {
        if (!arguments.length) return x0;
        x0 = _;
        return area;
      };
      area.x1 = function(_) {
        if (!arguments.length) return x1;
        x1 = _;
        return area;
      };
      area.y = function(_) {
        if (!arguments.length) return y1;
        y0 = y1 = _;
        return area;
      };
      area.y0 = function(_) {
        if (!arguments.length) return y0;
        y0 = _;
        return area;
      };
      area.y1 = function(_) {
        if (!arguments.length) return y1;
        y1 = _;
        return area;
      };
      area.defined = function(_) {
        if (!arguments.length) return defined;
        defined = _;
        return area;
      };
      area.interpolate = function(_) {
        if (!arguments.length) return interpolateKey;
        if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
        interpolateReverse = interpolate.reverse || interpolate;
        L = interpolate.closed ? "M" : "L";
        return area;
      };
      area.tension = function(_) {
        if (!arguments.length) return tension;
        tension = _;
        return area;
      };
      return area;
    }
    d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
    d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
    d3.svg.area = function() {
      return d3_svg_area(d3_identity);
    };
    d3.svg.area.radial = function() {
      var area = d3_svg_area(d3_svg_lineRadial);
      area.radius = area.x, delete area.x;
      area.innerRadius = area.x0, delete area.x0;
      area.outerRadius = area.x1, delete area.x1;
      area.angle = area.y, delete area.y;
      area.startAngle = area.y0, delete area.y0;
      area.endAngle = area.y1, delete area.y1;
      return area;
    };
    d3.svg.chord = function() {
      var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
      function chord(d, i) {
        var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
        return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
      }
      function subgroup(self, f, d, i) {
        var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) + d3_svg_arcOffset, a1 = endAngle.call(self, subgroup, i) + d3_svg_arcOffset;
        return {
          r: r,
          a0: a0,
          a1: a1,
          p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
          p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
        };
      }
      function equals(a, b) {
        return a.a0 == b.a0 && a.a1 == b.a1;
      }
      function arc(r, p, a) {
        return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
      }
      function curve(r0, p0, r1, p1) {
        return "Q 0,0 " + p1;
      }
      chord.radius = function(v) {
        if (!arguments.length) return radius;
        radius = d3_functor(v);
        return chord;
      };
      chord.source = function(v) {
        if (!arguments.length) return source;
        source = d3_functor(v);
        return chord;
      };
      chord.target = function(v) {
        if (!arguments.length) return target;
        target = d3_functor(v);
        return chord;
      };
      chord.startAngle = function(v) {
        if (!arguments.length) return startAngle;
        startAngle = d3_functor(v);
        return chord;
      };
      chord.endAngle = function(v) {
        if (!arguments.length) return endAngle;
        endAngle = d3_functor(v);
        return chord;
      };
      return chord;
    };
    function d3_svg_chordRadius(d) {
      return d.radius;
    }
    d3.svg.diagonal = function() {
      var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
      function diagonal(d, i) {
        var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
          x: p0.x,
          y: m
        }, {
          x: p3.x,
          y: m
        }, p3 ];
        p = p.map(projection);
        return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
      }
      diagonal.source = function(x) {
        if (!arguments.length) return source;
        source = d3_functor(x);
        return diagonal;
      };
      diagonal.target = function(x) {
        if (!arguments.length) return target;
        target = d3_functor(x);
        return diagonal;
      };
      diagonal.projection = function(x) {
        if (!arguments.length) return projection;
        projection = x;
        return diagonal;
      };
      return diagonal;
    };
    function d3_svg_diagonalProjection(d) {
      return [ d.x, d.y ];
    }
    d3.svg.diagonal.radial = function() {
      var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
      diagonal.projection = function(x) {
        return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
      };
      return diagonal;
    };
    function d3_svg_diagonalRadialProjection(projection) {
      return function() {
        var d = projection.apply(this, arguments), r = d[0], a = d[1] + d3_svg_arcOffset;
        return [ r * Math.cos(a), r * Math.sin(a) ];
      };
    }
    d3.svg.symbol = function() {
      var type = d3_svg_symbolType, size = d3_svg_symbolSize;
      function symbol(d, i) {
        return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
      }
      symbol.type = function(x) {
        if (!arguments.length) return type;
        type = d3_functor(x);
        return symbol;
      };
      symbol.size = function(x) {
        if (!arguments.length) return size;
        size = d3_functor(x);
        return symbol;
      };
      return symbol;
    };
    function d3_svg_symbolSize() {
      return 64;
    }
    function d3_svg_symbolType() {
      return "circle";
    }
    function d3_svg_symbolCircle(size) {
      var r = Math.sqrt(size / π);
      return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
    }
    var d3_svg_symbols = d3.map({
      circle: d3_svg_symbolCircle,
      cross: function(size) {
        var r = Math.sqrt(size / 5) / 2;
        return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
      },
      diamond: function(size) {
        var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
        return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
      },
      square: function(size) {
        var r = Math.sqrt(size) / 2;
        return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
      },
      "triangle-down": function(size) {
        var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
        return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
      },
      "triangle-up": function(size) {
        var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
        return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
      }
    });
    d3.svg.symbolTypes = d3_svg_symbols.keys();
    var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
    function d3_transition(groups, id) {
      d3_subclass(groups, d3_transitionPrototype);
      groups.id = id;
      return groups;
    }
    var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
    d3_transitionPrototype.call = d3_selectionPrototype.call;
    d3_transitionPrototype.empty = d3_selectionPrototype.empty;
    d3_transitionPrototype.node = d3_selectionPrototype.node;
    d3_transitionPrototype.size = d3_selectionPrototype.size;
    d3.transition = function(selection) {
      return arguments.length ? d3_transitionInheritId ? selection.transition() : selection : d3_selectionRoot.transition();
    };
    d3.transition.prototype = d3_transitionPrototype;
    d3_transitionPrototype.select = function(selector) {
      var id = this.id, subgroups = [], subgroup, subnode, node;
      selector = d3_selection_selector(selector);
      for (var j = -1, m = this.length; ++j < m; ) {
        subgroups.push(subgroup = []);
        for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
          if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            d3_transitionNode(subnode, i, id, node.__transition__[id]);
            subgroup.push(subnode);
          } else {
            subgroup.push(null);
          }
        }
      }
      return d3_transition(subgroups, id);
    };
    d3_transitionPrototype.selectAll = function(selector) {
      var id = this.id, subgroups = [], subgroup, subnodes, node, subnode, transition;
      selector = d3_selection_selectorAll(selector);
      for (var j = -1, m = this.length; ++j < m; ) {
        for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
          if (node = group[i]) {
            transition = node.__transition__[id];
            subnodes = selector.call(node, node.__data__, i, j);
            subgroups.push(subgroup = []);
            for (var k = -1, o = subnodes.length; ++k < o; ) {
              if (subnode = subnodes[k]) d3_transitionNode(subnode, k, id, transition);
              subgroup.push(subnode);
            }
          }
        }
      }
      return d3_transition(subgroups, id);
    };
    d3_transitionPrototype.filter = function(filter) {
      var subgroups = [], subgroup, group, node;
      if (typeof filter !== "function") filter = d3_selection_filter(filter);
      for (var j = 0, m = this.length; j < m; j++) {
        subgroups.push(subgroup = []);
        for (var group = this[j], i = 0, n = group.length; i < n; i++) {
          if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
            subgroup.push(node);
          }
        }
      }
      return d3_transition(subgroups, this.id);
    };
    d3_transitionPrototype.tween = function(name, tween) {
      var id = this.id;
      if (arguments.length < 2) return this.node().__transition__[id].tween.get(name);
      return d3_selection_each(this, tween == null ? function(node) {
        node.__transition__[id].tween.remove(name);
      } : function(node) {
        node.__transition__[id].tween.set(name, tween);
      });
    };
    function d3_transition_tween(groups, name, value, tween) {
      var id = groups.id;
      return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
        node.__transition__[id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
      } : (value = tween(value), function(node) {
        node.__transition__[id].tween.set(name, value);
      }));
    }
    d3_transitionPrototype.attr = function(nameNS, value) {
      if (arguments.length < 2) {
        for (value in nameNS) this.attr(value, nameNS[value]);
        return this;
      }
      var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
      function attrNull() {
        this.removeAttribute(name);
      }
      function attrNullNS() {
        this.removeAttributeNS(name.space, name.local);
      }
      function attrTween(b) {
        return b == null ? attrNull : (b += "", function() {
          var a = this.getAttribute(name), i;
          return a !== b && (i = interpolate(a, b), function(t) {
            this.setAttribute(name, i(t));
          });
        });
      }
      function attrTweenNS(b) {
        return b == null ? attrNullNS : (b += "", function() {
          var a = this.getAttributeNS(name.space, name.local), i;
          return a !== b && (i = interpolate(a, b), function(t) {
            this.setAttributeNS(name.space, name.local, i(t));
          });
        });
      }
      return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
    };
    d3_transitionPrototype.attrTween = function(nameNS, tween) {
      var name = d3.ns.qualify(nameNS);
      function attrTween(d, i) {
        var f = tween.call(this, d, i, this.getAttribute(name));
        return f && function(t) {
          this.setAttribute(name, f(t));
        };
      }
      function attrTweenNS(d, i) {
        var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
        return f && function(t) {
          this.setAttributeNS(name.space, name.local, f(t));
        };
      }
      return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
    };
    d3_transitionPrototype.style = function(name, value, priority) {
      var n = arguments.length;
      if (n < 3) {
        if (typeof name !== "string") {
          if (n < 2) value = "";
          for (priority in name) this.style(priority, name[priority], value);
          return this;
        }
        priority = "";
      }
      function styleNull() {
        this.style.removeProperty(name);
      }
      function styleString(b) {
        return b == null ? styleNull : (b += "", function() {
          var a = d3_window.getComputedStyle(this, null).getPropertyValue(name), i;
          return a !== b && (i = d3_interpolate(a, b), function(t) {
            this.style.setProperty(name, i(t), priority);
          });
        });
      }
      return d3_transition_tween(this, "style." + name, value, styleString);
    };
    d3_transitionPrototype.styleTween = function(name, tween, priority) {
      if (arguments.length < 3) priority = "";
      function styleTween(d, i) {
        var f = tween.call(this, d, i, d3_window.getComputedStyle(this, null).getPropertyValue(name));
        return f && function(t) {
          this.style.setProperty(name, f(t), priority);
        };
      }
      return this.tween("style." + name, styleTween);
    };
    d3_transitionPrototype.text = function(value) {
      return d3_transition_tween(this, "text", value, d3_transition_text);
    };
    function d3_transition_text(b) {
      if (b == null) b = "";
      return function() {
        this.textContent = b;
      };
    }
    d3_transitionPrototype.remove = function() {
      return this.each("end.transition", function() {
        var p;
        if (this.__transition__.count < 2 && (p = this.parentNode)) p.removeChild(this);
      });
    };
    d3_transitionPrototype.ease = function(value) {
      var id = this.id;
      if (arguments.length < 1) return this.node().__transition__[id].ease;
      if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
      return d3_selection_each(this, function(node) {
        node.__transition__[id].ease = value;
      });
    };
    d3_transitionPrototype.delay = function(value) {
      var id = this.id;
      if (arguments.length < 1) return this.node().__transition__[id].delay;
      return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
        node.__transition__[id].delay = +value.call(node, node.__data__, i, j);
      } : (value = +value, function(node) {
        node.__transition__[id].delay = value;
      }));
    };
    d3_transitionPrototype.duration = function(value) {
      var id = this.id;
      if (arguments.length < 1) return this.node().__transition__[id].duration;
      return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
        node.__transition__[id].duration = Math.max(1, value.call(node, node.__data__, i, j));
      } : (value = Math.max(1, value), function(node) {
        node.__transition__[id].duration = value;
      }));
    };
    d3_transitionPrototype.each = function(type, listener) {
      var id = this.id;
      if (arguments.length < 2) {
        var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
        d3_transitionInheritId = id;
        d3_selection_each(this, function(node, i, j) {
          d3_transitionInherit = node.__transition__[id];
          type.call(node, node.__data__, i, j);
        });
        d3_transitionInherit = inherit;
        d3_transitionInheritId = inheritId;
      } else {
        d3_selection_each(this, function(node) {
          var transition = node.__transition__[id];
          (transition.event || (transition.event = d3.dispatch("start", "end"))).on(type, listener);
        });
      }
      return this;
    };
    d3_transitionPrototype.transition = function() {
      var id0 = this.id, id1 = ++d3_transitionId, subgroups = [], subgroup, group, node, transition;
      for (var j = 0, m = this.length; j < m; j++) {
        subgroups.push(subgroup = []);
        for (var group = this[j], i = 0, n = group.length; i < n; i++) {
          if (node = group[i]) {
            transition = Object.create(node.__transition__[id0]);
            transition.delay += transition.duration;
            d3_transitionNode(node, i, id1, transition);
          }
          subgroup.push(node);
        }
      }
      return d3_transition(subgroups, id1);
    };
    function d3_transitionNode(node, i, id, inherit) {
      var lock = node.__transition__ || (node.__transition__ = {
        active: 0,
        count: 0
      }), transition = lock[id];
      if (!transition) {
        var time = inherit.time;
        transition = lock[id] = {
          tween: new d3_Map(),
          time: time,
          ease: inherit.ease,
          delay: inherit.delay,
          duration: inherit.duration
        };
        ++lock.count;
        d3.timer(function(elapsed) {
          var d = node.__data__, ease = transition.ease, delay = transition.delay, duration = transition.duration, timer = d3_timer_active, tweened = [];
          timer.t = delay + time;
          if (delay <= elapsed) return start(elapsed - delay);
          timer.c = start;
          function start(elapsed) {
            if (lock.active > id) return stop();
            lock.active = id;
            transition.event && transition.event.start.call(node, d, i);
            transition.tween.forEach(function(key, value) {
              if (value = value.call(node, d, i)) {
                tweened.push(value);
              }
            });
            d3.timer(function() {
              timer.c = tick(elapsed || 1) ? d3_true : tick;
              return 1;
            }, 0, time);
          }
          function tick(elapsed) {
            if (lock.active !== id) return stop();
            var t = elapsed / duration, e = ease(t), n = tweened.length;
            while (n > 0) {
              tweened[--n].call(node, e);
            }
            if (t >= 1) {
              transition.event && transition.event.end.call(node, d, i);
              return stop();
            }
          }
          function stop() {
            if (--lock.count) delete lock[id]; else delete node.__transition__;
            return 1;
          }
        }, 0, time);
      }
    }
    d3.svg.axis = function() {
      var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
      function axis(g) {
        g.each(function() {
          var g = d3.select(this);
          var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
          var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickTransform;
          var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
          d3.transition(path));
          tickEnter.append("line");
          tickEnter.append("text");
          var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text");
          switch (orient) {
           case "bottom":
            {
              tickTransform = d3_svg_axisX;
              lineEnter.attr("y2", innerTickSize);
              textEnter.attr("y", Math.max(innerTickSize, 0) + tickPadding);
              lineUpdate.attr("x2", 0).attr("y2", innerTickSize);
              textUpdate.attr("x", 0).attr("y", Math.max(innerTickSize, 0) + tickPadding);
              text.attr("dy", ".71em").style("text-anchor", "middle");
              pathUpdate.attr("d", "M" + range[0] + "," + outerTickSize + "V0H" + range[1] + "V" + outerTickSize);
              break;
            }

           case "top":
            {
              tickTransform = d3_svg_axisX;
              lineEnter.attr("y2", -innerTickSize);
              textEnter.attr("y", -(Math.max(innerTickSize, 0) + tickPadding));
              lineUpdate.attr("x2", 0).attr("y2", -innerTickSize);
              textUpdate.attr("x", 0).attr("y", -(Math.max(innerTickSize, 0) + tickPadding));
              text.attr("dy", "0em").style("text-anchor", "middle");
              pathUpdate.attr("d", "M" + range[0] + "," + -outerTickSize + "V0H" + range[1] + "V" + -outerTickSize);
              break;
            }

           case "left":
            {
              tickTransform = d3_svg_axisY;
              lineEnter.attr("x2", -innerTickSize);
              textEnter.attr("x", -(Math.max(innerTickSize, 0) + tickPadding));
              lineUpdate.attr("x2", -innerTickSize).attr("y2", 0);
              textUpdate.attr("x", -(Math.max(innerTickSize, 0) + tickPadding)).attr("y", 0);
              text.attr("dy", ".32em").style("text-anchor", "end");
              pathUpdate.attr("d", "M" + -outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + -outerTickSize);
              break;
            }

           case "right":
            {
              tickTransform = d3_svg_axisY;
              lineEnter.attr("x2", innerTickSize);
              textEnter.attr("x", Math.max(innerTickSize, 0) + tickPadding);
              lineUpdate.attr("x2", innerTickSize).attr("y2", 0);
              textUpdate.attr("x", Math.max(innerTickSize, 0) + tickPadding).attr("y", 0);
              text.attr("dy", ".32em").style("text-anchor", "start");
              pathUpdate.attr("d", "M" + outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + outerTickSize);
              break;
            }
          }
          if (scale1.rangeBand) {
            var x = scale1, dx = x.rangeBand() / 2;
            scale0 = scale1 = function(d) {
              return x(d) + dx;
            };
          } else if (scale0.rangeBand) {
            scale0 = scale1;
          } else {
            tickExit.call(tickTransform, scale1);
          }
          tickEnter.call(tickTransform, scale0);
          tickUpdate.call(tickTransform, scale1);
        });
      }
      axis.scale = function(x) {
        if (!arguments.length) return scale;
        scale = x;
        return axis;
      };
      axis.orient = function(x) {
        if (!arguments.length) return orient;
        orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
        return axis;
      };
      axis.ticks = function() {
        if (!arguments.length) return tickArguments_;
        tickArguments_ = arguments;
        return axis;
      };
      axis.tickValues = function(x) {
        if (!arguments.length) return tickValues;
        tickValues = x;
        return axis;
      };
      axis.tickFormat = function(x) {
        if (!arguments.length) return tickFormat_;
        tickFormat_ = x;
        return axis;
      };
      axis.tickSize = function(x) {
        var n = arguments.length;
        if (!n) return innerTickSize;
        innerTickSize = +x;
        outerTickSize = +arguments[n - 1];
        return axis;
      };
      axis.innerTickSize = function(x) {
        if (!arguments.length) return innerTickSize;
        innerTickSize = +x;
        return axis;
      };
      axis.outerTickSize = function(x) {
        if (!arguments.length) return outerTickSize;
        outerTickSize = +x;
        return axis;
      };
      axis.tickPadding = function(x) {
        if (!arguments.length) return tickPadding;
        tickPadding = +x;
        return axis;
      };
      axis.tickSubdivide = function() {
        return arguments.length && axis;
      };
      return axis;
    };
    var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
      top: 1,
      right: 1,
      bottom: 1,
      left: 1
    };
    function d3_svg_axisX(selection, x) {
      selection.attr("transform", function(d) {
        return "translate(" + x(d) + ",0)";
      });
    }
    function d3_svg_axisY(selection, y) {
      selection.attr("transform", function(d) {
        return "translate(0," + y(d) + ")";
      });
    }
    d3.svg.brush = function() {
      var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
      function brush(g) {
        g.each(function() {
          var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
          var background = g.selectAll(".background").data([ 0 ]);
          background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
          g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
          var resize = g.selectAll(".resize").data(resizes, d3_identity);
          resize.exit().remove();
          resize.enter().append("g").attr("class", function(d) {
            return "resize " + d;
          }).style("cursor", function(d) {
            return d3_svg_brushCursor[d];
          }).append("rect").attr("x", function(d) {
            return /[ew]$/.test(d) ? -3 : null;
          }).attr("y", function(d) {
            return /^[ns]/.test(d) ? -3 : null;
          }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
          resize.style("display", brush.empty() ? "none" : null);
          var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
          if (x) {
            range = d3_scaleRange(x);
            backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
            redrawX(gUpdate);
          }
          if (y) {
            range = d3_scaleRange(y);
            backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
            redrawY(gUpdate);
          }
          redraw(gUpdate);
        });
      }
      brush.event = function(g) {
        g.each(function() {
          var event_ = event.of(this, arguments), extent1 = {
            x: xExtent,
            y: yExtent,
            i: xExtentDomain,
            j: yExtentDomain
          }, extent0 = this.__chart__ || extent1;
          this.__chart__ = extent1;
          if (d3_transitionInheritId) {
            d3.select(this).transition().each("start.brush", function() {
              xExtentDomain = extent0.i;
              yExtentDomain = extent0.j;
              xExtent = extent0.x;
              yExtent = extent0.y;
              event_({
                type: "brushstart"
              });
            }).tween("brush:brush", function() {
              var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
              xExtentDomain = yExtentDomain = null;
              return function(t) {
                xExtent = extent1.x = xi(t);
                yExtent = extent1.y = yi(t);
                event_({
                  type: "brush",
                  mode: "resize"
                });
              };
            }).each("end.brush", function() {
              xExtentDomain = extent1.i;
              yExtentDomain = extent1.j;
              event_({
                type: "brush",
                mode: "resize"
              });
              event_({
                type: "brushend"
              });
            });
          } else {
            event_({
              type: "brushstart"
            });
            event_({
              type: "brush",
              mode: "resize"
            });
            event_({
              type: "brushend"
            });
          }
        });
      };
      function redraw(g) {
        g.selectAll(".resize").attr("transform", function(d) {
          return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
        });
      }
      function redrawX(g) {
        g.select(".extent").attr("x", xExtent[0]);
        g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
      }
      function redrawY(g) {
        g.select(".extent").attr("y", yExtent[0]);
        g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
      }
      function brushstart() {
        var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(), center, origin = d3.mouse(target), offset;
        var w = d3.select(d3_window).on("keydown.brush", keydown).on("keyup.brush", keyup);
        if (d3.event.changedTouches) {
          w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
        } else {
          w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
        }
        g.interrupt().selectAll("*").interrupt();
        if (dragging) {
          origin[0] = xExtent[0] - origin[0];
          origin[1] = yExtent[0] - origin[1];
        } else if (resizing) {
          var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
          offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
          origin[0] = xExtent[ex];
          origin[1] = yExtent[ey];
        } else if (d3.event.altKey) center = origin.slice();
        g.style("pointer-events", "none").selectAll(".resize").style("display", null);
        d3.select("body").style("cursor", eventTarget.style("cursor"));
        event_({
          type: "brushstart"
        });
        brushmove();
        function keydown() {
          if (d3.event.keyCode == 32) {
            if (!dragging) {
              center = null;
              origin[0] -= xExtent[1];
              origin[1] -= yExtent[1];
              dragging = 2;
            }
            d3_eventPreventDefault();
          }
        }
        function keyup() {
          if (d3.event.keyCode == 32 && dragging == 2) {
            origin[0] += xExtent[1];
            origin[1] += yExtent[1];
            dragging = 0;
            d3_eventPreventDefault();
          }
        }
        function brushmove() {
          var point = d3.mouse(target), moved = false;
          if (offset) {
            point[0] += offset[0];
            point[1] += offset[1];
          }
          if (!dragging) {
            if (d3.event.altKey) {
              if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
              origin[0] = xExtent[+(point[0] < center[0])];
              origin[1] = yExtent[+(point[1] < center[1])];
            } else center = null;
          }
          if (resizingX && move1(point, x, 0)) {
            redrawX(g);
            moved = true;
          }
          if (resizingY && move1(point, y, 1)) {
            redrawY(g);
            moved = true;
          }
          if (moved) {
            redraw(g);
            event_({
              type: "brush",
              mode: dragging ? "move" : "resize"
            });
          }
        }
        function move1(point, scale, i) {
          var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
          if (dragging) {
            r0 -= position;
            r1 -= size + position;
          }
          min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
          if (dragging) {
            max = (min += position) + size;
          } else {
            if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
            if (position < min) {
              max = min;
              min = position;
            } else {
              max = position;
            }
          }
          if (extent[0] != min || extent[1] != max) {
            if (i) yExtentDomain = null; else xExtentDomain = null;
            extent[0] = min;
            extent[1] = max;
            return true;
          }
        }
        function brushend() {
          brushmove();
          g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
          d3.select("body").style("cursor", null);
          w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
          dragRestore();
          event_({
            type: "brushend"
          });
        }
      }
      brush.x = function(z) {
        if (!arguments.length) return x;
        x = z;
        resizes = d3_svg_brushResizes[!x << 1 | !y];
        return brush;
      };
      brush.y = function(z) {
        if (!arguments.length) return y;
        y = z;
        resizes = d3_svg_brushResizes[!x << 1 | !y];
        return brush;
      };
      brush.clamp = function(z) {
        if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
        if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
        return brush;
      };
      brush.extent = function(z) {
        var x0, x1, y0, y1, t;
        if (!arguments.length) {
          if (x) {
            if (xExtentDomain) {
              x0 = xExtentDomain[0], x1 = xExtentDomain[1];
            } else {
              x0 = xExtent[0], x1 = xExtent[1];
              if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
              if (x1 < x0) t = x0, x0 = x1, x1 = t;
            }
          }
          if (y) {
            if (yExtentDomain) {
              y0 = yExtentDomain[0], y1 = yExtentDomain[1];
            } else {
              y0 = yExtent[0], y1 = yExtent[1];
              if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
              if (y1 < y0) t = y0, y0 = y1, y1 = t;
            }
          }
          return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
        }
        if (x) {
          x0 = z[0], x1 = z[1];
          if (y) x0 = x0[0], x1 = x1[0];
          xExtentDomain = [ x0, x1 ];
          if (x.invert) x0 = x(x0), x1 = x(x1);
          if (x1 < x0) t = x0, x0 = x1, x1 = t;
          if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
        }
        if (y) {
          y0 = z[0], y1 = z[1];
          if (x) y0 = y0[1], y1 = y1[1];
          yExtentDomain = [ y0, y1 ];
          if (y.invert) y0 = y(y0), y1 = y(y1);
          if (y1 < y0) t = y0, y0 = y1, y1 = t;
          if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
        }
        return brush;
      };
      brush.clear = function() {
        if (!brush.empty()) {
          xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
          xExtentDomain = yExtentDomain = null;
        }
        return brush;
      };
      brush.empty = function() {
        return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
      };
      return d3.rebind(brush, event, "on");
    };
    var d3_svg_brushCursor = {
      n: "ns-resize",
      e: "ew-resize",
      s: "ns-resize",
      w: "ew-resize",
      nw: "nwse-resize",
      ne: "nesw-resize",
      se: "nwse-resize",
      sw: "nesw-resize"
    };
    var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
    var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
    var d3_time_formatUtc = d3_time_format.utc;
    var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
    d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
    function d3_time_formatIsoNative(date) {
      return date.toISOString();
    }
    d3_time_formatIsoNative.parse = function(string) {
      var date = new Date(string);
      return isNaN(date) ? null : date;
    };
    d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
    d3_time.second = d3_time_interval(function(date) {
      return new d3_date(Math.floor(date / 1e3) * 1e3);
    }, function(date, offset) {
      date.setTime(date.getTime() + Math.floor(offset) * 1e3);
    }, function(date) {
      return date.getSeconds();
    });
    d3_time.seconds = d3_time.second.range;
    d3_time.seconds.utc = d3_time.second.utc.range;
    d3_time.minute = d3_time_interval(function(date) {
      return new d3_date(Math.floor(date / 6e4) * 6e4);
    }, function(date, offset) {
      date.setTime(date.getTime() + Math.floor(offset) * 6e4);
    }, function(date) {
      return date.getMinutes();
    });
    d3_time.minutes = d3_time.minute.range;
    d3_time.minutes.utc = d3_time.minute.utc.range;
    d3_time.hour = d3_time_interval(function(date) {
      var timezone = date.getTimezoneOffset() / 60;
      return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
    }, function(date, offset) {
      date.setTime(date.getTime() + Math.floor(offset) * 36e5);
    }, function(date) {
      return date.getHours();
    });
    d3_time.hours = d3_time.hour.range;
    d3_time.hours.utc = d3_time.hour.utc.range;
    d3_time.month = d3_time_interval(function(date) {
      date = d3_time.day(date);
      date.setDate(1);
      return date;
    }, function(date, offset) {
      date.setMonth(date.getMonth() + offset);
    }, function(date) {
      return date.getMonth();
    });
    d3_time.months = d3_time.month.range;
    d3_time.months.utc = d3_time.month.utc.range;
    function d3_time_scale(linear, methods, format) {
      function scale(x) {
        return linear(x);
      }
      scale.invert = function(x) {
        return d3_time_scaleDate(linear.invert(x));
      };
      scale.domain = function(x) {
        if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
        linear.domain(x);
        return scale;
      };
      function tickMethod(extent, count) {
        var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
        return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
          return d / 31536e6;
        }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
      }
      scale.nice = function(interval, skip) {
        var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
        if (method) interval = method[0], skip = method[1];
        function skipped(date) {
          return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
        }
        return scale.domain(d3_scale_nice(domain, skip > 1 ? {
          floor: function(date) {
            while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
            return date;
          },
          ceil: function(date) {
            while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
            return date;
          }
        } : interval));
      };
      scale.ticks = function(interval, skip) {
        var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
          range: interval
        }, skip ];
        if (method) interval = method[0], skip = method[1];
        return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
      };
      scale.tickFormat = function() {
        return format;
      };
      scale.copy = function() {
        return d3_time_scale(linear.copy(), methods, format);
      };
      return d3_scale_linearRebind(scale, linear);
    }
    function d3_time_scaleDate(t) {
      return new Date(t);
    }
    var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
    var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
    var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
      return d.getMilliseconds();
    } ], [ ":%S", function(d) {
      return d.getSeconds();
    } ], [ "%I:%M", function(d) {
      return d.getMinutes();
    } ], [ "%I %p", function(d) {
      return d.getHours();
    } ], [ "%a %d", function(d) {
      return d.getDay() && d.getDate() != 1;
    } ], [ "%b %d", function(d) {
      return d.getDate() != 1;
    } ], [ "%B", function(d) {
      return d.getMonth();
    } ], [ "%Y", d3_true ] ]);
    var d3_time_scaleMilliseconds = {
      range: function(start, stop, step) {
        return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
      },
      floor: d3_identity,
      ceil: d3_identity
    };
    d3_time_scaleLocalMethods.year = d3_time.year;
    d3_time.scale = function() {
      return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
    };
    var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
      return [ m[0].utc, m[1] ];
    });
    var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
      return d.getUTCMilliseconds();
    } ], [ ":%S", function(d) {
      return d.getUTCSeconds();
    } ], [ "%I:%M", function(d) {
      return d.getUTCMinutes();
    } ], [ "%I %p", function(d) {
      return d.getUTCHours();
    } ], [ "%a %d", function(d) {
      return d.getUTCDay() && d.getUTCDate() != 1;
    } ], [ "%b %d", function(d) {
      return d.getUTCDate() != 1;
    } ], [ "%B", function(d) {
      return d.getUTCMonth();
    } ], [ "%Y", d3_true ] ]);
    d3_time_scaleUtcMethods.year = d3_time.year.utc;
    d3_time.scale.utc = function() {
      return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
    };
    d3.text = d3_xhrType(function(request) {
      return request.responseText;
    });
    d3.json = function(url, callback) {
      return d3_xhr(url, "application/json", d3_json, callback);
    };
    function d3_json(request) {
      return JSON.parse(request.responseText);
    }
    d3.html = function(url, callback) {
      return d3_xhr(url, "text/html", d3_html, callback);
    };
    function d3_html(request) {
      var range = d3_document.createRange();
      range.selectNode(d3_document.body);
      return range.createContextualFragment(request.responseText);
    }
    d3.xml = d3_xhrType(function(request) {
      return request.responseXML;
    });
    if (typeof define === "function" && define.amd) define(d3); else if (typeof module === "object" && module.exports) module.exports = d3;
    this.d3 = d3;
  }();

  </script>

  <script type="text/javascript">
  // CodeMirror, copyright (c) by Marijn Haverbeke and others
  // Distributed under an MIT license: http://codemirror.net/LICENSE

  // This is CodeMirror (http://codemirror.net), a code editor
  // implemented in JavaScript on top of the browser's DOM.
  //
  // You can find some technical background for some of the code below
  // at http://marijnhaverbeke.nl/blog/#cm-internals .

  (function(mod) {
    if (typeof exports == "object" && typeof module == "object") // CommonJS
      module.exports = mod();
    else if (typeof define == "function" && define.amd) // AMD
      return define([], mod);
    else
      this.CodeMirror = mod();
  })(function() {
    "use strict";

    // BROWSER SNIFFING

    // Kludges for bugs and behavior differences that can't be feature
    // detected are enabled based on userAgent etc sniffing.

    var gecko = /gecko\/\d/i.test(navigator.userAgent);
    // ie_uptoN means Internet Explorer version N or lower
    var ie_upto10 = /MSIE \d/.test(navigator.userAgent);
    var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
    var ie = ie_upto10 || ie_11up;
    var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);
    var webkit = /WebKit\//.test(navigator.userAgent);
    var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
    var chrome = /Chrome\//.test(navigator.userAgent);
    var presto = /Opera\//.test(navigator.userAgent);
    var safari = /Apple Computer/.test(navigator.vendor);
    var khtml = /KHTML\//.test(navigator.userAgent);
    var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
    var phantom = /PhantomJS/.test(navigator.userAgent);

    var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
    // This is woefully incomplete. Suggestions for alternative methods welcome.
    var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
    var mac = ios || /Mac/.test(navigator.platform);
    var windows = /win/i.test(navigator.platform);

    var presto_version = presto && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
    if (presto_version) presto_version = Number(presto_version[1]);
    if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
    // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
    var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
    var captureRightClick = gecko || (ie && ie_version >= 9);

    // Optimize some code when these features are not used.
    var sawReadOnlySpans = false, sawCollapsedSpans = false;

    // EDITOR CONSTRUCTOR

    // A CodeMirror instance represents an editor. This is the object
    // that user code is usually dealing with.

    function CodeMirror(place, options) {
      if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);

      this.options = options = options || {};
      // Determine effective options based on given values and defaults.
      copyObj(defaults, options, false);
      setGuttersForLineNumbers(options);

      var doc = options.value;
      if (typeof doc == "string") doc = new Doc(doc, options.mode);
      this.doc = doc;

      var display = this.display = new Display(place, doc);
      display.wrapper.CodeMirror = this;
      updateGutters(this);
      themeChanged(this);
      if (options.lineWrapping)
        this.display.wrapper.className += " CodeMirror-wrap";
      if (options.autofocus && !mobile) focusInput(this);

      this.state = {
        keyMaps: [],  // stores maps added by addKeyMap
        overlays: [], // highlighting overlays, as added by addOverlay
        modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
        overwrite: false, focused: false,
        suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
        pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in readInput
        draggingText: false,
        highlight: new Delayed() // stores highlight worker timeout
      };

      // Override magic textarea content restore that IE sometimes does
      // on our hidden textarea on reload
      if (ie && ie_version < 11) setTimeout(bind(resetInput, this, true), 20);

      registerEventHandlers(this);
      ensureGlobalHandlers();

      var cm = this;
      runInOp(this, function() {
        cm.curOp.forceUpdate = true;
        attachDoc(cm, doc);

        if ((options.autofocus && !mobile) || activeElt() == display.input)
          setTimeout(bind(onFocus, cm), 20);
        else
          onBlur(cm);

        for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))
          optionHandlers[opt](cm, options[opt], Init);
        maybeUpdateLineNumberWidth(cm);
        for (var i = 0; i < initHooks.length; ++i) initHooks[i](cm);
      });
    }

    // DISPLAY CONSTRUCTOR

    // The display handles the DOM integration, both for input reading
    // and content drawing. It holds references to DOM nodes and
    // display-related state.

    function Display(place, doc) {
      var d = this;

      // The semihidden textarea that is focused when the editor is
      // focused, and receives input.
      var input = d.input = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none");
      // The textarea is kept positioned near the cursor to prevent the
      // fact that it'll be scrolled into view on input from scrolling
      // our fake cursor out of view. On webkit, when wrap=off, paste is
      // very slow. So make the area wide instead.
      if (webkit) input.style.width = "1000px";
      else input.setAttribute("wrap", "off");
      // If border: 0; -- iOS fails to open keyboard (issue #1287)
      if (ios) input.style.border = "1px solid black";
      input.setAttribute("autocorrect", "off"); input.setAttribute("autocapitalize", "off"); input.setAttribute("spellcheck", "false");

      // Wraps and hides input textarea
      d.inputDiv = elt("div", [input], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
      // The fake scrollbar elements.
      d.scrollbarH = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
      d.scrollbarV = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
      // Covers bottom-right square when both scrollbars are present.
      d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
      // Covers bottom of gutter when coverGutterNextToScrollbar is on
      // and h scrollbar is present.
      d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
      // Will contain the actual code, positioned to cover the viewport.
      d.lineDiv = elt("div", null, "CodeMirror-code");
      // Elements are added to these to represent selection and cursors.
      d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
      d.cursorDiv = elt("div", null, "CodeMirror-cursors");
      // A visibility: hidden element used to find the size of things.
      d.measure = elt("div", null, "CodeMirror-measure");
      // When lines outside of the viewport are measured, they are drawn in this.
      d.lineMeasure = elt("div", null, "CodeMirror-measure");
      // Wraps everything that needs to exist inside the vertically-padded coordinate system
      d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                        null, "position: relative; outline: none");
      // Moved around its parent to cover visible view.
      d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
      // Set to the height of the document, allowing scrolling.
      d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
      // Behavior of elts with overflow: auto and padding is
      // inconsistent across browsers. This is used to ensure the
      // scrollable area is big enough.
      d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerCutOff + "px; width: 1px;");
      // Will contain the gutters, if any.
      d.gutters = elt("div", null, "CodeMirror-gutters");
      d.lineGutter = null;
      // Actual scrollable element.
      d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
      d.scroller.setAttribute("tabIndex", "-1");
      // The element in which the editor lives.
      d.wrapper = elt("div", [d.inputDiv, d.scrollbarH, d.scrollbarV,
                              d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

      // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
      if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
      // Needed to hide big blue blinking cursor on Mobile Safari
      if (ios) input.style.width = "0px";
      if (!webkit) d.scroller.draggable = true;
      // Needed to handle Tab key in KHTML
      if (khtml) { d.inputDiv.style.height = "1px"; d.inputDiv.style.position = "absolute"; }
      // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
      if (ie && ie_version < 8) d.scrollbarH.style.minHeight = d.scrollbarV.style.minWidth = "18px";

      if (place.appendChild) place.appendChild(d.wrapper);
      else place(d.wrapper);

      // Current rendered range (may be bigger than the view window).
      d.viewFrom = d.viewTo = doc.first;
      // Information about the rendered lines.
      d.view = [];
      // Holds info about a single rendered line when it was rendered
      // for measurement, while not in view.
      d.externalMeasured = null;
      // Empty space (in pixels) above the view
      d.viewOffset = 0;
      d.lastSizeC = 0;
      d.updateLineNumbers = null;

      // Used to only resize the line number gutter when necessary (when
      // the amount of lines crosses a boundary that makes its width change)
      d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
      // See readInput and resetInput
      d.prevInput = "";
      // Set to true when a non-horizontal-scrolling line widget is
      // added. As an optimization, line widget aligning is skipped when
      // this is false.
      d.alignWidgets = false;
      // Flag that indicates whether we expect input to appear real soon
      // now (after some event like 'keypress' or 'input') and are
      // polling intensively.
      d.pollingFast = false;
      // Self-resetting timeout for the poller
      d.poll = new Delayed();

      d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

      // Tracks when resetInput has punted to just putting a short
      // string into the textarea instead of the full selection.
      d.inaccurateSelection = false;

      // Tracks the maximum line length so that the horizontal scrollbar
      // can be kept static when scrolling.
      d.maxLine = null;
      d.maxLineLength = 0;
      d.maxLineChanged = false;

      // Used for measuring wheel scrolling granularity
      d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

      // True when shift is held down.
      d.shift = false;

      // Used to track whether anything happened since the context menu
      // was opened.
      d.selForContextMenu = null;
    }

    // STATE UPDATES

    // Used to get the editor into a consistent state again when options change.

    function loadMode(cm) {
      cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
      resetModeState(cm);
    }

    function resetModeState(cm) {
      cm.doc.iter(function(line) {
        if (line.stateAfter) line.stateAfter = null;
        if (line.styles) line.styles = null;
      });
      cm.doc.frontier = cm.doc.first;
      startWorker(cm, 100);
      cm.state.modeGen++;
      if (cm.curOp) regChange(cm);
    }

    function wrappingChanged(cm) {
      if (cm.options.lineWrapping) {
        addClass(cm.display.wrapper, "CodeMirror-wrap");
        cm.display.sizer.style.minWidth = "";
      } else {
        rmClass(cm.display.wrapper, "CodeMirror-wrap");
        findMaxLine(cm);
      }
      estimateLineHeights(cm);
      regChange(cm);
      clearCaches(cm);
      setTimeout(function(){updateScrollbars(cm);}, 100);
    }

    // Returns a function that estimates the height of a line, to use as
    // first approximation until the line becomes visible (and is thus
    // properly measurable).
    function estimateHeight(cm) {
      var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
      var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
      return function(line) {
        if (lineIsHidden(cm.doc, line)) return 0;

        var widgetsHeight = 0;
        if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {
          if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;
        }

        if (wrapping)
          return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
        else
          return widgetsHeight + th;
      };
    }

    function estimateLineHeights(cm) {
      var doc = cm.doc, est = estimateHeight(cm);
      doc.iter(function(line) {
        var estHeight = est(line);
        if (estHeight != line.height) updateLineHeight(line, estHeight);
      });
    }

    function keyMapChanged(cm) {
      var map = keyMap[cm.options.keyMap], style = map.style;
      cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-keymap-\S+/g, "") +
        (style ? " cm-keymap-" + style : "");
    }

    function themeChanged(cm) {
      cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
        cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
      clearCaches(cm);
    }

    function guttersChanged(cm) {
      updateGutters(cm);
      regChange(cm);
      setTimeout(function(){alignHorizontally(cm);}, 20);
    }

    // Rebuild the gutter elements, ensure the margin to the left of the
    // code matches their width.
    function updateGutters(cm) {
      var gutters = cm.display.gutters, specs = cm.options.gutters;
      removeChildren(gutters);
      for (var i = 0; i < specs.length; ++i) {
        var gutterClass = specs[i];
        var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
        if (gutterClass == "CodeMirror-linenumbers") {
          cm.display.lineGutter = gElt;
          gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
        }
      }
      gutters.style.display = i ? "" : "none";
      updateGutterSpace(cm);
    }

    function updateGutterSpace(cm) {
      var width = cm.display.gutters.offsetWidth;
      cm.display.sizer.style.marginLeft = width + "px";
      cm.display.scrollbarH.style.left = cm.options.fixedGutter ? width + "px" : 0;
    }

    // Compute the character length of a line, taking into account
    // collapsed ranges (see markText) that might hide parts, and join
    // other lines onto it.
    function lineLength(line) {
      if (line.height == 0) return 0;
      var len = line.text.length, merged, cur = line;
      while (merged = collapsedSpanAtStart(cur)) {
        var found = merged.find(0, true);
        cur = found.from.line;
        len += found.from.ch - found.to.ch;
      }
      cur = line;
      while (merged = collapsedSpanAtEnd(cur)) {
        var found = merged.find(0, true);
        len -= cur.text.length - found.from.ch;
        cur = found.to.line;
        len += cur.text.length - found.to.ch;
      }
      return len;
    }

    // Find the longest line in the document.
    function findMaxLine(cm) {
      var d = cm.display, doc = cm.doc;
      d.maxLine = getLine(doc, doc.first);
      d.maxLineLength = lineLength(d.maxLine);
      d.maxLineChanged = true;
      doc.iter(function(line) {
        var len = lineLength(line);
        if (len > d.maxLineLength) {
          d.maxLineLength = len;
          d.maxLine = line;
        }
      });
    }

    // Make sure the gutters options contains the element
    // "CodeMirror-linenumbers" when the lineNumbers option is true.
    function setGuttersForLineNumbers(options) {
      var found = indexOf(options.gutters, "CodeMirror-linenumbers");
      if (found == -1 && options.lineNumbers) {
        options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
      } else if (found > -1 && !options.lineNumbers) {
        options.gutters = options.gutters.slice(0);
        options.gutters.splice(found, 1);
      }
    }

    // SCROLLBARS

    function hScrollbarTakesSpace(cm) {
      return cm.display.scroller.clientHeight - cm.display.wrapper.clientHeight < scrollerCutOff - 3;
    }

    // Prepare DOM reads needed to update the scrollbars. Done in one
    // shot to minimize update/measure roundtrips.
    function measureForScrollbars(cm) {
      var scroll = cm.display.scroller;
      return {
        clientHeight: scroll.clientHeight,
        barHeight: cm.display.scrollbarV.clientHeight,
        scrollWidth: scroll.scrollWidth, clientWidth: scroll.clientWidth,
        hScrollbarTakesSpace: hScrollbarTakesSpace(cm),
        barWidth: cm.display.scrollbarH.clientWidth,
        docHeight: Math.round(cm.doc.height + paddingVert(cm.display))
      };
    }

    // Re-synchronize the fake scrollbars with the actual size of the
    // content.
    function updateScrollbars(cm, measure) {
      if (!measure) measure = measureForScrollbars(cm);
      var d = cm.display, sWidth = scrollbarWidth(d.measure);
      var scrollHeight = measure.docHeight + scrollerCutOff;
      var needsH = measure.scrollWidth > measure.clientWidth;
      if (needsH && measure.scrollWidth <= measure.clientWidth + 1 &&
          sWidth > 0 && !measure.hScrollbarTakesSpace)
        needsH = false; // (Issue #2562)
      var needsV = scrollHeight > measure.clientHeight;

      if (needsV) {
        d.scrollbarV.style.display = "block";
        d.scrollbarV.style.bottom = needsH ? sWidth + "px" : "0";
        // A bug in IE8 can cause this value to be negative, so guard it.
        d.scrollbarV.firstChild.style.height =
          Math.max(0, scrollHeight - measure.clientHeight + (measure.barHeight || d.scrollbarV.clientHeight)) + "px";
      } else {
        d.scrollbarV.style.display = "";
        d.scrollbarV.firstChild.style.height = "0";
      }
      if (needsH) {
        d.scrollbarH.style.display = "block";
        d.scrollbarH.style.right = needsV ? sWidth + "px" : "0";
        d.scrollbarH.firstChild.style.width =
          (measure.scrollWidth - measure.clientWidth + (measure.barWidth || d.scrollbarH.clientWidth)) + "px";
      } else {
        d.scrollbarH.style.display = "";
        d.scrollbarH.firstChild.style.width = "0";
      }
      if (needsH && needsV) {
        d.scrollbarFiller.style.display = "block";
        d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = sWidth + "px";
      } else d.scrollbarFiller.style.display = "";
      if (needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
        d.gutterFiller.style.display = "block";
        d.gutterFiller.style.height = sWidth + "px";
        d.gutterFiller.style.width = d.gutters.offsetWidth + "px";
      } else d.gutterFiller.style.display = "";

      if (!cm.state.checkedOverlayScrollbar && measure.clientHeight > 0) {
        if (sWidth === 0) {
          var w = mac && !mac_geMountainLion ? "12px" : "18px";
          d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = w;
          var barMouseDown = function(e) {
            if (e_target(e) != d.scrollbarV && e_target(e) != d.scrollbarH)
              operation(cm, onMouseDown)(e);
          };
          on(d.scrollbarV, "mousedown", barMouseDown);
          on(d.scrollbarH, "mousedown", barMouseDown);
        }
        cm.state.checkedOverlayScrollbar = true;
      }
    }

    // Compute the lines that are visible in a given viewport (defaults
    // the the current scroll position). viewport may contain top,
    // height, and ensure (see op.scrollToPos) properties.
    function visibleLines(display, doc, viewport) {
      var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
      top = Math.floor(top - paddingTop(display));
      var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

      var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
      // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
      // forces those lines into the viewport (if possible).
      if (viewport && viewport.ensure) {
        var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
        if (ensureFrom < from)
          return {from: ensureFrom,
                  to: lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight)};
        if (Math.min(ensureTo, doc.lastLine()) >= to)
          return {from: lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight),
                  to: ensureTo};
      }
      return {from: from, to: Math.max(to, from + 1)};
    }

    // LINE NUMBERS

    // Re-align line numbers and gutter marks to compensate for
    // horizontal scrolling.
    function alignHorizontally(cm) {
      var display = cm.display, view = display.view;
      if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;
      var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
      var gutterW = display.gutters.offsetWidth, left = comp + "px";
      for (var i = 0; i < view.length; i++) if (!view[i].hidden) {
        if (cm.options.fixedGutter && view[i].gutter)
          view[i].gutter.style.left = left;
        var align = view[i].alignable;
        if (align) for (var j = 0; j < align.length; j++)
          align[j].style.left = left;
      }
      if (cm.options.fixedGutter)
        display.gutters.style.left = (comp + gutterW) + "px";
    }

    // Used to ensure that the line number gutter is still the right
    // size for the current document size. Returns true when an update
    // is needed.
    function maybeUpdateLineNumberWidth(cm) {
      if (!cm.options.lineNumbers) return false;
      var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
      if (last.length != display.lineNumChars) {
        var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                   "CodeMirror-linenumber CodeMirror-gutter-elt"));
        var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
        display.lineGutter.style.width = "";
        display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);
        display.lineNumWidth = display.lineNumInnerWidth + padding;
        display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
        display.lineGutter.style.width = display.lineNumWidth + "px";
        updateGutterSpace(cm);
        return true;
      }
      return false;
    }

    function lineNumberFor(options, i) {
      return String(options.lineNumberFormatter(i + options.firstLineNumber));
    }

    // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
    // but using getBoundingClientRect to get a sub-pixel-accurate
    // result.
    function compensateForHScroll(display) {
      return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
    }

    // DISPLAY DRAWING

    function DisplayUpdate(cm, viewport, force) {
      var display = cm.display;

      this.viewport = viewport;
      // Store some values that we'll need later (but don't want to force a relayout for)
      this.visible = visibleLines(display, cm.doc, viewport);
      this.editorIsHidden = !display.wrapper.offsetWidth;
      this.wrapperHeight = display.wrapper.clientHeight;
      this.oldViewFrom = display.viewFrom; this.oldViewTo = display.viewTo;
      this.oldScrollerWidth = display.scroller.clientWidth;
      this.force = force;
      this.dims = getDimensions(cm);
    }

    // Does the actual updating of the line display. Bails out
    // (returning false) when there is nothing to be done and forced is
    // false.
    function updateDisplayIfNeeded(cm, update) {
      var display = cm.display, doc = cm.doc;
      if (update.editorIsHidden) {
        resetView(cm);
        return false;
      }

      // Bail out if the visible area is already rendered and nothing changed.
      if (!update.force &&
          update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
          (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
          countDirtyView(cm) == 0)
        return false;

      if (maybeUpdateLineNumberWidth(cm)) {
        resetView(cm);
        update.dims = getDimensions(cm);
      }

      // Compute a suitable new viewport (from & to)
      var end = doc.first + doc.size;
      var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
      var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
      if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);
      if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);
      if (sawCollapsedSpans) {
        from = visualLineNo(cm.doc, from);
        to = visualLineEndNo(cm.doc, to);
      }

      var different = from != display.viewFrom || to != display.viewTo ||
        display.lastSizeC != update.wrapperHeight;
      adjustView(cm, from, to);

      display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
      // Position the mover div to align with the current scroll position
      cm.display.mover.style.top = display.viewOffset + "px";

      var toUpdate = countDirtyView(cm);
      if (!different && toUpdate == 0 && !update.force &&
          (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
        return false;

      // For big changes, we hide the enclosing element during the
      // update, since that speeds up the operations on most browsers.
      var focused = activeElt();
      if (toUpdate > 4) display.lineDiv.style.display = "none";
      patchDisplay(cm, display.updateLineNumbers, update.dims);
      if (toUpdate > 4) display.lineDiv.style.display = "";
      // There might have been a widget with a focused element that got
      // hidden or updated, if so re-focus it.
      if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();

      // Prevent selection and cursors from interfering with the scroll
      // width.
      removeChildren(display.cursorDiv);
      removeChildren(display.selectionDiv);

      if (different) {
        display.lastSizeC = update.wrapperHeight;
        startWorker(cm, 400);
      }

      display.updateLineNumbers = null;

      return true;
    }

    function postUpdateDisplay(cm, update) {
      var force = update.force, viewport = update.viewport;
      for (var first = true;; first = false) {
        if (first && cm.options.lineWrapping && update.oldScrollerWidth != cm.display.scroller.clientWidth) {
          force = true;
        } else {
          force = false;
          // Clip forced viewport to actual scrollable area.
          if (viewport && viewport.top != null)
            viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - scrollerCutOff -
                                      cm.display.scroller.clientHeight, viewport.top)};
          // Updated line heights might result in the drawn area not
          // actually covering the viewport. Keep looping until it does.
          update.visible = visibleLines(cm.display, cm.doc, viewport);
          if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
            break;
        }
        if (!updateDisplayIfNeeded(cm, update)) break;
        updateHeightsInViewport(cm);
        var barMeasure = measureForScrollbars(cm);
        updateSelection(cm);
        setDocumentHeight(cm, barMeasure);
        updateScrollbars(cm, barMeasure);
      }

      signalLater(cm, "update", cm);
      if (cm.display.viewFrom != update.oldViewFrom || cm.display.viewTo != update.oldViewTo)
        signalLater(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
    }

    function updateDisplaySimple(cm, viewport) {
      var update = new DisplayUpdate(cm, viewport);
      if (updateDisplayIfNeeded(cm, update)) {
        updateHeightsInViewport(cm);
        postUpdateDisplay(cm, update);
        var barMeasure = measureForScrollbars(cm);
        updateSelection(cm);
        setDocumentHeight(cm, barMeasure);
        updateScrollbars(cm, barMeasure);
      }
    }

    function setDocumentHeight(cm, measure) {
      cm.display.sizer.style.minHeight = cm.display.heightForcer.style.top = measure.docHeight + "px";
      cm.display.gutters.style.height = Math.max(measure.docHeight, measure.clientHeight - scrollerCutOff) + "px";
    }

    function checkForWebkitWidthBug(cm, measure) {
      // Work around Webkit bug where it sometimes reserves space for a
      // non-existing phantom scrollbar in the scroller (Issue #2420)
      if (cm.display.sizer.offsetWidth + cm.display.gutters.offsetWidth < cm.display.scroller.clientWidth - 1) {
        cm.display.sizer.style.minHeight = cm.display.heightForcer.style.top = "0px";
        cm.display.gutters.style.height = measure.docHeight + "px";
      }
    }

    // Read the actual heights of the rendered lines, and update their
    // stored heights to match.
    function updateHeightsInViewport(cm) {
      var display = cm.display;
      var prevBottom = display.lineDiv.offsetTop;
      for (var i = 0; i < display.view.length; i++) {
        var cur = display.view[i], height;
        if (cur.hidden) continue;
        if (ie && ie_version < 8) {
          var bot = cur.node.offsetTop + cur.node.offsetHeight;
          height = bot - prevBottom;
          prevBottom = bot;
        } else {
          var box = cur.node.getBoundingClientRect();
          height = box.bottom - box.top;
        }
        var diff = cur.line.height - height;
        if (height < 2) height = textHeight(display);
        if (diff > .001 || diff < -.001) {
          updateLineHeight(cur.line, height);
          updateWidgetHeight(cur.line);
          if (cur.rest) for (var j = 0; j < cur.rest.length; j++)
            updateWidgetHeight(cur.rest[j]);
        }
      }
    }

    // Read and store the height of line widgets associated with the
    // given line.
    function updateWidgetHeight(line) {
      if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)
        line.widgets[i].height = line.widgets[i].node.offsetHeight;
    }

    // Do a bulk-read of the DOM positions and sizes needed to draw the
    // view, so that we don't interleave reading and writing to the DOM.
    function getDimensions(cm) {
      var d = cm.display, left = {}, width = {};
      for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
        left[cm.options.gutters[i]] = n.offsetLeft;
        width[cm.options.gutters[i]] = n.offsetWidth;
      }
      return {fixedPos: compensateForHScroll(d),
              gutterTotalWidth: d.gutters.offsetWidth,
              gutterLeft: left,
              gutterWidth: width,
              wrapperWidth: d.wrapper.clientWidth};
    }

    // Sync the actual display DOM structure with display.view, removing
    // nodes for lines that are no longer in view, and creating the ones
    // that are not there yet, and updating the ones that are out of
    // date.
    function patchDisplay(cm, updateNumbersFrom, dims) {
      var display = cm.display, lineNumbers = cm.options.lineNumbers;
      var container = display.lineDiv, cur = container.firstChild;

      function rm(node) {
        var next = node.nextSibling;
        // Works around a throw-scroll bug in OS X Webkit
        if (webkit && mac && cm.display.currentWheelTarget == node)
          node.style.display = "none";
        else
          node.parentNode.removeChild(node);
        return next;
      }

      var view = display.view, lineN = display.viewFrom;
      // Loop over the elements in the view, syncing cur (the DOM nodes
      // in display.lineDiv) with the view as we go.
      for (var i = 0; i < view.length; i++) {
        var lineView = view[i];
        if (lineView.hidden) {
        } else if (!lineView.node) { // Not drawn yet
          var node = buildLineElement(cm, lineView, lineN, dims);
          container.insertBefore(node, cur);
        } else { // Already drawn
          while (cur != lineView.node) cur = rm(cur);
          var updateNumber = lineNumbers && updateNumbersFrom != null &&
            updateNumbersFrom <= lineN && lineView.lineNumber;
          if (lineView.changes) {
            if (indexOf(lineView.changes, "gutter") > -1) updateNumber = false;
            updateLineForChanges(cm, lineView, lineN, dims);
          }
          if (updateNumber) {
            removeChildren(lineView.lineNumber);
            lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
          }
          cur = lineView.node.nextSibling;
        }
        lineN += lineView.size;
      }
      while (cur) cur = rm(cur);
    }

    // When an aspect of a line changes, a string is added to
    // lineView.changes. This updates the relevant part of the line's
    // DOM structure.
    function updateLineForChanges(cm, lineView, lineN, dims) {
      for (var j = 0; j < lineView.changes.length; j++) {
        var type = lineView.changes[j];
        if (type == "text") updateLineText(cm, lineView);
        else if (type == "gutter") updateLineGutter(cm, lineView, lineN, dims);
        else if (type == "class") updateLineClasses(lineView);
        else if (type == "widget") updateLineWidgets(lineView, dims);
      }
      lineView.changes = null;
    }

    // Lines with gutter elements, widgets or a background class need to
    // be wrapped, and have the extra elements added to the wrapper div
    function ensureLineWrapped(lineView) {
      if (lineView.node == lineView.text) {
        lineView.node = elt("div", null, null, "position: relative");
        if (lineView.text.parentNode)
          lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
        lineView.node.appendChild(lineView.text);
        if (ie && ie_version < 8) lineView.node.style.zIndex = 2;
      }
      return lineView.node;
    }

    function updateLineBackground(lineView) {
      var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
      if (cls) cls += " CodeMirror-linebackground";
      if (lineView.background) {
        if (cls) lineView.background.className = cls;
        else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
      } else if (cls) {
        var wrap = ensureLineWrapped(lineView);
        lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
      }
    }

    // Wrapper around buildLineContent which will reuse the structure
    // in display.externalMeasured when possible.
    function getLineContent(cm, lineView) {
      var ext = cm.display.externalMeasured;
      if (ext && ext.line == lineView.line) {
        cm.display.externalMeasured = null;
        lineView.measure = ext.measure;
        return ext.built;
      }
      return buildLineContent(cm, lineView);
    }

    // Redraw the line's text. Interacts with the background and text
    // classes because the mode may output tokens that influence these
    // classes.
    function updateLineText(cm, lineView) {
      var cls = lineView.text.className;
      var built = getLineContent(cm, lineView);
      if (lineView.text == lineView.node) lineView.node = built.pre;
      lineView.text.parentNode.replaceChild(built.pre, lineView.text);
      lineView.text = built.pre;
      if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
        lineView.bgClass = built.bgClass;
        lineView.textClass = built.textClass;
        updateLineClasses(lineView);
      } else if (cls) {
        lineView.text.className = cls;
      }
    }

    function updateLineClasses(lineView) {
      updateLineBackground(lineView);
      if (lineView.line.wrapClass)
        ensureLineWrapped(lineView).className = lineView.line.wrapClass;
      else if (lineView.node != lineView.text)
        lineView.node.className = "";
      var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
      lineView.text.className = textClass || "";
    }

    function updateLineGutter(cm, lineView, lineN, dims) {
      if (lineView.gutter) {
        lineView.node.removeChild(lineView.gutter);
        lineView.gutter = null;
      }
      var markers = lineView.line.gutterMarkers;
      if (cm.options.lineNumbers || markers) {
        var wrap = ensureLineWrapped(lineView);
        var gutterWrap = lineView.gutter =
          wrap.insertBefore(elt("div", null, "CodeMirror-gutter-wrapper", "position: absolute; left: " +
                                (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"),
                            lineView.text);
        if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
          lineView.lineNumber = gutterWrap.appendChild(
            elt("div", lineNumberFor(cm.options, lineN),
                "CodeMirror-linenumber CodeMirror-gutter-elt",
                "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "
                + cm.display.lineNumInnerWidth + "px"));
        if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {
          var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
          if (found)
            gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +
                                       dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
        }
      }
    }

    function updateLineWidgets(lineView, dims) {
      if (lineView.alignable) lineView.alignable = null;
      for (var node = lineView.node.firstChild, next; node; node = next) {
        var next = node.nextSibling;
        if (node.className == "CodeMirror-linewidget")
          lineView.node.removeChild(node);
      }
      insertLineWidgets(lineView, dims);
    }

    // Build a line's DOM representation from scratch
    function buildLineElement(cm, lineView, lineN, dims) {
      var built = getLineContent(cm, lineView);
      lineView.text = lineView.node = built.pre;
      if (built.bgClass) lineView.bgClass = built.bgClass;
      if (built.textClass) lineView.textClass = built.textClass;

      updateLineClasses(lineView);
      updateLineGutter(cm, lineView, lineN, dims);
      insertLineWidgets(lineView, dims);
      return lineView.node;
    }

    // A lineView may contain multiple logical lines (when merged by
    // collapsed spans). The widgets for all of them need to be drawn.
    function insertLineWidgets(lineView, dims) {
      insertLineWidgetsFor(lineView.line, lineView, dims, true);
      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
        insertLineWidgetsFor(lineView.rest[i], lineView, dims, false);
    }

    function insertLineWidgetsFor(line, lineView, dims, allowAbove) {
      if (!line.widgets) return;
      var wrap = ensureLineWrapped(lineView);
      for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
        var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
        if (!widget.handleMouseEvents) node.ignoreEvents = true;
        positionLineWidget(widget, node, lineView, dims);
        if (allowAbove && widget.above)
          wrap.insertBefore(node, lineView.gutter || lineView.text);
        else
          wrap.appendChild(node);
        signalLater(widget, "redraw");
      }
    }

    function positionLineWidget(widget, node, lineView, dims) {
      if (widget.noHScroll) {
        (lineView.alignable || (lineView.alignable = [])).push(node);
        var width = dims.wrapperWidth;
        node.style.left = dims.fixedPos + "px";
        if (!widget.coverGutter) {
          width -= dims.gutterTotalWidth;
          node.style.paddingLeft = dims.gutterTotalWidth + "px";
        }
        node.style.width = width + "px";
      }
      if (widget.coverGutter) {
        node.style.zIndex = 5;
        node.style.position = "relative";
        if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";
      }
    }

    // POSITION OBJECT

    // A Pos instance represents a position within the text.
    var Pos = CodeMirror.Pos = function(line, ch) {
      if (!(this instanceof Pos)) return new Pos(line, ch);
      this.line = line; this.ch = ch;
    };

    // Compare two positions, return 0 if they are the same, a negative
    // number when a is less, and a positive number otherwise.
    var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };

    function copyPos(x) {return Pos(x.line, x.ch);}
    function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }
    function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }

    // SELECTION / CURSOR

    // Selection objects are immutable. A new one is created every time
    // the selection changes. A selection is one or more non-overlapping
    // (and non-touching) ranges, sorted, and an integer that indicates
    // which one is the primary selection (the one that's scrolled into
    // view, that getCursor returns, etc).
    function Selection(ranges, primIndex) {
      this.ranges = ranges;
      this.primIndex = primIndex;
    }

    Selection.prototype = {
      primary: function() { return this.ranges[this.primIndex]; },
      equals: function(other) {
        if (other == this) return true;
        if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;
        for (var i = 0; i < this.ranges.length; i++) {
          var here = this.ranges[i], there = other.ranges[i];
          if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;
        }
        return true;
      },
      deepCopy: function() {
        for (var out = [], i = 0; i < this.ranges.length; i++)
          out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
        return new Selection(out, this.primIndex);
      },
      somethingSelected: function() {
        for (var i = 0; i < this.ranges.length; i++)
          if (!this.ranges[i].empty()) return true;
        return false;
      },
      contains: function(pos, end) {
        if (!end) end = pos;
        for (var i = 0; i < this.ranges.length; i++) {
          var range = this.ranges[i];
          if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
            return i;
        }
        return -1;
      }
    };

    function Range(anchor, head) {
      this.anchor = anchor; this.head = head;
    }

    Range.prototype = {
      from: function() { return minPos(this.anchor, this.head); },
      to: function() { return maxPos(this.anchor, this.head); },
      empty: function() {
        return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
      }
    };

    // Take an unsorted, potentially overlapping set of ranges, and
    // build a selection out of it. 'Consumes' ranges array (modifying
    // it).
    function normalizeSelection(ranges, primIndex) {
      var prim = ranges[primIndex];
      ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });
      primIndex = indexOf(ranges, prim);
      for (var i = 1; i < ranges.length; i++) {
        var cur = ranges[i], prev = ranges[i - 1];
        if (cmp(prev.to(), cur.from()) >= 0) {
          var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
          var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
          if (i <= primIndex) --primIndex;
          ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
        }
      }
      return new Selection(ranges, primIndex);
    }

    function simpleSelection(anchor, head) {
      return new Selection([new Range(anchor, head || anchor)], 0);
    }

    // Most of the external API clips given positions to make sure they
    // actually exist within the document.
    function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}
    function clipPos(doc, pos) {
      if (pos.line < doc.first) return Pos(doc.first, 0);
      var last = doc.first + doc.size - 1;
      if (pos.line > last) return Pos(last, getLine(doc, last).text.length);
      return clipToLen(pos, getLine(doc, pos.line).text.length);
    }
    function clipToLen(pos, linelen) {
      var ch = pos.ch;
      if (ch == null || ch > linelen) return Pos(pos.line, linelen);
      else if (ch < 0) return Pos(pos.line, 0);
      else return pos;
    }
    function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}
    function clipPosArray(doc, array) {
      for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);
      return out;
    }

    // SELECTION UPDATES

    // The 'scroll' parameter given to many of these indicated whether
    // the new cursor position should be scrolled into view after
    // modifying the selection.

    // If shift is held or the extend flag is set, extends a range to
    // include a given position (and optionally a second position).
    // Otherwise, simply returns the range between the given positions.
    // Used for cursor motion and such.
    function extendRange(doc, range, head, other) {
      if (doc.cm && doc.cm.display.shift || doc.extend) {
        var anchor = range.anchor;
        if (other) {
          var posBefore = cmp(head, anchor) < 0;
          if (posBefore != (cmp(other, anchor) < 0)) {
            anchor = head;
            head = other;
          } else if (posBefore != (cmp(head, other) < 0)) {
            head = other;
          }
        }
        return new Range(anchor, head);
      } else {
        return new Range(other || head, head);
      }
    }

    // Extend the primary selection range, discard the rest.
    function extendSelection(doc, head, other, options) {
      setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);
    }

    // Extend all selections (pos is an array of selections with length
    // equal the number of selections)
    function extendSelections(doc, heads, options) {
      for (var out = [], i = 0; i < doc.sel.ranges.length; i++)
        out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
      var newSel = normalizeSelection(out, doc.sel.primIndex);
      setSelection(doc, newSel, options);
    }

    // Updates a single range in the selection.
    function replaceOneSelection(doc, i, range, options) {
      var ranges = doc.sel.ranges.slice(0);
      ranges[i] = range;
      setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
    }

    // Reset the selection to a single range.
    function setSimpleSelection(doc, anchor, head, options) {
      setSelection(doc, simpleSelection(anchor, head), options);
    }

    // Give beforeSelectionChange handlers a change to influence a
    // selection update.
    function filterSelectionChange(doc, sel) {
      var obj = {
        ranges: sel.ranges,
        update: function(ranges) {
          this.ranges = [];
          for (var i = 0; i < ranges.length; i++)
            this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                       clipPos(doc, ranges[i].head));
        }
      };
      signal(doc, "beforeSelectionChange", doc, obj);
      if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
      if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);
      else return sel;
    }

    function setSelectionReplaceHistory(doc, sel, options) {
      var done = doc.history.done, last = lst(done);
      if (last && last.ranges) {
        done[done.length - 1] = sel;
        setSelectionNoUndo(doc, sel, options);
      } else {
        setSelection(doc, sel, options);
      }
    }

    // Set a new selection.
    function setSelection(doc, sel, options) {
      setSelectionNoUndo(doc, sel, options);
      addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
    }

    function setSelectionNoUndo(doc, sel, options) {
      if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
        sel = filterSelectionChange(doc, sel);

      var bias = options && options.bias ||
        (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
      setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

      if (!(options && options.scroll === false) && doc.cm)
        ensureCursorVisible(doc.cm);
    }

    function setSelectionInner(doc, sel) {
      if (sel.equals(doc.sel)) return;

      doc.sel = sel;

      if (doc.cm) {
        doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
        signalCursorActivity(doc.cm);
      }
      signalLater(doc, "cursorActivity", doc);
    }

    // Verify that the selection does not partially select any atomic
    // marked ranges.
    function reCheckSelection(doc) {
      setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);
    }

    // Return a selection that does not partially select any atomic
    // ranges.
    function skipAtomicInSelection(doc, sel, bias, mayClear) {
      var out;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range = sel.ranges[i];
        var newAnchor = skipAtomic(doc, range.anchor, bias, mayClear);
        var newHead = skipAtomic(doc, range.head, bias, mayClear);
        if (out || newAnchor != range.anchor || newHead != range.head) {
          if (!out) out = sel.ranges.slice(0, i);
          out[i] = new Range(newAnchor, newHead);
        }
      }
      return out ? normalizeSelection(out, sel.primIndex) : sel;
    }

    // Ensure a given position is not inside an atomic range.
    function skipAtomic(doc, pos, bias, mayClear) {
      var flipped = false, curPos = pos;
      var dir = bias || 1;
      doc.cantEdit = false;
      search: for (;;) {
        var line = getLine(doc, curPos.line);
        if (line.markedSpans) {
          for (var i = 0; i < line.markedSpans.length; ++i) {
            var sp = line.markedSpans[i], m = sp.marker;
            if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&
                (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
              if (mayClear) {
                signal(m, "beforeCursorEnter");
                if (m.explicitlyCleared) {
                  if (!line.markedSpans) break;
                  else {--i; continue;}
                }
              }
              if (!m.atomic) continue;
              var newPos = m.find(dir < 0 ? -1 : 1);
              if (cmp(newPos, curPos) == 0) {
                newPos.ch += dir;
                if (newPos.ch < 0) {
                  if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));
                  else newPos = null;
                } else if (newPos.ch > line.text.length) {
                  if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);
                  else newPos = null;
                }
                if (!newPos) {
                  if (flipped) {
                    // Driven in a corner -- no valid cursor position found at all
                    // -- try again *with* clearing, if we didn't already
                    if (!mayClear) return skipAtomic(doc, pos, bias, true);
                    // Otherwise, turn off editing until further notice, and return the start of the doc
                    doc.cantEdit = true;
                    return Pos(doc.first, 0);
                  }
                  flipped = true; newPos = pos; dir = -dir;
                }
              }
              curPos = newPos;
              continue search;
            }
          }
        }
        return curPos;
      }
    }

    // SELECTION DRAWING

    // Redraw the selection and/or cursor
    function drawSelection(cm) {
      var display = cm.display, doc = cm.doc, result = {};
      var curFragment = result.cursors = document.createDocumentFragment();
      var selFragment = result.selection = document.createDocumentFragment();

      for (var i = 0; i < doc.sel.ranges.length; i++) {
        var range = doc.sel.ranges[i];
        var collapsed = range.empty();
        if (collapsed || cm.options.showCursorWhenSelecting)
          drawSelectionCursor(cm, range, curFragment);
        if (!collapsed)
          drawSelectionRange(cm, range, selFragment);
      }

      // Move the hidden textarea near the cursor to prevent scrolling artifacts
      if (cm.options.moveInputWithCursor) {
        var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                            headPos.top + lineOff.top - wrapOff.top));
        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                             headPos.left + lineOff.left - wrapOff.left));
      }

      return result;
    }

    function showSelection(cm, drawn) {
      removeChildrenAndAdd(cm.display.cursorDiv, drawn.cursors);
      removeChildrenAndAdd(cm.display.selectionDiv, drawn.selection);
      if (drawn.teTop != null) {
        cm.display.inputDiv.style.top = drawn.teTop + "px";
        cm.display.inputDiv.style.left = drawn.teLeft + "px";
      }
    }

    function updateSelection(cm) {
      showSelection(cm, drawSelection(cm));
    }

    // Draws a cursor for the given range
    function drawSelectionCursor(cm, range, output) {
      var pos = cursorCoords(cm, range.head, "div", null, null, !cm.options.singleCursorHeightPerLine);

      var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
      cursor.style.left = pos.left + "px";
      cursor.style.top = pos.top + "px";
      cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

      if (pos.other) {
        // Secondary cursor, shown when on a 'jump' in bi-directional text
        var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
        otherCursor.style.display = "";
        otherCursor.style.left = pos.other.left + "px";
        otherCursor.style.top = pos.other.top + "px";
        otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
      }
    }

    // Draws the given range as a highlighted selection
    function drawSelectionRange(cm, range, output) {
      var display = cm.display, doc = cm.doc;
      var fragment = document.createDocumentFragment();
      var padding = paddingH(cm.display), leftSide = padding.left, rightSide = display.lineSpace.offsetWidth - padding.right;

      function add(left, top, width, bottom) {
        if (top < 0) top = 0;
        top = Math.round(top);
        bottom = Math.round(bottom);
        fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +
                                 "px; top: " + top + "px; width: " + (width == null ? rightSide - left : width) +
                                 "px; height: " + (bottom - top) + "px"));
      }

      function drawForLine(line, fromArg, toArg) {
        var lineObj = getLine(doc, line);
        var lineLen = lineObj.text.length;
        var start, end;
        function coords(ch, bias) {
          return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
        }

        iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {
          var leftPos = coords(from, "left"), rightPos, left, right;
          if (from == to) {
            rightPos = leftPos;
            left = right = leftPos.left;
          } else {
            rightPos = coords(to - 1, "right");
            if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }
            left = leftPos.left;
            right = rightPos.right;
          }
          if (fromArg == null && from == 0) left = leftSide;
          if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part
            add(left, leftPos.top, null, leftPos.bottom);
            left = leftSide;
            if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);
          }
          if (toArg == null && to == lineLen) right = rightSide;
          if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
            start = leftPos;
          if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
            end = rightPos;
          if (left < leftSide + 1) left = leftSide;
          add(left, rightPos.top, right - left, rightPos.bottom);
        });
        return {start: start, end: end};
      }

      var sFrom = range.from(), sTo = range.to();
      if (sFrom.line == sTo.line) {
        drawForLine(sFrom.line, sFrom.ch, sTo.ch);
      } else {
        var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
        var singleVLine = visualLine(fromLine) == visualLine(toLine);
        var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
        var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
        if (singleVLine) {
          if (leftEnd.top < rightStart.top - 2) {
            add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
            add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
          } else {
            add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
          }
        }
        if (leftEnd.bottom < rightStart.top)
          add(leftSide, leftEnd.bottom, null, rightStart.top);
      }

      output.appendChild(fragment);
    }

    // Cursor-blinking
    function restartBlink(cm) {
      if (!cm.state.focused) return;
      var display = cm.display;
      clearInterval(display.blinker);
      var on = true;
      display.cursorDiv.style.visibility = "";
      if (cm.options.cursorBlinkRate > 0)
        display.blinker = setInterval(function() {
          display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
        }, cm.options.cursorBlinkRate);
      else if (cm.options.cursorBlinkRate < 0)
        display.cursorDiv.style.visibility = "hidden";
    }

    // HIGHLIGHT WORKER

    function startWorker(cm, time) {
      if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)
        cm.state.highlight.set(time, bind(highlightWorker, cm));
    }

    function highlightWorker(cm) {
      var doc = cm.doc;
      if (doc.frontier < doc.first) doc.frontier = doc.first;
      if (doc.frontier >= cm.display.viewTo) return;
      var end = +new Date + cm.options.workTime;
      var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
      var changedLines = [];

      doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
        if (doc.frontier >= cm.display.viewFrom) { // Visible
          var oldStyles = line.styles;
          var highlighted = highlightLine(cm, line, state, true);
          line.styles = highlighted.styles;
          var oldCls = line.styleClasses, newCls = highlighted.classes;
          if (newCls) line.styleClasses = newCls;
          else if (oldCls) line.styleClasses = null;
          var ischange = !oldStyles || oldStyles.length != line.styles.length ||
            oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
          for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
          if (ischange) changedLines.push(doc.frontier);
          line.stateAfter = copyState(doc.mode, state);
        } else {
          processLine(cm, line.text, state);
          line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
        }
        ++doc.frontier;
        if (+new Date > end) {
          startWorker(cm, cm.options.workDelay);
          return true;
        }
      });
      if (changedLines.length) runInOp(cm, function() {
        for (var i = 0; i < changedLines.length; i++)
          regLineChange(cm, changedLines[i], "text");
      });
    }

    // Finds the line to start with when starting a parse. Tries to
    // find a line with a stateAfter, so that it can start with a
    // valid state. If that fails, it returns the line with the
    // smallest indentation, which tends to need the least context to
    // parse correctly.
    function findStartLine(cm, n, precise) {
      var minindent, minline, doc = cm.doc;
      var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
      for (var search = n; search > lim; --search) {
        if (search <= doc.first) return doc.first;
        var line = getLine(doc, search - 1);
        if (line.stateAfter && (!precise || search <= doc.frontier)) return search;
        var indented = countColumn(line.text, null, cm.options.tabSize);
        if (minline == null || minindent > indented) {
          minline = search - 1;
          minindent = indented;
        }
      }
      return minline;
    }

    function getStateBefore(cm, n, precise) {
      var doc = cm.doc, display = cm.display;
      if (!doc.mode.startState) return true;
      var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;
      if (!state) state = startState(doc.mode);
      else state = copyState(doc.mode, state);
      doc.iter(pos, n, function(line) {
        processLine(cm, line.text, state);
        var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
        line.stateAfter = save ? copyState(doc.mode, state) : null;
        ++pos;
      });
      if (precise) doc.frontier = pos;
      return state;
    }

    // POSITION MEASUREMENT

    function paddingTop(display) {return display.lineSpace.offsetTop;}
    function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}
    function paddingH(display) {
      if (display.cachedPaddingH) return display.cachedPaddingH;
      var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
      var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
      var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
      if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;
      return data;
    }

    // Ensure the lineView.wrapping.heights array is populated. This is
    // an array of bottom offsets for the lines that make up a drawn
    // line. When lineWrapping is on, there might be more than one
    // height.
    function ensureLineHeights(cm, lineView, rect) {
      var wrapping = cm.options.lineWrapping;
      var curWidth = wrapping && cm.display.scroller.clientWidth;
      if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
        var heights = lineView.measure.heights = [];
        if (wrapping) {
          lineView.measure.width = curWidth;
          var rects = lineView.text.firstChild.getClientRects();
          for (var i = 0; i < rects.length - 1; i++) {
            var cur = rects[i], next = rects[i + 1];
            if (Math.abs(cur.bottom - next.bottom) > 2)
              heights.push((cur.bottom + next.top) / 2 - rect.top);
          }
        }
        heights.push(rect.bottom - rect.top);
      }
    }

    // Find a line map (mapping character offsets to text nodes) and a
    // measurement cache for the given line number. (A line view might
    // contain multiple lines when collapsed ranges are present.)
    function mapFromLineView(lineView, line, lineN) {
      if (lineView.line == line)
        return {map: lineView.measure.map, cache: lineView.measure.cache};
      for (var i = 0; i < lineView.rest.length; i++)
        if (lineView.rest[i] == line)
          return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};
      for (var i = 0; i < lineView.rest.length; i++)
        if (lineNo(lineView.rest[i]) > lineN)
          return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};
    }

    // Render a line into the hidden node display.externalMeasured. Used
    // when measurement is needed for a line that's not in the viewport.
    function updateExternalMeasurement(cm, line) {
      line = visualLine(line);
      var lineN = lineNo(line);
      var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
      view.lineN = lineN;
      var built = view.built = buildLineContent(cm, view);
      view.text = built.pre;
      removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
      return view;
    }

    // Get a {top, bottom, left, right} box (in line-local coordinates)
    // for a given character.
    function measureChar(cm, line, ch, bias) {
      return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
    }

    // Find a line view that corresponds to the given line number.
    function findViewForLine(cm, lineN) {
      if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
        return cm.display.view[findViewIndex(cm, lineN)];
      var ext = cm.display.externalMeasured;
      if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
        return ext;
    }

    // Measurement can be split in two steps, the set-up work that
    // applies to the whole line, and the measurement of the actual
    // character. Functions like coordsChar, that need to do a lot of
    // measurements in a row, can thus ensure that the set-up work is
    // only done once.
    function prepareMeasureForLine(cm, line) {
      var lineN = lineNo(line);
      var view = findViewForLine(cm, lineN);
      if (view && !view.text)
        view = null;
      else if (view && view.changes)
        updateLineForChanges(cm, view, lineN, getDimensions(cm));
      if (!view)
        view = updateExternalMeasurement(cm, line);

      var info = mapFromLineView(view, line, lineN);
      return {
        line: line, view: view, rect: null,
        map: info.map, cache: info.cache, before: info.before,
        hasHeights: false
      };
    }

    // Given a prepared measurement object, measures the position of an
    // actual character (or fetches it from the cache).
    function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
      if (prepared.before) ch = -1;
      var key = ch + (bias || ""), found;
      if (prepared.cache.hasOwnProperty(key)) {
        found = prepared.cache[key];
      } else {
        if (!prepared.rect)
          prepared.rect = prepared.view.text.getBoundingClientRect();
        if (!prepared.hasHeights) {
          ensureLineHeights(cm, prepared.view, prepared.rect);
          prepared.hasHeights = true;
        }
        found = measureCharInner(cm, prepared, ch, bias);
        if (!found.bogus) prepared.cache[key] = found;
      }
      return {left: found.left, right: found.right,
              top: varHeight ? found.rtop : found.top,
              bottom: varHeight ? found.rbottom : found.bottom};
    }

    var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

    function measureCharInner(cm, prepared, ch, bias) {
      var map = prepared.map;

      var node, start, end, collapse;
      // First, search the line map for the text node corresponding to,
      // or closest to, the target character.
      for (var i = 0; i < map.length; i += 3) {
        var mStart = map[i], mEnd = map[i + 1];
        if (ch < mStart) {
          start = 0; end = 1;
          collapse = "left";
        } else if (ch < mEnd) {
          start = ch - mStart;
          end = start + 1;
        } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
          end = mEnd - mStart;
          start = end - 1;
          if (ch >= mEnd) collapse = "right";
        }
        if (start != null) {
          node = map[i + 2];
          if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
            collapse = bias;
          if (bias == "left" && start == 0)
            while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
              node = map[(i -= 3) + 2];
              collapse = "left";
            }
          if (bias == "right" && start == mEnd - mStart)
            while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
              node = map[(i += 3) + 2];
              collapse = "right";
            }
          break;
        }
      }

      var rect;
      if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
        for (;;) {
          while (start && isExtendingChar(prepared.line.text.charAt(mStart + start))) --start;
          while (mStart + end < mEnd && isExtendingChar(prepared.line.text.charAt(mStart + end))) ++end;
          if (ie && ie_version < 9 && start == 0 && end == mEnd - mStart) {
            rect = node.parentNode.getBoundingClientRect();
          } else if (ie && cm.options.lineWrapping) {
            var rects = range(node, start, end).getClientRects();
            if (rects.length)
              rect = rects[bias == "right" ? rects.length - 1 : 0];
            else
              rect = nullRect;
          } else {
            rect = range(node, start, end).getBoundingClientRect() || nullRect;
          }
          if (rect.left || rect.right || start == 0) break;
          end = start;
          start = start - 1;
          collapse = "right";
        }
      } else { // If it is a widget, simply get the box for the whole widget.
        if (start > 0) collapse = bias = "right";
        var rects;
        if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
          rect = rects[bias == "right" ? rects.length - 1 : 0];
        else
          rect = node.getBoundingClientRect();
      }
      if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
        var rSpan = node.parentNode.getClientRects()[0];
        if (rSpan)
          rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};
        else
          rect = nullRect;
      }

      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);

      var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
      var mid = (rtop + rbot) / 2;
      var heights = prepared.view.measure.heights;
      for (var i = 0; i < heights.length - 1; i++)
        if (mid < heights[i]) break;
      var top = i ? heights[i - 1] : 0, bot = heights[i];
      var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                    right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                    top: top, bottom: bot};
      if (!rect.left && !rect.right) result.bogus = true;
      if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

      return result;
    }

    // Work around problem with bounding client rects on ranges being
    // returned incorrectly when zoomed on IE10 and below.
    function maybeUpdateRectForZooming(measure, rect) {
      if (!window.screen || screen.logicalXDPI == null ||
          screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
        return rect;
      var scaleX = screen.logicalXDPI / screen.deviceXDPI;
      var scaleY = screen.logicalYDPI / screen.deviceYDPI;
      return {left: rect.left * scaleX, right: rect.right * scaleX,
              top: rect.top * scaleY, bottom: rect.bottom * scaleY};
    }

    function clearLineMeasurementCacheFor(lineView) {
      if (lineView.measure) {
        lineView.measure.cache = {};
        lineView.measure.heights = null;
        if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
          lineView.measure.caches[i] = {};
      }
    }

    function clearLineMeasurementCache(cm) {
      cm.display.externalMeasure = null;
      removeChildren(cm.display.lineMeasure);
      for (var i = 0; i < cm.display.view.length; i++)
        clearLineMeasurementCacheFor(cm.display.view[i]);
    }

    function clearCaches(cm) {
      clearLineMeasurementCache(cm);
      cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
      if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;
      cm.display.lineNumChars = null;
    }

    function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }
    function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }

    // Converts a {top, bottom, left, right} box from line-local
    // coordinates into another coordinate system. Context may be one of
    // "line", "div" (display.lineDiv), "local"/null (editor), or "page".
    function intoCoordSystem(cm, lineObj, rect, context) {
      if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {
        var size = widgetHeight(lineObj.widgets[i]);
        rect.top += size; rect.bottom += size;
      }
      if (context == "line") return rect;
      if (!context) context = "local";
      var yOff = heightAtLine(lineObj);
      if (context == "local") yOff += paddingTop(cm.display);
      else yOff -= cm.display.viewOffset;
      if (context == "page" || context == "window") {
        var lOff = cm.display.lineSpace.getBoundingClientRect();
        yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
        var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
        rect.left += xOff; rect.right += xOff;
      }
      rect.top += yOff; rect.bottom += yOff;
      return rect;
    }

    // Coverts a box from "div" coords to another coordinate system.
    // Context may be "window", "page", "div", or "local"/null.
    function fromCoordSystem(cm, coords, context) {
      if (context == "div") return coords;
      var left = coords.left, top = coords.top;
      // First move into "page" coordinate system
      if (context == "page") {
        left -= pageScrollX();
        top -= pageScrollY();
      } else if (context == "local" || !context) {
        var localBox = cm.display.sizer.getBoundingClientRect();
        left += localBox.left;
        top += localBox.top;
      }

      var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
      return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};
    }

    function charCoords(cm, pos, context, lineObj, bias) {
      if (!lineObj) lineObj = getLine(cm.doc, pos.line);
      return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
    }

    // Returns a box for a given cursor position, which may have an
    // 'other' property containing the position of the secondary cursor
    // on a bidi boundary.
    function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
      lineObj = lineObj || getLine(cm.doc, pos.line);
      if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);
      function get(ch, right) {
        var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
        if (right) m.left = m.right; else m.right = m.left;
        return intoCoordSystem(cm, lineObj, m, context);
      }
      function getBidi(ch, partPos) {
        var part = order[partPos], right = part.level % 2;
        if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
          part = order[--partPos];
          ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
          right = true;
        } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
          part = order[++partPos];
          ch = bidiLeft(part) - part.level % 2;
          right = false;
        }
        if (right && ch == part.to && ch > part.from) return get(ch - 1);
        return get(ch, right);
      }
      var order = getOrder(lineObj), ch = pos.ch;
      if (!order) return get(ch);
      var partPos = getBidiPartAt(order, ch);
      var val = getBidi(ch, partPos);
      if (bidiOther != null) val.other = getBidi(ch, bidiOther);
      return val;
    }

    // Used to cheaply estimate the coordinates for a position. Used for
    // intermediate scroll updates.
    function estimateCoords(cm, pos) {
      var left = 0, pos = clipPos(cm.doc, pos);
      if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;
      var lineObj = getLine(cm.doc, pos.line);
      var top = heightAtLine(lineObj) + paddingTop(cm.display);
      return {left: left, right: left, top: top, bottom: top + lineObj.height};
    }

    // Positions returned by coordsChar contain some extra information.
    // xRel is the relative x position of the input coordinates compared
    // to the found position (so xRel > 0 means the coordinates are to
    // the right of the character position, for example). When outside
    // is true, that means the coordinates lie outside the line's
    // vertical range.
    function PosWithInfo(line, ch, outside, xRel) {
      var pos = Pos(line, ch);
      pos.xRel = xRel;
      if (outside) pos.outside = true;
      return pos;
    }

    // Compute the character position closest to the given coordinates.
    // Input must be lineSpace-local ("div" coordinate system).
    function coordsChar(cm, x, y) {
      var doc = cm.doc;
      y += cm.display.viewOffset;
      if (y < 0) return PosWithInfo(doc.first, 0, true, -1);
      var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
      if (lineN > last)
        return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
      if (x < 0) x = 0;

      var lineObj = getLine(doc, lineN);
      for (;;) {
        var found = coordsCharInner(cm, lineObj, lineN, x, y);
        var merged = collapsedSpanAtEnd(lineObj);
        var mergedPos = merged && merged.find(0, true);
        if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
          lineN = lineNo(lineObj = mergedPos.to.line);
        else
          return found;
      }
    }

    function coordsCharInner(cm, lineObj, lineNo, x, y) {
      var innerOff = y - heightAtLine(lineObj);
      var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
      var preparedMeasure = prepareMeasureForLine(cm, lineObj);

      function getX(ch) {
        var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure);
        wrongLine = true;
        if (innerOff > sp.bottom) return sp.left - adjust;
        else if (innerOff < sp.top) return sp.left + adjust;
        else wrongLine = false;
        return sp.left;
      }

      var bidi = getOrder(lineObj), dist = lineObj.text.length;
      var from = lineLeft(lineObj), to = lineRight(lineObj);
      var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;

      if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);
      // Do a binary search between these bounds.
      for (;;) {
        if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
          var ch = x < fromX || x - fromX <= toX - x ? from : to;
          var xDiff = x - (ch == from ? fromX : toX);
          while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;
          var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,
                                xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);
          return pos;
        }
        var step = Math.ceil(dist / 2), middle = from + step;
        if (bidi) {
          middle = from;
          for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);
        }
        var middleX = getX(middle);
        if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}
        else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}
      }
    }

    var measureText;
    // Compute the default text height.
    function textHeight(display) {
      if (display.cachedTextHeight != null) return display.cachedTextHeight;
      if (measureText == null) {
        measureText = elt("pre");
        // Measure a bunch of lines, for browsers that compute
        // fractional heights.
        for (var i = 0; i < 49; ++i) {
          measureText.appendChild(document.createTextNode("x"));
          measureText.appendChild(elt("br"));
        }
        measureText.appendChild(document.createTextNode("x"));
      }
      removeChildrenAndAdd(display.measure, measureText);
      var height = measureText.offsetHeight / 50;
      if (height > 3) display.cachedTextHeight = height;
      removeChildren(display.measure);
      return height || 1;
    }

    // Compute the default character width.
    function charWidth(display) {
      if (display.cachedCharWidth != null) return display.cachedCharWidth;
      var anchor = elt("span", "xxxxxxxxxx");
      var pre = elt("pre", [anchor]);
      removeChildrenAndAdd(display.measure, pre);
      var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
      if (width > 2) display.cachedCharWidth = width;
      return width || 10;
    }

    // OPERATIONS

    // Operations are used to wrap a series of changes to the editor
    // state in such a way that each change won't have to update the
    // cursor and display (which would be awkward, slow, and
    // error-prone). Instead, display updates are batched and then all
    // combined and executed at once.

    var operationGroup = null;

    var nextOpId = 0;
    // Start a new operation.
    function startOperation(cm) {
      cm.curOp = {
        cm: cm,
        viewChanged: false,      // Flag that indicates that lines might need to be redrawn
        startHeight: cm.doc.height, // Used to detect need to update scrollbar
        forceUpdate: false,      // Used to force a redraw
        updateInput: null,       // Whether to reset the input textarea
        typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
        changeObjs: null,        // Accumulated changes, for firing change events
        cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
        cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
        selectionChanged: false, // Whether the selection needs to be redrawn
        updateMaxLine: false,    // Set when the widest line needs to be determined anew
        scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
        scrollToPos: null,       // Used to scroll to a specific position
        id: ++nextOpId           // Unique ID
      };
      if (operationGroup) {
        operationGroup.ops.push(cm.curOp);
      } else {
        cm.curOp.ownsGroup = operationGroup = {
          ops: [cm.curOp],
          delayedCallbacks: []
        };
      }
    }

    function fireCallbacksForOps(group) {
      // Calls delayed callbacks and cursorActivity handlers until no
      // new ones appear
      var callbacks = group.delayedCallbacks, i = 0;
      do {
        for (; i < callbacks.length; i++)
          callbacks[i]();
        for (var j = 0; j < group.ops.length; j++) {
          var op = group.ops[j];
          if (op.cursorActivityHandlers)
            while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
              op.cursorActivityHandlers[op.cursorActivityCalled++](op.cm);
        }
      } while (i < callbacks.length);
    }

    // Finish an operation, updating the display and signalling delayed events
    function endOperation(cm) {
      var op = cm.curOp, group = op.ownsGroup;
      if (!group) return;

      try { fireCallbacksForOps(group); }
      finally {
        operationGroup = null;
        for (var i = 0; i < group.ops.length; i++)
          group.ops[i].cm.curOp = null;
        endOperations(group);
      }
    }

    // The DOM updates done when an operation finishes are batched so
    // that the minimum number of relayouts are required.
    function endOperations(group) {
      var ops = group.ops;
      for (var i = 0; i < ops.length; i++) // Read DOM
        endOperation_R1(ops[i]);
      for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
        endOperation_W1(ops[i]);
      for (var i = 0; i < ops.length; i++) // Read DOM
        endOperation_R2(ops[i]);
      for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
        endOperation_W2(ops[i]);
      for (var i = 0; i < ops.length; i++) // Read DOM
        endOperation_finish(ops[i]);
    }

    function endOperation_R1(op) {
      var cm = op.cm, display = cm.display;
      if (op.updateMaxLine) findMaxLine(cm);

      op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
        op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                           op.scrollToPos.to.line >= display.viewTo) ||
        display.maxLineChanged && cm.options.lineWrapping;
      op.update = op.mustUpdate &&
        new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
    }

    function endOperation_W1(op) {
      op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
    }

    function endOperation_R2(op) {
      var cm = op.cm, display = cm.display;
      if (op.updatedDisplay) updateHeightsInViewport(cm);

      op.barMeasure = measureForScrollbars(cm);

      // If the max line changed since it was last measured, measure it,
      // and ensure the document's width matches it.
      // updateDisplay_W2 will use these properties to do the actual resizing
      if (display.maxLineChanged && !cm.options.lineWrapping) {
        op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
        op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo +
                                    scrollerCutOff - display.scroller.clientWidth);
      }

      if (op.updatedDisplay || op.selectionChanged)
        op.newSelectionNodes = drawSelection(cm);
    }

    function endOperation_W2(op) {
      var cm = op.cm;

      if (op.adjustWidthTo != null) {
        cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
        if (op.maxScrollLeft < cm.doc.scrollLeft)
          setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
        cm.display.maxLineChanged = false;
      }

      if (op.newSelectionNodes)
        showSelection(cm, op.newSelectionNodes);
      if (op.updatedDisplay)
        setDocumentHeight(cm, op.barMeasure);
      if (op.updatedDisplay || op.startHeight != cm.doc.height)
        updateScrollbars(cm, op.barMeasure);

      if (op.selectionChanged) restartBlink(cm);

      if (cm.state.focused && op.updateInput)
        resetInput(cm, op.typing);
    }

    function endOperation_finish(op) {
      var cm = op.cm, display = cm.display, doc = cm.doc;

      if (op.adjustWidthTo != null && Math.abs(op.barMeasure.scrollWidth - cm.display.scroller.scrollWidth) > 1)
        updateScrollbars(cm);

      if (op.updatedDisplay) postUpdateDisplay(cm, op.update);

      // Abort mouse wheel delta measurement, when scrolling explicitly
      if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
        display.wheelStartX = display.wheelStartY = null;

      // Propagate the scroll position to the actual DOM scroller
      if (op.scrollTop != null && display.scroller.scrollTop != op.scrollTop) {
        var top = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
        display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = top;
      }
      if (op.scrollLeft != null && display.scroller.scrollLeft != op.scrollLeft) {
        var left = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));
        display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = left;
        alignHorizontally(cm);
      }
      // If we need to scroll a specific position into view, do so.
      if (op.scrollToPos) {
        var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                       clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
        if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);
      }

      // Fire events for markers that are hidden/unidden by editing or
      // undoing
      var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
      if (hidden) for (var i = 0; i < hidden.length; ++i)
        if (!hidden[i].lines.length) signal(hidden[i], "hide");
      if (unhidden) for (var i = 0; i < unhidden.length; ++i)
        if (unhidden[i].lines.length) signal(unhidden[i], "unhide");

      if (display.wrapper.offsetHeight)
        doc.scrollTop = cm.display.scroller.scrollTop;

      // Apply workaround for two webkit bugs
      if (op.updatedDisplay && webkit) {
        if (cm.options.lineWrapping)
          checkForWebkitWidthBug(cm, op.barMeasure); // (Issue #2420)
        if (op.barMeasure.scrollWidth > op.barMeasure.clientWidth &&
            op.barMeasure.scrollWidth < op.barMeasure.clientWidth + 1 &&
            !hScrollbarTakesSpace(cm))
          updateScrollbars(cm); // (Issue #2562)
      }

      // Fire change events, and delayed event handlers
      if (op.changeObjs)
        signal(cm, "changes", cm, op.changeObjs);
    }

    // Run the given function in an operation
    function runInOp(cm, f) {
      if (cm.curOp) return f();
      startOperation(cm);
      try { return f(); }
      finally { endOperation(cm); }
    }
    // Wraps a function in an operation. Returns the wrapped function.
    function operation(cm, f) {
      return function() {
        if (cm.curOp) return f.apply(cm, arguments);
        startOperation(cm);
        try { return f.apply(cm, arguments); }
        finally { endOperation(cm); }
      };
    }
    // Used to add methods to editor and doc instances, wrapping them in
    // operations.
    function methodOp(f) {
      return function() {
        if (this.curOp) return f.apply(this, arguments);
        startOperation(this);
        try { return f.apply(this, arguments); }
        finally { endOperation(this); }
      };
    }
    function docMethodOp(f) {
      return function() {
        var cm = this.cm;
        if (!cm || cm.curOp) return f.apply(this, arguments);
        startOperation(cm);
        try { return f.apply(this, arguments); }
        finally { endOperation(cm); }
      };
    }

    // VIEW TRACKING

    // These objects are used to represent the visible (currently drawn)
    // part of the document. A LineView may correspond to multiple
    // logical lines, if those are connected by collapsed ranges.
    function LineView(doc, line, lineN) {
      // The starting line
      this.line = line;
      // Continuing lines, if any
      this.rest = visualLineContinued(line);
      // Number of logical lines in this visual line
      this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
      this.node = this.text = null;
      this.hidden = lineIsHidden(doc, line);
    }

    // Create a range of LineView objects for the given lines.
    function buildViewArray(cm, from, to) {
      var array = [], nextPos;
      for (var pos = from; pos < to; pos = nextPos) {
        var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
        nextPos = pos + view.size;
        array.push(view);
      }
      return array;
    }

    // Updates the display.view data structure for a given change to the
    // document. From and to are in pre-change coordinates. Lendiff is
    // the amount of lines added or subtracted by the change. This is
    // used for changes that span multiple lines, or change the way
    // lines are divided into visual lines. regLineChange (below)
    // registers single-line changes.
    function regChange(cm, from, to, lendiff) {
      if (from == null) from = cm.doc.first;
      if (to == null) to = cm.doc.first + cm.doc.size;
      if (!lendiff) lendiff = 0;

      var display = cm.display;
      if (lendiff && to < display.viewTo &&
          (display.updateLineNumbers == null || display.updateLineNumbers > from))
        display.updateLineNumbers = from;

      cm.curOp.viewChanged = true;

      if (from >= display.viewTo) { // Change after
        if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
          resetView(cm);
      } else if (to <= display.viewFrom) { // Change before
        if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
          resetView(cm);
        } else {
          display.viewFrom += lendiff;
          display.viewTo += lendiff;
        }
      } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
        resetView(cm);
      } else if (from <= display.viewFrom) { // Top overlap
        var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
        if (cut) {
          display.view = display.view.slice(cut.index);
          display.viewFrom = cut.lineN;
          display.viewTo += lendiff;
        } else {
          resetView(cm);
        }
      } else if (to >= display.viewTo) { // Bottom overlap
        var cut = viewCuttingPoint(cm, from, from, -1);
        if (cut) {
          display.view = display.view.slice(0, cut.index);
          display.viewTo = cut.lineN;
        } else {
          resetView(cm);
        }
      } else { // Gap in the middle
        var cutTop = viewCuttingPoint(cm, from, from, -1);
        var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
        if (cutTop && cutBot) {
          display.view = display.view.slice(0, cutTop.index)
            .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
            .concat(display.view.slice(cutBot.index));
          display.viewTo += lendiff;
        } else {
          resetView(cm);
        }
      }

      var ext = display.externalMeasured;
      if (ext) {
        if (to < ext.lineN)
          ext.lineN += lendiff;
        else if (from < ext.lineN + ext.size)
          display.externalMeasured = null;
      }
    }

    // Register a change to a single line. Type must be one of "text",
    // "gutter", "class", "widget"
    function regLineChange(cm, line, type) {
      cm.curOp.viewChanged = true;
      var display = cm.display, ext = cm.display.externalMeasured;
      if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
        display.externalMeasured = null;

      if (line < display.viewFrom || line >= display.viewTo) return;
      var lineView = display.view[findViewIndex(cm, line)];
      if (lineView.node == null) return;
      var arr = lineView.changes || (lineView.changes = []);
      if (indexOf(arr, type) == -1) arr.push(type);
    }

    // Clear the view.
    function resetView(cm) {
      cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
      cm.display.view = [];
      cm.display.viewOffset = 0;
    }

    // Find the view element corresponding to a given line. Return null
    // when the line isn't visible.
    function findViewIndex(cm, n) {
      if (n >= cm.display.viewTo) return null;
      n -= cm.display.viewFrom;
      if (n < 0) return null;
      var view = cm.display.view;
      for (var i = 0; i < view.length; i++) {
        n -= view[i].size;
        if (n < 0) return i;
      }
    }

    function viewCuttingPoint(cm, oldN, newN, dir) {
      var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
      if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
        return {index: index, lineN: newN};
      for (var i = 0, n = cm.display.viewFrom; i < index; i++)
        n += view[i].size;
      if (n != oldN) {
        if (dir > 0) {
          if (index == view.length - 1) return null;
          diff = (n + view[index].size) - oldN;
          index++;
        } else {
          diff = n - oldN;
        }
        oldN += diff; newN += diff;
      }
      while (visualLineNo(cm.doc, newN) != newN) {
        if (index == (dir < 0 ? 0 : view.length - 1)) return null;
        newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
        index += dir;
      }
      return {index: index, lineN: newN};
    }

    // Force the view to cover a given range, adding empty view element
    // or clipping off existing ones as needed.
    function adjustView(cm, from, to) {
      var display = cm.display, view = display.view;
      if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
        display.view = buildViewArray(cm, from, to);
        display.viewFrom = from;
      } else {
        if (display.viewFrom > from)
          display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
        else if (display.viewFrom < from)
          display.view = display.view.slice(findViewIndex(cm, from));
        display.viewFrom = from;
        if (display.viewTo < to)
          display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
        else if (display.viewTo > to)
          display.view = display.view.slice(0, findViewIndex(cm, to));
      }
      display.viewTo = to;
    }

    // Count the number of lines in the view whose DOM representation is
    // out of date (or nonexistent).
    function countDirtyView(cm) {
      var view = cm.display.view, dirty = 0;
      for (var i = 0; i < view.length; i++) {
        var lineView = view[i];
        if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;
      }
      return dirty;
    }

    // INPUT HANDLING

    // Poll for input changes, using the normal rate of polling. This
    // runs as long as the editor is focused.
    function slowPoll(cm) {
      if (cm.display.pollingFast) return;
      cm.display.poll.set(cm.options.pollInterval, function() {
        readInput(cm);
        if (cm.state.focused) slowPoll(cm);
      });
    }

    // When an event has just come in that is likely to add or change
    // something in the input textarea, we poll faster, to ensure that
    // the change appears on the screen quickly.
    function fastPoll(cm) {
      var missed = false;
      cm.display.pollingFast = true;
      function p() {
        var changed = readInput(cm);
        if (!changed && !missed) {missed = true; cm.display.poll.set(60, p);}
        else {cm.display.pollingFast = false; slowPoll(cm);}
      }
      cm.display.poll.set(20, p);
    }

    // This will be set to an array of strings when copying, so that,
    // when pasting, we know what kind of selections the copied text
    // was made out of.
    var lastCopied = null;

    // Read input from the textarea, and update the document to match.
    // When something is selected, it is present in the textarea, and
    // selected (unless it is huge, in which case a placeholder is
    // used). When nothing is selected, the cursor sits after previously
    // seen text (can be empty), which is stored in prevInput (we must
    // not reset the textarea when typing, because that breaks IME).
    function readInput(cm) {
      var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc;
      // Since this is called a *lot*, try to bail out as cheaply as
      // possible when it is clear that nothing happened. hasSelection
      // will be the case when there is a lot of text in the textarea,
      // in which case reading its value would be expensive.
      if (!cm.state.focused || (hasSelection(input) && !prevInput) || isReadOnly(cm) || cm.options.disableInput)
        return false;
      // See paste handler for more on the fakedLastChar kludge
      if (cm.state.pasteIncoming && cm.state.fakedLastChar) {
        input.value = input.value.substring(0, input.value.length - 1);
        cm.state.fakedLastChar = false;
      }
      var text = input.value;
      // If nothing changed, bail.
      if (text == prevInput && !cm.somethingSelected()) return false;
      // Work around nonsensical selection resetting in IE9/10, and
      // inexplicable appearance of private area unicode characters on
      // some key combos in Mac (#2689).
      if (ie && ie_version >= 9 && cm.display.inputHasSelection === text ||
          mac && /[\uf700-\uf7ff]/.test(text)) {
        resetInput(cm);
        return false;
      }

      var withOp = !cm.curOp;
      if (withOp) startOperation(cm);
      cm.display.shift = false;

      if (text.charCodeAt(0) == 0x200b && doc.sel == cm.display.selForContextMenu && !prevInput)
        prevInput = "\u200b";
      // Find the part of the input that is actually new
      var same = 0, l = Math.min(prevInput.length, text.length);
      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;
      var inserted = text.slice(same), textLines = splitLines(inserted);

      // When pasing N lines into N selections, insert one line per selection
      var multiPaste = null;
      if (cm.state.pasteIncoming && doc.sel.ranges.length > 1) {
        if (lastCopied && lastCopied.join("\n") == inserted)
          multiPaste = doc.sel.ranges.length % lastCopied.length == 0 && map(lastCopied, splitLines);
        else if (textLines.length == doc.sel.ranges.length)
          multiPaste = map(textLines, function(l) { return [l]; });
      }

      // Normal behavior is to insert the new text into every selection
      for (var i = doc.sel.ranges.length - 1; i >= 0; i--) {
        var range = doc.sel.ranges[i];
        var from = range.from(), to = range.to();
        // Handle deletion
        if (same < prevInput.length)
          from = Pos(from.line, from.ch - (prevInput.length - same));
        // Handle overwrite
        else if (cm.state.overwrite && range.empty() && !cm.state.pasteIncoming)
          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
        var updateInput = cm.curOp.updateInput;
        var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,
                           origin: cm.state.pasteIncoming ? "paste" : cm.state.cutIncoming ? "cut" : "+input"};
        makeChange(cm.doc, changeEvent);
        signalLater(cm, "inputRead", cm, changeEvent);
        // When an 'electric' character is inserted, immediately trigger a reindent
        if (inserted && !cm.state.pasteIncoming && cm.options.electricChars &&
            cm.options.smartIndent && range.head.ch < 100 &&
            (!i || doc.sel.ranges[i - 1].head.line != range.head.line)) {
          var mode = cm.getModeAt(range.head);
          if (mode.electricChars) {
            for (var j = 0; j < mode.electricChars.length; j++)
              if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
                indentLine(cm, range.head.line, "smart");
                break;
              }
          } else if (mode.electricInput) {
            var end = changeEnd(changeEvent);
            if (mode.electricInput.test(getLine(doc, end.line).text.slice(0, end.ch)))
              indentLine(cm, range.head.line, "smart");
          }
        }
      }
      ensureCursorVisible(cm);
      cm.curOp.updateInput = updateInput;
      cm.curOp.typing = true;

      // Don't leave long text in the textarea, since it makes further polling slow
      if (text.length > 1000 || text.indexOf("\n") > -1) input.value = cm.display.prevInput = "";
      else cm.display.prevInput = text;
      if (withOp) endOperation(cm);
      cm.state.pasteIncoming = cm.state.cutIncoming = false;
      return true;
    }

    // Reset the input to correspond to the selection (or to be empty,
    // when not typing and nothing is selected)
    function resetInput(cm, typing) {
      var minimal, selected, doc = cm.doc;
      if (cm.somethingSelected()) {
        cm.display.prevInput = "";
        var range = doc.sel.primary();
        minimal = hasCopyEvent &&
          (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);
        var content = minimal ? "-" : selected || cm.getSelection();
        cm.display.input.value = content;
        if (cm.state.focused) selectInput(cm.display.input);
        if (ie && ie_version >= 9) cm.display.inputHasSelection = content;
      } else if (!typing) {
        cm.display.prevInput = cm.display.input.value = "";
        if (ie && ie_version >= 9) cm.display.inputHasSelection = null;
      }
      cm.display.inaccurateSelection = minimal;
    }

    function focusInput(cm) {
      if (cm.options.readOnly != "nocursor" && (!mobile || activeElt() != cm.display.input))
        cm.display.input.focus();
    }

    function ensureFocus(cm) {
      if (!cm.state.focused) { focusInput(cm); onFocus(cm); }
    }

    function isReadOnly(cm) {
      return cm.options.readOnly || cm.doc.cantEdit;
    }

    // EVENT HANDLERS

    // Attach the necessary event handlers when initializing the editor
    function registerEventHandlers(cm) {
      var d = cm.display;
      on(d.scroller, "mousedown", operation(cm, onMouseDown));
      // Older IE's will not fire a second mousedown for a double click
      if (ie && ie_version < 11)
        on(d.scroller, "dblclick", operation(cm, function(e) {
          if (signalDOMEvent(cm, e)) return;
          var pos = posFromMouse(cm, e);
          if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;
          e_preventDefault(e);
          var word = findWordAt(cm, pos);
          extendSelection(cm.doc, word.anchor, word.head);
        }));
      else
        on(d.scroller, "dblclick", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });
      // Prevent normal selection in the editor (we handle our own)
      on(d.lineSpace, "selectstart", function(e) {
        if (!eventInWidget(d, e)) e_preventDefault(e);
      });
      // Some browsers fire contextmenu *after* opening the menu, at
      // which point we can't mess with it anymore. Context menu is
      // handled in onMouseDown for these browsers.
      if (!captureRightClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});

      // Sync scrolling between fake scrollbars and real scrollable
      // area, ensure viewport is updated when scrolling.
      on(d.scroller, "scroll", function() {
        if (d.scroller.clientHeight) {
          setScrollTop(cm, d.scroller.scrollTop);
          setScrollLeft(cm, d.scroller.scrollLeft, true);
          signal(cm, "scroll", cm);
        }
      });
      on(d.scrollbarV, "scroll", function() {
        if (d.scroller.clientHeight) setScrollTop(cm, d.scrollbarV.scrollTop);
      });
      on(d.scrollbarH, "scroll", function() {
        if (d.scroller.clientHeight) setScrollLeft(cm, d.scrollbarH.scrollLeft);
      });

      // Listen to wheel events in order to try and update the viewport on time.
      on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});
      on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});

      // Prevent clicks in the scrollbars from killing focus
      function reFocus() { if (cm.state.focused) setTimeout(bind(focusInput, cm), 0); }
      on(d.scrollbarH, "mousedown", reFocus);
      on(d.scrollbarV, "mousedown", reFocus);
      // Prevent wrapper from ever scrolling
      on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

      on(d.input, "keyup", function(e) { onKeyUp.call(cm, e); });
      on(d.input, "input", function() {
        if (ie && ie_version >= 9 && cm.display.inputHasSelection) cm.display.inputHasSelection = null;
        fastPoll(cm);
      });
      on(d.input, "keydown", operation(cm, onKeyDown));
      on(d.input, "keypress", operation(cm, onKeyPress));
      on(d.input, "focus", bind(onFocus, cm));
      on(d.input, "blur", bind(onBlur, cm));

      function drag_(e) {
        if (!signalDOMEvent(cm, e)) e_stop(e);
      }
      if (cm.options.dragDrop) {
        on(d.scroller, "dragstart", function(e){onDragStart(cm, e);});
        on(d.scroller, "dragenter", drag_);
        on(d.scroller, "dragover", drag_);
        on(d.scroller, "drop", operation(cm, onDrop));
      }
      on(d.scroller, "paste", function(e) {
        if (eventInWidget(d, e)) return;
        cm.state.pasteIncoming = true;
        focusInput(cm);
        fastPoll(cm);
      });
      on(d.input, "paste", function() {
        // Workaround for webkit bug https://bugs.webkit.org/show_bug.cgi?id=90206
        // Add a char to the end of textarea before paste occur so that
        // selection doesn't span to the end of textarea.
        if (webkit && !cm.state.fakedLastChar && !(new Date - cm.state.lastMiddleDown < 200)) {
          var start = d.input.selectionStart, end = d.input.selectionEnd;
          d.input.value += "$";
          // The selection end needs to be set before the start, otherwise there
          // can be an intermediate non-empty selection between the two, which
          // can override the middle-click paste buffer on linux and cause the
          // wrong thing to get pasted.
          d.input.selectionEnd = end;
          d.input.selectionStart = start;
          cm.state.fakedLastChar = true;
        }
        cm.state.pasteIncoming = true;
        fastPoll(cm);
      });

      function prepareCopyCut(e) {
        if (cm.somethingSelected()) {
          lastCopied = cm.getSelections();
          if (d.inaccurateSelection) {
            d.prevInput = "";
            d.inaccurateSelection = false;
            d.input.value = lastCopied.join("\n");
            selectInput(d.input);
          }
        } else {
          var text = [], ranges = [];
          for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
            var line = cm.doc.sel.ranges[i].head.line;
            var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
            ranges.push(lineRange);
            text.push(cm.getRange(lineRange.anchor, lineRange.head));
          }
          if (e.type == "cut") {
            cm.setSelections(ranges, null, sel_dontScroll);
          } else {
            d.prevInput = "";
            d.input.value = text.join("\n");
            selectInput(d.input);
          }
          lastCopied = text;
        }
        if (e.type == "cut") cm.state.cutIncoming = true;
      }
      on(d.input, "cut", prepareCopyCut);
      on(d.input, "copy", prepareCopyCut);

      // Needed to handle Tab key in KHTML
      if (khtml) on(d.sizer, "mouseup", function() {
        if (activeElt() == d.input) d.input.blur();
        focusInput(cm);
      });
    }

    // Called when the window resizes
    function onResize(cm) {
      // Might be a text scaling operation, clear size caches.
      var d = cm.display;
      d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
      cm.setSize();
    }

    // MOUSE EVENTS

    // Return true when the given mouse event happened in a widget
    function eventInWidget(display, e) {
      for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
        if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover) return true;
      }
    }

    // Given a mouse event, find the corresponding position. If liberal
    // is false, it checks whether a gutter or scrollbar was clicked,
    // and returns null if it was. forRect is used by rectangular
    // selections, and tries to estimate a character position even for
    // coordinates beyond the right of the text.
    function posFromMouse(cm, e, liberal, forRect) {
      var display = cm.display;
      if (!liberal) {
        var target = e_target(e);
        if (target == display.scrollbarH || target == display.scrollbarV ||
            target == display.scrollbarFiller || target == display.gutterFiller) return null;
      }
      var x, y, space = display.lineSpace.getBoundingClientRect();
      // Fails unpredictably on IE[67] when mouse is dragged around quickly.
      try { x = e.clientX - space.left; y = e.clientY - space.top; }
      catch (e) { return null; }
      var coords = coordsChar(cm, x, y), line;
      if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
        var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
        coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
      }
      return coords;
    }

    // A mouse down can be a single click, double click, triple click,
    // start of selection drag, start of text drag, new cursor
    // (ctrl-click), rectangle drag (alt-drag), or xwin
    // middle-click-paste. Or it might be a click on something we should
    // not interfere with, such as a scrollbar or widget.
    function onMouseDown(e) {
      if (signalDOMEvent(this, e)) return;
      var cm = this, display = cm.display;
      display.shift = e.shiftKey;

      if (eventInWidget(display, e)) {
        if (!webkit) {
          // Briefly turn off draggability, to allow widgets to do
          // normal dragging things.
          display.scroller.draggable = false;
          setTimeout(function(){display.scroller.draggable = true;}, 100);
        }
        return;
      }
      if (clickInGutter(cm, e)) return;
      var start = posFromMouse(cm, e);
      window.focus();

      switch (e_button(e)) {
      case 1:
        if (start)
          leftButtonDown(cm, e, start);
        else if (e_target(e) == display.scroller)
          e_preventDefault(e);
        break;
      case 2:
        if (webkit) cm.state.lastMiddleDown = +new Date;
        if (start) extendSelection(cm.doc, start);
        setTimeout(bind(focusInput, cm), 20);
        e_preventDefault(e);
        break;
      case 3:
        if (captureRightClick) onContextMenu(cm, e);
        break;
      }
    }

    var lastClick, lastDoubleClick;
    function leftButtonDown(cm, e, start) {
      setTimeout(bind(ensureFocus, cm), 0);

      var now = +new Date, type;
      if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
        type = "triple";
      } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
        type = "double";
        lastDoubleClick = {time: now, pos: start};
      } else {
        type = "single";
        lastClick = {time: now, pos: start};
      }

      var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey;
      if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) &&
          type == "single" && sel.contains(start) > -1 && sel.somethingSelected())
        leftButtonStartDrag(cm, e, start, modifier);
      else
        leftButtonSelect(cm, e, start, type, modifier);
    }

    // Start a text drag. When it ends, see if any dragging actually
    // happen, and treat as a click if it didn't.
    function leftButtonStartDrag(cm, e, start, modifier) {
      var display = cm.display;
      var dragEnd = operation(cm, function(e2) {
        if (webkit) display.scroller.draggable = false;
        cm.state.draggingText = false;
        off(document, "mouseup", dragEnd);
        off(display.scroller, "drop", dragEnd);
        if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
          e_preventDefault(e2);
          if (!modifier)
            extendSelection(cm.doc, start);
          focusInput(cm);
          // Work around unexplainable focus problem in IE9 (#2127)
          if (ie && ie_version == 9)
            setTimeout(function() {document.body.focus(); focusInput(cm);}, 20);
        }
      });
      // Let the drag handler handle this.
      if (webkit) display.scroller.draggable = true;
      cm.state.draggingText = dragEnd;
      // IE's approach to draggable
      if (display.scroller.dragDrop) display.scroller.dragDrop();
      on(document, "mouseup", dragEnd);
      on(display.scroller, "drop", dragEnd);
    }

    // Normal selection, as opposed to text dragging.
    function leftButtonSelect(cm, e, start, type, addNew) {
      var display = cm.display, doc = cm.doc;
      e_preventDefault(e);

      var ourRange, ourIndex, startSel = doc.sel;
      if (addNew && !e.shiftKey) {
        ourIndex = doc.sel.contains(start);
        if (ourIndex > -1)
          ourRange = doc.sel.ranges[ourIndex];
        else
          ourRange = new Range(start, start);
      } else {
        ourRange = doc.sel.primary();
      }

      if (e.altKey) {
        type = "rect";
        if (!addNew) ourRange = new Range(start, start);
        start = posFromMouse(cm, e, true, true);
        ourIndex = -1;
      } else if (type == "double") {
        var word = findWordAt(cm, start);
        if (cm.display.shift || doc.extend)
          ourRange = extendRange(doc, ourRange, word.anchor, word.head);
        else
          ourRange = word;
      } else if (type == "triple") {
        var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
        if (cm.display.shift || doc.extend)
          ourRange = extendRange(doc, ourRange, line.anchor, line.head);
        else
          ourRange = line;
      } else {
        ourRange = extendRange(doc, ourRange, start);
      }

      if (!addNew) {
        ourIndex = 0;
        setSelection(doc, new Selection([ourRange], 0), sel_mouse);
        startSel = doc.sel;
      } else if (ourIndex > -1) {
        replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
      } else {
        ourIndex = doc.sel.ranges.length;
        setSelection(doc, normalizeSelection(doc.sel.ranges.concat([ourRange]), ourIndex),
                     {scroll: false, origin: "*mouse"});
      }

      var lastPos = start;
      function extendTo(pos) {
        if (cmp(lastPos, pos) == 0) return;
        lastPos = pos;

        if (type == "rect") {
          var ranges = [], tabSize = cm.options.tabSize;
          var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
          var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
          var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
          for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
               line <= end; line++) {
            var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
            if (left == right)
              ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
            else if (text.length > leftPos)
              ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
          }
          if (!ranges.length) ranges.push(new Range(start, start));
          setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                       {origin: "*mouse", scroll: false});
          cm.scrollIntoView(pos);
        } else {
          var oldRange = ourRange;
          var anchor = oldRange.anchor, head = pos;
          if (type != "single") {
            if (type == "double")
              var range = findWordAt(cm, pos);
            else
              var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));
            if (cmp(range.anchor, anchor) > 0) {
              head = range.head;
              anchor = minPos(oldRange.from(), range.anchor);
            } else {
              head = range.anchor;
              anchor = maxPos(oldRange.to(), range.head);
            }
          }
          var ranges = startSel.ranges.slice(0);
          ranges[ourIndex] = new Range(clipPos(doc, anchor), head);
          setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);
        }
      }

      var editorSize = display.wrapper.getBoundingClientRect();
      // Used to ensure timeout re-tries don't fire when another extend
      // happened in the meantime (clearTimeout isn't reliable -- at
      // least on Chrome, the timeouts still happen even when cleared,
      // if the clear happens after their scheduled firing time).
      var counter = 0;

      function extend(e) {
        var curCount = ++counter;
        var cur = posFromMouse(cm, e, true, type == "rect");
        if (!cur) return;
        if (cmp(cur, lastPos) != 0) {
          ensureFocus(cm);
          extendTo(cur);
          var visible = visibleLines(display, doc);
          if (cur.line >= visible.to || cur.line < visible.from)
            setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);
        } else {
          var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
          if (outside) setTimeout(operation(cm, function() {
            if (counter != curCount) return;
            display.scroller.scrollTop += outside;
            extend(e);
          }), 50);
        }
      }

      function done(e) {
        counter = Infinity;
        e_preventDefault(e);
        focusInput(cm);
        off(document, "mousemove", move);
        off(document, "mouseup", up);
        doc.history.lastSelOrigin = null;
      }

      var move = operation(cm, function(e) {
        if (!e_button(e)) done(e);
        else extend(e);
      });
      var up = operation(cm, done);
      on(document, "mousemove", move);
      on(document, "mouseup", up);
    }

    // Determines whether an event happened in the gutter, and fires the
    // handlers for the corresponding event.
    function gutterEvent(cm, e, type, prevent, signalfn) {
      try { var mX = e.clientX, mY = e.clientY; }
      catch(e) { return false; }
      if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;
      if (prevent) e_preventDefault(e);

      var display = cm.display;
      var lineBox = display.lineDiv.getBoundingClientRect();

      if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
      mY -= lineBox.top - display.viewOffset;

      for (var i = 0; i < cm.options.gutters.length; ++i) {
        var g = display.gutters.childNodes[i];
        if (g && g.getBoundingClientRect().right >= mX) {
          var line = lineAtHeight(cm.doc, mY);
          var gutter = cm.options.gutters[i];
          signalfn(cm, type, cm, line, gutter, e);
          return e_defaultPrevented(e);
        }
      }
    }

    function clickInGutter(cm, e) {
      return gutterEvent(cm, e, "gutterClick", true, signalLater);
    }

    // Kludge to work around strange IE behavior where it'll sometimes
    // re-fire a series of drag-related events right after the drop (#1551)
    var lastDrop = 0;

    function onDrop(e) {
      var cm = this;
      if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
        return;
      e_preventDefault(e);
      if (ie) lastDrop = +new Date;
      var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
      if (!pos || isReadOnly(cm)) return;
      // Might be a file drop, in which case we simply extract the text
      // and insert it.
      if (files && files.length && window.FileReader && window.File) {
        var n = files.length, text = Array(n), read = 0;
        var loadFile = function(file, i) {
          var reader = new FileReader;
          reader.onload = operation(cm, function() {
            text[i] = reader.result;
            if (++read == n) {
              pos = clipPos(cm.doc, pos);
              var change = {from: pos, to: pos, text: splitLines(text.join("\n")), origin: "paste"};
              makeChange(cm.doc, change);
              setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
            }
          });
          reader.readAsText(file);
        };
        for (var i = 0; i < n; ++i) loadFile(files[i], i);
      } else { // Normal drop
        // Don't do a replace if the drop happened inside of the selected text.
        if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
          cm.state.draggingText(e);
          // Ensure the editor is re-focused
          setTimeout(bind(focusInput, cm), 20);
          return;
        }
        try {
          var text = e.dataTransfer.getData("Text");
          if (text) {
            if (cm.state.draggingText && !(mac ? e.metaKey : e.ctrlKey))
              var selected = cm.listSelections();
            setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
            if (selected) for (var i = 0; i < selected.length; ++i)
              replaceRange(cm.doc, "", selected[i].anchor, selected[i].head, "drag");
            cm.replaceSelection(text, "around", "paste");
            focusInput(cm);
          }
        }
        catch(e){}
      }
    }

    function onDragStart(cm, e) {
      if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }
      if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;

      e.dataTransfer.setData("Text", cm.getSelection());

      // Use dummy image instead of default browsers image.
      // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
      if (e.dataTransfer.setDragImage && !safari) {
        var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
        img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
        if (presto) {
          img.width = img.height = 1;
          cm.display.wrapper.appendChild(img);
          // Force a relayout, or Opera won't use our image for some obscure reason
          img._top = img.offsetTop;
        }
        e.dataTransfer.setDragImage(img, 0, 0);
        if (presto) img.parentNode.removeChild(img);
      }
    }

    // SCROLL EVENTS

    // Sync the scrollable area and scrollbars, ensure the viewport
    // covers the visible area.
    function setScrollTop(cm, val) {
      if (Math.abs(cm.doc.scrollTop - val) < 2) return;
      cm.doc.scrollTop = val;
      if (!gecko) updateDisplaySimple(cm, {top: val});
      if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;
      if (cm.display.scrollbarV.scrollTop != val) cm.display.scrollbarV.scrollTop = val;
      if (gecko) updateDisplaySimple(cm);
      startWorker(cm, 100);
    }
    // Sync scroller and scrollbar, ensure the gutter elements are
    // aligned.
    function setScrollLeft(cm, val, isScroller) {
      if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;
      val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
      cm.doc.scrollLeft = val;
      alignHorizontally(cm);
      if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;
      if (cm.display.scrollbarH.scrollLeft != val) cm.display.scrollbarH.scrollLeft = val;
    }

    // Since the delta values reported on mouse wheel events are
    // unstandardized between browsers and even browser versions, and
    // generally horribly unpredictable, this code starts by measuring
    // the scroll effect that the first few mouse wheel events have,
    // and, from that, detects the way it can convert deltas to pixel
    // offsets afterwards.
    //
    // The reason we want to know the amount a wheel event will scroll
    // is that it gives us a chance to update the display before the
    // actual scrolling happens, reducing flickering.

    var wheelSamples = 0, wheelPixelsPerUnit = null;
    // Fill in a browser-detected starting value on browsers where we
    // know one. These don't have to be accurate -- the result of them
    // being wrong would just be a slight flicker on the first wheel
    // scroll (if it is large enough).
    if (ie) wheelPixelsPerUnit = -.53;
    else if (gecko) wheelPixelsPerUnit = 15;
    else if (chrome) wheelPixelsPerUnit = -.7;
    else if (safari) wheelPixelsPerUnit = -1/3;

    function onScrollWheel(cm, e) {
      var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
      if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;
      if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;
      else if (dy == null) dy = e.wheelDelta;

      var display = cm.display, scroll = display.scroller;
      // Quit if there's nothing to scroll here
      if (!(dx && scroll.scrollWidth > scroll.clientWidth ||
            dy && scroll.scrollHeight > scroll.clientHeight)) return;

      // Webkit browsers on OS X abort momentum scrolls when the target
      // of the scroll event is removed from the scrollable element.
      // This hack (see related code in patchDisplay) makes sure the
      // element is kept around.
      if (dy && mac && webkit) {
        outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
          for (var i = 0; i < view.length; i++) {
            if (view[i].node == cur) {
              cm.display.currentWheelTarget = cur;
              break outer;
            }
          }
        }
      }

      // On some browsers, horizontal scrolling will cause redraws to
      // happen before the gutter has been realigned, causing it to
      // wriggle around in a most unseemly way. When we have an
      // estimated pixels/delta value, we just handle horizontal
      // scrolling entirely here. It'll be slightly off from native, but
      // better than glitching out.
      if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
        if (dy)
          setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
        setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
        e_preventDefault(e);
        display.wheelStartX = null; // Abort measurement, if in progress
        return;
      }

      // 'Project' the visible viewport to cover the area that is being
      // scrolled into view (if we know enough to estimate it).
      if (dy && wheelPixelsPerUnit != null) {
        var pixels = dy * wheelPixelsPerUnit;
        var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
        if (pixels < 0) top = Math.max(0, top + pixels - 50);
        else bot = Math.min(cm.doc.height, bot + pixels + 50);
        updateDisplaySimple(cm, {top: top, bottom: bot});
      }

      if (wheelSamples < 20) {
        if (display.wheelStartX == null) {
          display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
          display.wheelDX = dx; display.wheelDY = dy;
          setTimeout(function() {
            if (display.wheelStartX == null) return;
            var movedX = scroll.scrollLeft - display.wheelStartX;
            var movedY = scroll.scrollTop - display.wheelStartY;
            var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
              (movedX && display.wheelDX && movedX / display.wheelDX);
            display.wheelStartX = display.wheelStartY = null;
            if (!sample) return;
            wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
            ++wheelSamples;
          }, 200);
        } else {
          display.wheelDX += dx; display.wheelDY += dy;
        }
      }
    }

    // KEY EVENTS

    // Run a handler that was bound to a key.
    function doHandleBinding(cm, bound, dropShift) {
      if (typeof bound == "string") {
        bound = commands[bound];
        if (!bound) return false;
      }
      // Ensure previous input has been read, so that the handler sees a
      // consistent view of the document
      if (cm.display.pollingFast && readInput(cm)) cm.display.pollingFast = false;
      var prevShift = cm.display.shift, done = false;
      try {
        if (isReadOnly(cm)) cm.state.suppressEdits = true;
        if (dropShift) cm.display.shift = false;
        done = bound(cm) != Pass;
      } finally {
        cm.display.shift = prevShift;
        cm.state.suppressEdits = false;
      }
      return done;
    }

    // Collect the currently active keymaps.
    function allKeyMaps(cm) {
      var maps = cm.state.keyMaps.slice(0);
      if (cm.options.extraKeys) maps.push(cm.options.extraKeys);
      maps.push(cm.options.keyMap);
      return maps;
    }

    var maybeTransition;
    // Handle a key from the keydown event.
    function handleKeyBinding(cm, e) {
      // Handle automatic keymap transitions
      var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;
      clearTimeout(maybeTransition);
      if (next && !isModifierKey(e)) maybeTransition = setTimeout(function() {
        if (getKeyMap(cm.options.keyMap) == startMap) {
          cm.options.keyMap = (next.call ? next.call(null, cm) : next);
          keyMapChanged(cm);
        }
      }, 50);

      var name = keyName(e, true), handled = false;
      if (!name) return false;
      var keymaps = allKeyMaps(cm);

      if (e.shiftKey) {
        // First try to resolve full name (including 'Shift-'). Failing
        // that, see if there is a cursor-motion command (starting with
        // 'go') bound to the keyname without 'Shift-'.
        handled = lookupKey("Shift-" + name, keymaps, function(b) {return doHandleBinding(cm, b, true);})
               || lookupKey(name, keymaps, function(b) {
                    if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                      return doHandleBinding(cm, b);
                  });
      } else {
        handled = lookupKey(name, keymaps, function(b) { return doHandleBinding(cm, b); });
      }

      if (handled) {
        e_preventDefault(e);
        restartBlink(cm);
        signalLater(cm, "keyHandled", cm, name, e);
      }
      return handled;
    }

    // Handle a key from the keypress event
    function handleCharBinding(cm, e, ch) {
      var handled = lookupKey("'" + ch + "'", allKeyMaps(cm),
                              function(b) { return doHandleBinding(cm, b, true); });
      if (handled) {
        e_preventDefault(e);
        restartBlink(cm);
        signalLater(cm, "keyHandled", cm, "'" + ch + "'", e);
      }
      return handled;
    }

    var lastStoppedKey = null;
    function onKeyDown(e) {
      var cm = this;
      ensureFocus(cm);
      if (signalDOMEvent(cm, e)) return;
      // IE does strange things with escape.
      if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;
      var code = e.keyCode;
      cm.display.shift = code == 16 || e.shiftKey;
      var handled = handleKeyBinding(cm, e);
      if (presto) {
        lastStoppedKey = handled ? code : null;
        // Opera has no cut event... we try to at least catch the key combo
        if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
          cm.replaceSelection("", null, "cut");
      }

      // Turn mouse into crosshair when Alt is held on Mac.
      if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
        showCrossHair(cm);
    }

    function showCrossHair(cm) {
      var lineDiv = cm.display.lineDiv;
      addClass(lineDiv, "CodeMirror-crosshair");

      function up(e) {
        if (e.keyCode == 18 || !e.altKey) {
          rmClass(lineDiv, "CodeMirror-crosshair");
          off(document, "keyup", up);
          off(document, "mouseover", up);
        }
      }
      on(document, "keyup", up);
      on(document, "mouseover", up);
    }

    function onKeyUp(e) {
      if (e.keyCode == 16) this.doc.sel.shift = false;
      signalDOMEvent(this, e);
    }

    function onKeyPress(e) {
      var cm = this;
      if (signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;
      var keyCode = e.keyCode, charCode = e.charCode;
      if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}
      if (((presto && (!e.which || e.which < 10)) || khtml) && handleKeyBinding(cm, e)) return;
      var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
      if (handleCharBinding(cm, e, ch)) return;
      if (ie && ie_version >= 9) cm.display.inputHasSelection = null;
      fastPoll(cm);
    }

    // FOCUS/BLUR EVENTS

    function onFocus(cm) {
      if (cm.options.readOnly == "nocursor") return;
      if (!cm.state.focused) {
        signal(cm, "focus", cm);
        cm.state.focused = true;
        addClass(cm.display.wrapper, "CodeMirror-focused");
        // The prevInput test prevents this from firing when a context
        // menu is closed (since the resetInput would kill the
        // select-all detection hack)
        if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
          resetInput(cm);
          if (webkit) setTimeout(bind(resetInput, cm, true), 0); // Issue #1730
        }
      }
      slowPoll(cm);
      restartBlink(cm);
    }
    function onBlur(cm) {
      if (cm.state.focused) {
        signal(cm, "blur", cm);
        cm.state.focused = false;
        rmClass(cm.display.wrapper, "CodeMirror-focused");
      }
      clearInterval(cm.display.blinker);
      setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);
    }

    // CONTEXT MENU HANDLING

    // To make the context menu work, we need to briefly unhide the
    // textarea (making it as unobtrusive as possible) to let the
    // right-click take effect on it.
    function onContextMenu(cm, e) {
      if (signalDOMEvent(cm, e, "contextmenu")) return;
      var display = cm.display;
      if (eventInWidget(display, e) || contextMenuInGutter(cm, e)) return;

      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
      if (!pos || presto) return; // Opera is difficult.

      // Reset the current text selection only if the click is done outside of the selection
      // and 'resetSelectionOnContextMenu' option is true.
      var reset = cm.options.resetSelectionOnContextMenu;
      if (reset && cm.doc.sel.contains(pos) == -1)
        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);

      var oldCSS = display.input.style.cssText;
      display.inputDiv.style.position = "absolute";
      display.input.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) +
        "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: " +
        (ie ? "rgba(255, 255, 255, .05)" : "transparent") +
        "; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)
      focusInput(cm);
      if (webkit) window.scrollTo(null, oldScrollY);
      resetInput(cm);
      // Adds "Select all" to context menu in FF
      if (!cm.somethingSelected()) display.input.value = display.prevInput = " ";
      display.selForContextMenu = cm.doc.sel;
      clearTimeout(display.detectingSelectAll);

      // Select-all will be greyed out if there's nothing to select, so
      // this adds a zero-width space so that we can later check whether
      // it got selected.
      function prepareSelectAllHack() {
        if (display.input.selectionStart != null) {
          var selected = cm.somethingSelected();
          var extval = display.input.value = "\u200b" + (selected ? display.input.value : "");
          display.prevInput = selected ? "" : "\u200b";
          display.input.selectionStart = 1; display.input.selectionEnd = extval.length;
          // Re-set this, in case some other handler touched the
          // selection in the meantime.
          display.selForContextMenu = cm.doc.sel;
        }
      }
      function rehide() {
        display.inputDiv.style.position = "relative";
        display.input.style.cssText = oldCSS;
        if (ie && ie_version < 9) display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;
        slowPoll(cm);

        // Try to detect the user choosing select-all
        if (display.input.selectionStart != null) {
          if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();
          var i = 0, poll = function() {
            if (display.selForContextMenu == cm.doc.sel && display.input.selectionStart == 0)
              operation(cm, commands.selectAll)(cm);
            else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);
            else resetInput(cm);
          };
          display.detectingSelectAll = setTimeout(poll, 200);
        }
      }

      if (ie && ie_version >= 9) prepareSelectAllHack();
      if (captureRightClick) {
        e_stop(e);
        var mouseup = function() {
          off(window, "mouseup", mouseup);
          setTimeout(rehide, 20);
        };
        on(window, "mouseup", mouseup);
      } else {
        setTimeout(rehide, 50);
      }
    }

    function contextMenuInGutter(cm, e) {
      if (!hasHandler(cm, "gutterContextMenu")) return false;
      return gutterEvent(cm, e, "gutterContextMenu", false, signal);
    }

    // UPDATING

    // Compute the position of the end of a change (its 'to' property
    // refers to the pre-change end).
    var changeEnd = CodeMirror.changeEnd = function(change) {
      if (!change.text) return change.to;
      return Pos(change.from.line + change.text.length - 1,
                 lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
    };

    // Adjust a position to refer to the post-change position of the
    // same text, or the end of the change if the change covers it.
    function adjustForChange(pos, change) {
      if (cmp(pos, change.from) < 0) return pos;
      if (cmp(pos, change.to) <= 0) return changeEnd(change);

      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
      if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;
      return Pos(line, ch);
    }

    function computeSelAfterChange(doc, change) {
      var out = [];
      for (var i = 0; i < doc.sel.ranges.length; i++) {
        var range = doc.sel.ranges[i];
        out.push(new Range(adjustForChange(range.anchor, change),
                           adjustForChange(range.head, change)));
      }
      return normalizeSelection(out, doc.sel.primIndex);
    }

    function offsetPos(pos, old, nw) {
      if (pos.line == old.line)
        return Pos(nw.line, pos.ch - old.ch + nw.ch);
      else
        return Pos(nw.line + (pos.line - old.line), pos.ch);
    }

    // Used by replaceSelections to allow moving the selection to the
    // start or around the replaced test. Hint may be "start" or "around".
    function computeReplacedSel(doc, changes, hint) {
      var out = [];
      var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
      for (var i = 0; i < changes.length; i++) {
        var change = changes[i];
        var from = offsetPos(change.from, oldPrev, newPrev);
        var to = offsetPos(changeEnd(change), oldPrev, newPrev);
        oldPrev = change.to;
        newPrev = to;
        if (hint == "around") {
          var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
          out[i] = new Range(inv ? to : from, inv ? from : to);
        } else {
          out[i] = new Range(from, from);
        }
      }
      return new Selection(out, doc.sel.primIndex);
    }

    // Allow "beforeChange" event handlers to influence a change
    function filterChange(doc, change, update) {
      var obj = {
        canceled: false,
        from: change.from,
        to: change.to,
        text: change.text,
        origin: change.origin,
        cancel: function() { this.canceled = true; }
      };
      if (update) obj.update = function(from, to, text, origin) {
        if (from) this.from = clipPos(doc, from);
        if (to) this.to = clipPos(doc, to);
        if (text) this.text = text;
        if (origin !== undefined) this.origin = origin;
      };
      signal(doc, "beforeChange", doc, obj);
      if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);

      if (obj.canceled) return null;
      return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};
    }

    // Apply a change to a document, and add it to the document's
    // history, and propagating it to all linked documents.
    function makeChange(doc, change, ignoreReadOnly) {
      if (doc.cm) {
        if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
        if (doc.cm.state.suppressEdits) return;
      }

      if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
        change = filterChange(doc, change, true);
        if (!change) return;
      }

      // Possibly split or suppress the update based on the presence
      // of read-only spans in its range.
      var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
      if (split) {
        for (var i = split.length - 1; i >= 0; --i)
          makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text});
      } else {
        makeChangeInner(doc, change);
      }
    }

    function makeChangeInner(doc, change) {
      if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) return;
      var selAfter = computeSelAfterChange(doc, change);
      addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

      makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
      var rebased = [];

      linkedDocs(doc, function(doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
      });
    }

    // Revert a change stored in a document's history.
    function makeChangeFromHistory(doc, type, allowSelectionOnly) {
      if (doc.cm && doc.cm.state.suppressEdits) return;

      var hist = doc.history, event, selAfter = doc.sel;
      var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

      // Verify that there is a useable event (so that ctrl-z won't
      // needlessly clear selection events)
      for (var i = 0; i < source.length; i++) {
        event = source[i];
        if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
          break;
      }
      if (i == source.length) return;
      hist.lastOrigin = hist.lastSelOrigin = null;

      for (;;) {
        event = source.pop();
        if (event.ranges) {
          pushSelectionToHistory(event, dest);
          if (allowSelectionOnly && !event.equals(doc.sel)) {
            setSelection(doc, event, {clearRedo: false});
            return;
          }
          selAfter = event;
        }
        else break;
      }

      // Build up a reverse change object to add to the opposite history
      // stack (redo when undoing, and vice versa).
      var antiChanges = [];
      pushSelectionToHistory(selAfter, dest);
      dest.push({changes: antiChanges, generation: hist.generation});
      hist.generation = event.generation || ++hist.maxGeneration;

      var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

      for (var i = event.changes.length - 1; i >= 0; --i) {
        var change = event.changes[i];
        change.origin = type;
        if (filter && !filterChange(doc, change, false)) {
          source.length = 0;
          return;
        }

        antiChanges.push(historyChangeFromChange(doc, change));

        var after = i ? computeSelAfterChange(doc, change) : lst(source);
        makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
        if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});
        var rebased = [];

        // Propagate to the linked documents
        linkedDocs(doc, function(doc, sharedHist) {
          if (!sharedHist && indexOf(rebased, doc.history) == -1) {
            rebaseHist(doc.history, change);
            rebased.push(doc.history);
          }
          makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
        });
      }
    }

    // Sub-views need their line numbers shifted when text is added
    // above or below them in the parent document.
    function shiftDoc(doc, distance) {
      if (distance == 0) return;
      doc.first += distance;
      doc.sel = new Selection(map(doc.sel.ranges, function(range) {
        return new Range(Pos(range.anchor.line + distance, range.anchor.ch),
                         Pos(range.head.line + distance, range.head.ch));
      }), doc.sel.primIndex);
      if (doc.cm) {
        regChange(doc.cm, doc.first, doc.first - distance, distance);
        for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
          regLineChange(doc.cm, l, "gutter");
      }
    }

    // More lower-level change function, handling only a single document
    // (not linked ones).
    function makeChangeSingleDoc(doc, change, selAfter, spans) {
      if (doc.cm && !doc.cm.curOp)
        return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);

      if (change.to.line < doc.first) {
        shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
        return;
      }
      if (change.from.line > doc.lastLine()) return;

      // Clip the change to the size of this doc
      if (change.from.line < doc.first) {
        var shift = change.text.length - 1 - (doc.first - change.from.line);
        shiftDoc(doc, shift);
        change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                  text: [lst(change.text)], origin: change.origin};
      }
      var last = doc.lastLine();
      if (change.to.line > last) {
        change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                  text: [change.text[0]], origin: change.origin};
      }

      change.removed = getBetween(doc, change.from, change.to);

      if (!selAfter) selAfter = computeSelAfterChange(doc, change);
      if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);
      else updateDoc(doc, change, spans);
      setSelectionNoUndo(doc, selAfter, sel_dontScroll);
    }

    // Handle the interaction of a change to a document with the editor
    // that this document is part of.
    function makeChangeSingleDocInEditor(cm, change, spans) {
      var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

      var recomputeMaxLength = false, checkWidthStart = from.line;
      if (!cm.options.lineWrapping) {
        checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
        doc.iter(checkWidthStart, to.line + 1, function(line) {
          if (line == display.maxLine) {
            recomputeMaxLength = true;
            return true;
          }
        });
      }

      if (doc.sel.contains(change.from, change.to) > -1)
        signalCursorActivity(cm);

      updateDoc(doc, change, spans, estimateHeight(cm));

      if (!cm.options.lineWrapping) {
        doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
          var len = lineLength(line);
          if (len > display.maxLineLength) {
            display.maxLine = line;
            display.maxLineLength = len;
            display.maxLineChanged = true;
            recomputeMaxLength = false;
          }
        });
        if (recomputeMaxLength) cm.curOp.updateMaxLine = true;
      }

      // Adjust frontier, schedule worker
      doc.frontier = Math.min(doc.frontier, from.line);
      startWorker(cm, 400);

      var lendiff = change.text.length - (to.line - from.line) - 1;
      // Remember that these lines changed, for updating the display
      if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
        regLineChange(cm, from.line, "text");
      else
        regChange(cm, from.line, to.line + 1, lendiff);

      var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
      if (changeHandler || changesHandler) {
        var obj = {
          from: from, to: to,
          text: change.text,
          removed: change.removed,
          origin: change.origin
        };
        if (changeHandler) signalLater(cm, "change", cm, obj);
        if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
      }
      cm.display.selForContextMenu = null;
    }

    function replaceRange(doc, code, from, to, origin) {
      if (!to) to = from;
      if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }
      if (typeof code == "string") code = splitLines(code);
      makeChange(doc, {from: from, to: to, text: code, origin: origin});
    }

    // SCROLLING THINGS INTO VIEW

    // If an editor sits on the top or bottom of the window, partially
    // scrolled out of view, this ensures that the cursor is visible.
    function maybeScrollWindow(cm, coords) {
      var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
      if (coords.top + box.top < 0) doScroll = true;
      else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;
      if (doScroll != null && !phantom) {
        var scrollNode = elt("div", "\u200b", null, "position: absolute; top: " +
                             (coords.top - display.viewOffset - paddingTop(cm.display)) + "px; height: " +
                             (coords.bottom - coords.top + scrollerCutOff) + "px; left: " +
                             coords.left + "px; width: 2px;");
        cm.display.lineSpace.appendChild(scrollNode);
        scrollNode.scrollIntoView(doScroll);
        cm.display.lineSpace.removeChild(scrollNode);
      }
    }

    // Scroll a given position into view (immediately), verifying that
    // it actually became visible (as line heights are accurately
    // measured, the position of something may 'drift' during drawing).
    function scrollPosIntoView(cm, pos, end, margin) {
      if (margin == null) margin = 0;
      for (;;) {
        var changed = false, coords = cursorCoords(cm, pos);
        var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
        var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),
                                           Math.min(coords.top, endCoords.top) - margin,
                                           Math.max(coords.left, endCoords.left),
                                           Math.max(coords.bottom, endCoords.bottom) + margin);
        var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
        if (scrollPos.scrollTop != null) {
          setScrollTop(cm, scrollPos.scrollTop);
          if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;
        }
        if (scrollPos.scrollLeft != null) {
          setScrollLeft(cm, scrollPos.scrollLeft);
          if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;
        }
        if (!changed) return coords;
      }
    }

    // Scroll a given set of coordinates into view (immediately).
    function scrollIntoView(cm, x1, y1, x2, y2) {
      var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
      if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);
      if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);
    }

    // Calculate a new scroll position needed to scroll the given
    // rectangle into view. Returns an object with scrollTop and
    // scrollLeft properties. When these are undefined, the
    // vertical/horizontal position does not need to be adjusted.
    function calculateScrollPos(cm, x1, y1, x2, y2) {
      var display = cm.display, snapMargin = textHeight(cm.display);
      if (y1 < 0) y1 = 0;
      var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
      var screen = display.scroller.clientHeight - scrollerCutOff, result = {};
      if (y2 - y1 > screen) y2 = y1 + screen;
      var docBottom = cm.doc.height + paddingVert(display);
      var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
      if (y1 < screentop) {
        result.scrollTop = atTop ? 0 : y1;
      } else if (y2 > screentop + screen) {
        var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
        if (newTop != screentop) result.scrollTop = newTop;
      }

      var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
      var screenw = display.scroller.clientWidth - scrollerCutOff - display.gutters.offsetWidth;
      var tooWide = x2 - x1 > screenw;
      if (tooWide) x2 = y1 + screen;
      if (x1 < 10)
        result.scrollLeft = 0;
      else if (x1 < screenleft)
        result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));
      else if (x2 > screenw + screenleft - 3)
        result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;

      return result;
    }

    // Store a relative adjustment to the scroll position in the current
    // operation (to be applied when the operation finishes).
    function addToScrollPos(cm, left, top) {
      if (left != null || top != null) resolveScrollToPos(cm);
      if (left != null)
        cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;
      if (top != null)
        cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
    }

    // Make sure that at the end of the operation the current cursor is
    // shown.
    function ensureCursorVisible(cm) {
      resolveScrollToPos(cm);
      var cur = cm.getCursor(), from = cur, to = cur;
      if (!cm.options.lineWrapping) {
        from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
        to = Pos(cur.line, cur.ch + 1);
      }
      cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};
    }

    // When an operation has its scrollToPos property set, and another
    // scroll action is applied before the end of the operation, this
    // 'simulates' scrolling that position into view in a cheap way, so
    // that the effect of intermediate scroll commands is not ignored.
    function resolveScrollToPos(cm) {
      var range = cm.curOp.scrollToPos;
      if (range) {
        cm.curOp.scrollToPos = null;
        var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
        var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),
                                      Math.min(from.top, to.top) - range.margin,
                                      Math.max(from.right, to.right),
                                      Math.max(from.bottom, to.bottom) + range.margin);
        cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
      }
    }

    // API UTILITIES

    // Indent the given line. The how parameter can be "smart",
    // "add"/null, "subtract", or "prev". When aggressive is false
    // (typically set to true for forced single-line indents), empty
    // lines are not indented, and places where the mode returns Pass
    // are left alone.
    function indentLine(cm, n, how, aggressive) {
      var doc = cm.doc, state;
      if (how == null) how = "add";
      if (how == "smart") {
        // Fall back to "prev" when the mode doesn't have an indentation
        // method.
        if (!doc.mode.indent) how = "prev";
        else state = getStateBefore(cm, n);
      }

      var tabSize = cm.options.tabSize;
      var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
      if (line.stateAfter) line.stateAfter = null;
      var curSpaceString = line.text.match(/^\s*/)[0], indentation;
      if (!aggressive && !/\S/.test(line.text)) {
        indentation = 0;
        how = "not";
      } else if (how == "smart") {
        indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
        if (indentation == Pass || indentation > 150) {
          if (!aggressive) return;
          how = "prev";
        }
      }
      if (how == "prev") {
        if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);
        else indentation = 0;
      } else if (how == "add") {
        indentation = curSpace + cm.options.indentUnit;
      } else if (how == "subtract") {
        indentation = curSpace - cm.options.indentUnit;
      } else if (typeof how == "number") {
        indentation = curSpace + how;
      }
      indentation = Math.max(0, indentation);

      var indentString = "", pos = 0;
      if (cm.options.indentWithTabs)
        for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";}
      if (pos < indentation) indentString += spaceStr(indentation - pos);

      if (indentString != curSpaceString) {
        replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
      } else {
        // Ensure that, if the cursor was in the whitespace at the start
        // of the line, it is moved to the end of that space.
        for (var i = 0; i < doc.sel.ranges.length; i++) {
          var range = doc.sel.ranges[i];
          if (range.head.line == n && range.head.ch < curSpaceString.length) {
            var pos = Pos(n, curSpaceString.length);
            replaceOneSelection(doc, i, new Range(pos, pos));
            break;
          }
        }
      }
      line.stateAfter = null;
    }

    // Utility for applying a change to a line by handle or number,
    // returning the number and optionally registering the line as
    // changed.
    function changeLine(doc, handle, changeType, op) {
      var no = handle, line = handle;
      if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));
      else no = lineNo(handle);
      if (no == null) return null;
      if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);
      return line;
    }

    // Helper for deleting text near the selection(s), used to implement
    // backspace, delete, and similar functionality.
    function deleteNearSelection(cm, compute) {
      var ranges = cm.doc.sel.ranges, kill = [];
      // Build up a set of ranges to kill first, merging overlapping
      // ranges.
      for (var i = 0; i < ranges.length; i++) {
        var toKill = compute(ranges[i]);
        while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
          var replaced = kill.pop();
          if (cmp(replaced.from, toKill.from) < 0) {
            toKill.from = replaced.from;
            break;
          }
        }
        kill.push(toKill);
      }
      // Next, remove those actual ranges.
      runInOp(cm, function() {
        for (var i = kill.length - 1; i >= 0; i--)
          replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
        ensureCursorVisible(cm);
      });
    }

    // Used for horizontal relative motion. Dir is -1 or 1 (left or
    // right), unit can be "char", "column" (like char, but doesn't
    // cross line boundaries), "word" (across next word), or "group" (to
    // the start of next group of word or non-word-non-whitespace
    // chars). The visually param controls whether, in right-to-left
    // text, direction 1 means to move towards the next index in the
    // string, or towards the character to the right of the current
    // position. The resulting position will have a hitSide=true
    // property if it reached the end of the document.
    function findPosH(doc, pos, dir, unit, visually) {
      var line = pos.line, ch = pos.ch, origDir = dir;
      var lineObj = getLine(doc, line);
      var possible = true;
      function findNextLine() {
        var l = line + dir;
        if (l < doc.first || l >= doc.first + doc.size) return (possible = false);
        line = l;
        return lineObj = getLine(doc, l);
      }
      function moveOnce(boundToLine) {
        var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
        if (next == null) {
          if (!boundToLine && findNextLine()) {
            if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
            else ch = dir < 0 ? lineObj.text.length : 0;
          } else return (possible = false);
        } else ch = next;
        return true;
      }

      if (unit == "char") moveOnce();
      else if (unit == "column") moveOnce(true);
      else if (unit == "word" || unit == "group") {
        var sawType = null, group = unit == "group";
        var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
        for (var first = true;; first = false) {
          if (dir < 0 && !moveOnce(!first)) break;
          var cur = lineObj.text.charAt(ch) || "\n";
          var type = isWordChar(cur, helper) ? "w"
            : group && cur == "\n" ? "n"
            : !group || /\s/.test(cur) ? null
            : "p";
          if (group && !first && !type) type = "s";
          if (sawType && sawType != type) {
            if (dir < 0) {dir = 1; moveOnce();}
            break;
          }

          if (type) sawType = type;
          if (dir > 0 && !moveOnce(!first)) break;
        }
      }
      var result = skipAtomic(doc, Pos(line, ch), origDir, true);
      if (!possible) result.hitSide = true;
      return result;
    }

    // For relative vertical movement. Dir may be -1 or 1. Unit can be
    // "page" or "line". The resulting position will have a hitSide=true
    // property if it reached the end of the document.
    function findPosV(cm, pos, dir, unit) {
      var doc = cm.doc, x = pos.left, y;
      if (unit == "page") {
        var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
        y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));
      } else if (unit == "line") {
        y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
      }
      for (;;) {
        var target = coordsChar(cm, x, y);
        if (!target.outside) break;
        if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }
        y += dir * 5;
      }
      return target;
    }

    // Find the word at the given position (as returned by coordsChar).
    function findWordAt(cm, pos) {
      var doc = cm.doc, line = getLine(doc, pos.line).text;
      var start = pos.ch, end = pos.ch;
      if (line) {
        var helper = cm.getHelper(pos, "wordChars");
        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;
        var startChar = line.charAt(start);
        var check = isWordChar(startChar, helper)
          ? function(ch) { return isWordChar(ch, helper); }
          : /\s/.test(startChar) ? function(ch) {return /\s/.test(ch);}
          : function(ch) {return !/\s/.test(ch) && !isWordChar(ch);};
        while (start > 0 && check(line.charAt(start - 1))) --start;
        while (end < line.length && check(line.charAt(end))) ++end;
      }
      return new Range(Pos(pos.line, start), Pos(pos.line, end));
    }

    // EDITOR METHODS

    // The publicly visible API. Note that methodOp(f) means
    // 'wrap f in an operation, performed on its `this` parameter'.

    // This is not the complete set of editor methods. Most of the
    // methods defined on the Doc type are also injected into
    // CodeMirror.prototype, for backwards compatibility and
    // convenience.

    CodeMirror.prototype = {
      constructor: CodeMirror,
      focus: function(){window.focus(); focusInput(this); fastPoll(this);},

      setOption: function(option, value) {
        var options = this.options, old = options[option];
        if (options[option] == value && option != "mode") return;
        options[option] = value;
        if (optionHandlers.hasOwnProperty(option))
          operation(this, optionHandlers[option])(this, value, old);
      },

      getOption: function(option) {return this.options[option];},
      getDoc: function() {return this.doc;},

      addKeyMap: function(map, bottom) {
        this.state.keyMaps[bottom ? "push" : "unshift"](map);
      },
      removeKeyMap: function(map) {
        var maps = this.state.keyMaps;
        for (var i = 0; i < maps.length; ++i)
          if (maps[i] == map || (typeof maps[i] != "string" && maps[i].name == map)) {
            maps.splice(i, 1);
            return true;
          }
      },

      addOverlay: methodOp(function(spec, options) {
        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
        if (mode.startState) throw new Error("Overlays may not be stateful.");
        this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});
        this.state.modeGen++;
        regChange(this);
      }),
      removeOverlay: methodOp(function(spec) {
        var overlays = this.state.overlays;
        for (var i = 0; i < overlays.length; ++i) {
          var cur = overlays[i].modeSpec;
          if (cur == spec || typeof spec == "string" && cur.name == spec) {
            overlays.splice(i, 1);
            this.state.modeGen++;
            regChange(this);
            return;
          }
        }
      }),

      indentLine: methodOp(function(n, dir, aggressive) {
        if (typeof dir != "string" && typeof dir != "number") {
          if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";
          else dir = dir ? "add" : "subtract";
        }
        if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);
      }),
      indentSelection: methodOp(function(how) {
        var ranges = this.doc.sel.ranges, end = -1;
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i];
          if (!range.empty()) {
            var from = range.from(), to = range.to();
            var start = Math.max(end, from.line);
            end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
            for (var j = start; j < end; ++j)
              indentLine(this, j, how);
            var newRanges = this.doc.sel.ranges;
            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
              replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
          } else if (range.head.line > end) {
            indentLine(this, range.head.line, how, true);
            end = range.head.line;
            if (i == this.doc.sel.primIndex) ensureCursorVisible(this);
          }
        }
      }),

      // Fetch the parser token for a given character. Useful for hacks
      // that want to inspect the mode state (say, for completion).
      getTokenAt: function(pos, precise) {
        var doc = this.doc;
        pos = clipPos(doc, pos);
        var state = getStateBefore(this, pos.line, precise), mode = this.doc.mode;
        var line = getLine(doc, pos.line);
        var stream = new StringStream(line.text, this.options.tabSize);
        while (stream.pos < pos.ch && !stream.eol()) {
          stream.start = stream.pos;
          var style = readToken(mode, stream, state);
        }
        return {start: stream.start,
                end: stream.pos,
                string: stream.current(),
                type: style || null,
                state: state};
      },

      getTokenTypeAt: function(pos) {
        pos = clipPos(this.doc, pos);
        var styles = getLineStyles(this, getLine(this.doc, pos.line));
        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
        var type;
        if (ch == 0) type = styles[2];
        else for (;;) {
          var mid = (before + after) >> 1;
          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;
          else if (styles[mid * 2 + 1] < ch) before = mid + 1;
          else { type = styles[mid * 2 + 2]; break; }
        }
        var cut = type ? type.indexOf("cm-overlay ") : -1;
        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
      },

      getModeAt: function(pos) {
        var mode = this.doc.mode;
        if (!mode.innerMode) return mode;
        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
      },

      getHelper: function(pos, type) {
        return this.getHelpers(pos, type)[0];
      },

      getHelpers: function(pos, type) {
        var found = [];
        if (!helpers.hasOwnProperty(type)) return helpers;
        var help = helpers[type], mode = this.getModeAt(pos);
        if (typeof mode[type] == "string") {
          if (help[mode[type]]) found.push(help[mode[type]]);
        } else if (mode[type]) {
          for (var i = 0; i < mode[type].length; i++) {
            var val = help[mode[type][i]];
            if (val) found.push(val);
          }
        } else if (mode.helperType && help[mode.helperType]) {
          found.push(help[mode.helperType]);
        } else if (help[mode.name]) {
          found.push(help[mode.name]);
        }
        for (var i = 0; i < help._global.length; i++) {
          var cur = help._global[i];
          if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
            found.push(cur.val);
        }
        return found;
      },

      getStateAfter: function(line, precise) {
        var doc = this.doc;
        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
        return getStateBefore(this, line + 1, precise);
      },

      cursorCoords: function(start, mode) {
        var pos, range = this.doc.sel.primary();
        if (start == null) pos = range.head;
        else if (typeof start == "object") pos = clipPos(this.doc, start);
        else pos = start ? range.from() : range.to();
        return cursorCoords(this, pos, mode || "page");
      },

      charCoords: function(pos, mode) {
        return charCoords(this, clipPos(this.doc, pos), mode || "page");
      },

      coordsChar: function(coords, mode) {
        coords = fromCoordSystem(this, coords, mode || "page");
        return coordsChar(this, coords.left, coords.top);
      },

      lineAtHeight: function(height, mode) {
        height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
        return lineAtHeight(this.doc, height + this.display.viewOffset);
      },
      heightAtLine: function(line, mode) {
        var end = false, last = this.doc.first + this.doc.size - 1;
        if (line < this.doc.first) line = this.doc.first;
        else if (line > last) { line = last; end = true; }
        var lineObj = getLine(this.doc, line);
        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page").top +
          (end ? this.doc.height - heightAtLine(lineObj) : 0);
      },

      defaultTextHeight: function() { return textHeight(this.display); },
      defaultCharWidth: function() { return charWidth(this.display); },

      setGutterMarker: methodOp(function(line, gutterID, value) {
        return changeLine(this.doc, line, "gutter", function(line) {
          var markers = line.gutterMarkers || (line.gutterMarkers = {});
          markers[gutterID] = value;
          if (!value && isEmpty(markers)) line.gutterMarkers = null;
          return true;
        });
      }),

      clearGutter: methodOp(function(gutterID) {
        var cm = this, doc = cm.doc, i = doc.first;
        doc.iter(function(line) {
          if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
            line.gutterMarkers[gutterID] = null;
            regLineChange(cm, i, "gutter");
            if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;
          }
          ++i;
        });
      }),

      addLineWidget: methodOp(function(handle, node, options) {
        return addLineWidget(this, handle, node, options);
      }),

      removeLineWidget: function(widget) { widget.clear(); },

      lineInfo: function(line) {
        if (typeof line == "number") {
          if (!isLine(this.doc, line)) return null;
          var n = line;
          line = getLine(this.doc, line);
          if (!line) return null;
        } else {
          var n = lineNo(line);
          if (n == null) return null;
        }
        return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
                textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
                widgets: line.widgets};
      },

      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},

      addWidget: function(pos, node, scroll, vert, horiz) {
        var display = this.display;
        pos = cursorCoords(this, clipPos(this.doc, pos));
        var top = pos.bottom, left = pos.left;
        node.style.position = "absolute";
        display.sizer.appendChild(node);
        if (vert == "over") {
          top = pos.top;
        } else if (vert == "above" || vert == "near") {
          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
          // Default to positioning above (if specified and possible); otherwise default to positioning below
          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
            top = pos.top - node.offsetHeight;
          else if (pos.bottom + node.offsetHeight <= vspace)
            top = pos.bottom;
          if (left + node.offsetWidth > hspace)
            left = hspace - node.offsetWidth;
        }
        node.style.top = top + "px";
        node.style.left = node.style.right = "";
        if (horiz == "right") {
          left = display.sizer.clientWidth - node.offsetWidth;
          node.style.right = "0px";
        } else {
          if (horiz == "left") left = 0;
          else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;
          node.style.left = left + "px";
        }
        if (scroll)
          scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
      },

      triggerOnKeyDown: methodOp(onKeyDown),
      triggerOnKeyPress: methodOp(onKeyPress),
      triggerOnKeyUp: onKeyUp,

      execCommand: function(cmd) {
        if (commands.hasOwnProperty(cmd))
          return commands[cmd](this);
      },

      findPosH: function(from, amount, unit, visually) {
        var dir = 1;
        if (amount < 0) { dir = -1; amount = -amount; }
        for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
          cur = findPosH(this.doc, cur, dir, unit, visually);
          if (cur.hitSide) break;
        }
        return cur;
      },

      moveH: methodOp(function(dir, unit) {
        var cm = this;
        cm.extendSelectionsBy(function(range) {
          if (cm.display.shift || cm.doc.extend || range.empty())
            return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);
          else
            return dir < 0 ? range.from() : range.to();
        }, sel_move);
      }),

      deleteH: methodOp(function(dir, unit) {
        var sel = this.doc.sel, doc = this.doc;
        if (sel.somethingSelected())
          doc.replaceSelection("", null, "+delete");
        else
          deleteNearSelection(this, function(range) {
            var other = findPosH(doc, range.head, dir, unit, false);
            return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};
          });
      }),

      findPosV: function(from, amount, unit, goalColumn) {
        var dir = 1, x = goalColumn;
        if (amount < 0) { dir = -1; amount = -amount; }
        for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
          var coords = cursorCoords(this, cur, "div");
          if (x == null) x = coords.left;
          else coords.left = x;
          cur = findPosV(this, coords, dir, unit);
          if (cur.hitSide) break;
        }
        return cur;
      },

      moveV: methodOp(function(dir, unit) {
        var cm = this, doc = this.doc, goals = [];
        var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();
        doc.extendSelectionsBy(function(range) {
          if (collapse)
            return dir < 0 ? range.from() : range.to();
          var headPos = cursorCoords(cm, range.head, "div");
          if (range.goalColumn != null) headPos.left = range.goalColumn;
          goals.push(headPos.left);
          var pos = findPosV(cm, headPos, dir, unit);
          if (unit == "page" && range == doc.sel.primary())
            addToScrollPos(cm, null, charCoords(cm, pos, "div").top - headPos.top);
          return pos;
        }, sel_move);
        if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)
          doc.sel.ranges[i].goalColumn = goals[i];
      }),

      toggleOverwrite: function(value) {
        if (value != null && value == this.state.overwrite) return;
        if (this.state.overwrite = !this.state.overwrite)
          addClass(this.display.cursorDiv, "CodeMirror-overwrite");
        else
          rmClass(this.display.cursorDiv, "CodeMirror-overwrite");

        signal(this, "overwriteToggle", this, this.state.overwrite);
      },
      hasFocus: function() { return activeElt() == this.display.input; },

      scrollTo: methodOp(function(x, y) {
        if (x != null || y != null) resolveScrollToPos(this);
        if (x != null) this.curOp.scrollLeft = x;
        if (y != null) this.curOp.scrollTop = y;
      }),
      getScrollInfo: function() {
        var scroller = this.display.scroller, co = scrollerCutOff;
        return {left: scroller.scrollLeft, top: scroller.scrollTop,
                height: scroller.scrollHeight - co, width: scroller.scrollWidth - co,
                clientHeight: scroller.clientHeight - co, clientWidth: scroller.clientWidth - co};
      },

      scrollIntoView: methodOp(function(range, margin) {
        if (range == null) {
          range = {from: this.doc.sel.primary().head, to: null};
          if (margin == null) margin = this.options.cursorScrollMargin;
        } else if (typeof range == "number") {
          range = {from: Pos(range, 0), to: null};
        } else if (range.from == null) {
          range = {from: range, to: null};
        }
        if (!range.to) range.to = range.from;
        range.margin = margin || 0;

        if (range.from.line != null) {
          resolveScrollToPos(this);
          this.curOp.scrollToPos = range;
        } else {
          var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),
                                        Math.min(range.from.top, range.to.top) - range.margin,
                                        Math.max(range.from.right, range.to.right),
                                        Math.max(range.from.bottom, range.to.bottom) + range.margin);
          this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
        }
      }),

      setSize: methodOp(function(width, height) {
        var cm = this;
        function interpret(val) {
          return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
        }
        if (width != null) cm.display.wrapper.style.width = interpret(width);
        if (height != null) cm.display.wrapper.style.height = interpret(height);
        if (cm.options.lineWrapping) clearLineMeasurementCache(this);
        var lineNo = cm.display.viewFrom;
        cm.doc.iter(lineNo, cm.display.viewTo, function(line) {
          if (line.widgets) for (var i = 0; i < line.widgets.length; i++)
            if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, "widget"); break; }
          ++lineNo;
        });
        cm.curOp.forceUpdate = true;
        signal(cm, "refresh", this);
      }),

      operation: function(f){return runInOp(this, f);},

      refresh: methodOp(function() {
        var oldHeight = this.display.cachedTextHeight;
        regChange(this);
        this.curOp.forceUpdate = true;
        clearCaches(this);
        this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
        updateGutterSpace(this);
        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
          estimateLineHeights(this);
        signal(this, "refresh", this);
      }),

      swapDoc: methodOp(function(doc) {
        var old = this.doc;
        old.cm = null;
        attachDoc(this, doc);
        clearCaches(this);
        resetInput(this);
        this.scrollTo(doc.scrollLeft, doc.scrollTop);
        signalLater(this, "swapDoc", this, old);
        return old;
      }),

      getInputField: function(){return this.display.input;},
      getWrapperElement: function(){return this.display.wrapper;},
      getScrollerElement: function(){return this.display.scroller;},
      getGutterElement: function(){return this.display.gutters;}
    };
    eventMixin(CodeMirror);

    // OPTION DEFAULTS

    // The default configuration options.
    var defaults = CodeMirror.defaults = {};
    // Functions to run when options are changed.
    var optionHandlers = CodeMirror.optionHandlers = {};

    function option(name, deflt, handle, notOnInit) {
      CodeMirror.defaults[name] = deflt;
      if (handle) optionHandlers[name] =
        notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;
    }

    // Passed to option handlers when there is no old value.
    var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};

    // These two are, on init, called from the constructor because they
    // have to be initialized before the editor can start at all.
    option("value", "", function(cm, val) {
      cm.setValue(val);
    }, true);
    option("mode", null, function(cm, val) {
      cm.doc.modeOption = val;
      loadMode(cm);
    }, true);

    option("indentUnit", 2, loadMode, true);
    option("indentWithTabs", false);
    option("smartIndent", true);
    option("tabSize", 4, function(cm) {
      resetModeState(cm);
      clearCaches(cm);
      regChange(cm);
    }, true);
    option("specialChars", /[\t\u0000-\u0019\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function(cm, val) {
      cm.options.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
      cm.refresh();
    }, true);
    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);
    option("electricChars", true);
    option("rtlMoveVisually", !windows);
    option("wholeLineUpdateBefore", true);

    option("theme", "default", function(cm) {
      themeChanged(cm);
      guttersChanged(cm);
    }, true);
    option("keyMap", "default", keyMapChanged);
    option("extraKeys", null);

    option("lineWrapping", false, wrappingChanged, true);
    option("gutters", [], function(cm) {
      setGuttersForLineNumbers(cm.options);
      guttersChanged(cm);
    }, true);
    option("fixedGutter", true, function(cm, val) {
      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
      cm.refresh();
    }, true);
    option("coverGutterNextToScrollbar", false, updateScrollbars, true);
    option("lineNumbers", false, function(cm) {
      setGuttersForLineNumbers(cm.options);
      guttersChanged(cm);
    }, true);
    option("firstLineNumber", 1, guttersChanged, true);
    option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);
    option("showCursorWhenSelecting", false, updateSelection, true);

    option("resetSelectionOnContextMenu", true);

    option("readOnly", false, function(cm, val) {
      if (val == "nocursor") {
        onBlur(cm);
        cm.display.input.blur();
        cm.display.disabled = true;
      } else {
        cm.display.disabled = false;
        if (!val) resetInput(cm);
      }
    });
    option("disableInput", false, function(cm, val) {if (!val) resetInput(cm);}, true);
    option("dragDrop", true);

    option("cursorBlinkRate", 530);
    option("cursorScrollMargin", 0);
    option("cursorHeight", 1, updateSelection, true);
    option("singleCursorHeightPerLine", true, updateSelection, true);
    option("workTime", 100);
    option("workDelay", 100);
    option("flattenSpans", true, resetModeState, true);
    option("addModeClass", false, resetModeState, true);
    option("pollInterval", 100);
    option("undoDepth", 200, function(cm, val){cm.doc.history.undoDepth = val;});
    option("historyEventDelay", 1250);
    option("viewportMargin", 10, function(cm){cm.refresh();}, true);
    option("maxHighlightLength", 10000, resetModeState, true);
    option("moveInputWithCursor", true, function(cm, val) {
      if (!val) cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;
    });

    option("tabindex", null, function(cm, val) {
      cm.display.input.tabIndex = val || "";
    });
    option("autofocus", null);

    // MODE DEFINITION AND QUERYING

    // Known modes, by name and by MIME
    var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};

    // Extra arguments are stored as the mode's dependencies, which is
    // used by (legacy) mechanisms like loadmode.js to automatically
    // load a mode. (Preferred mechanism is the require/define calls.)
    CodeMirror.defineMode = function(name, mode) {
      if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;
      if (arguments.length > 2) {
        mode.dependencies = [];
        for (var i = 2; i < arguments.length; ++i) mode.dependencies.push(arguments[i]);
      }
      modes[name] = mode;
    };

    CodeMirror.defineMIME = function(mime, spec) {
      mimeModes[mime] = spec;
    };

    // Given a MIME type, a {name, ...options} config object, or a name
    // string, return a mode config object.
    CodeMirror.resolveMode = function(spec) {
      if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
        spec = mimeModes[spec];
      } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
        var found = mimeModes[spec.name];
        if (typeof found == "string") found = {name: found};
        spec = createObj(found, spec);
        spec.name = found.name;
      } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
        return CodeMirror.resolveMode("application/xml");
      }
      if (typeof spec == "string") return {name: spec};
      else return spec || {name: "null"};
    };

    // Given a mode spec (anything that resolveMode accepts), find and
    // initialize an actual mode object.
    CodeMirror.getMode = function(options, spec) {
      var spec = CodeMirror.resolveMode(spec);
      var mfactory = modes[spec.name];
      if (!mfactory) return CodeMirror.getMode(options, "text/plain");
      var modeObj = mfactory(options, spec);
      if (modeExtensions.hasOwnProperty(spec.name)) {
        var exts = modeExtensions[spec.name];
        for (var prop in exts) {
          if (!exts.hasOwnProperty(prop)) continue;
          if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
          modeObj[prop] = exts[prop];
        }
      }
      modeObj.name = spec.name;
      if (spec.helperType) modeObj.helperType = spec.helperType;
      if (spec.modeProps) for (var prop in spec.modeProps)
        modeObj[prop] = spec.modeProps[prop];

      return modeObj;
    };

    // Minimal default mode.
    CodeMirror.defineMode("null", function() {
      return {token: function(stream) {stream.skipToEnd();}};
    });
    CodeMirror.defineMIME("text/plain", "null");

    // This can be used to attach properties to mode objects from
    // outside the actual mode definition.
    var modeExtensions = CodeMirror.modeExtensions = {};
    CodeMirror.extendMode = function(mode, properties) {
      var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
      copyObj(properties, exts);
    };

    // EXTENSIONS

    CodeMirror.defineExtension = function(name, func) {
      CodeMirror.prototype[name] = func;
    };
    CodeMirror.defineDocExtension = function(name, func) {
      Doc.prototype[name] = func;
    };
    CodeMirror.defineOption = option;

    var initHooks = [];
    CodeMirror.defineInitHook = function(f) {initHooks.push(f);};

    var helpers = CodeMirror.helpers = {};
    CodeMirror.registerHelper = function(type, name, value) {
      if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};
      helpers[type][name] = value;
    };
    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
      CodeMirror.registerHelper(type, name, value);
      helpers[type]._global.push({pred: predicate, val: value});
    };

    // MODE STATE HANDLING

    // Utility functions for working with state. Exported because nested
    // modes need to do this for their inner modes.

    var copyState = CodeMirror.copyState = function(mode, state) {
      if (state === true) return state;
      if (mode.copyState) return mode.copyState(state);
      var nstate = {};
      for (var n in state) {
        var val = state[n];
        if (val instanceof Array) val = val.concat([]);
        nstate[n] = val;
      }
      return nstate;
    };

    var startState = CodeMirror.startState = function(mode, a1, a2) {
      return mode.startState ? mode.startState(a1, a2) : true;
    };

    // Given a mode and a state (for that mode), find the inner mode and
    // state at the position that the state refers to.
    CodeMirror.innerMode = function(mode, state) {
      while (mode.innerMode) {
        var info = mode.innerMode(state);
        if (!info || info.mode == mode) break;
        state = info.state;
        mode = info.mode;
      }
      return info || {mode: mode, state: state};
    };

    // STANDARD COMMANDS

    // Commands are parameter-less actions that can be performed on an
    // editor, mostly used for keybindings.
    var commands = CodeMirror.commands = {
      selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},
      singleSelection: function(cm) {
        cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
      },
      killLine: function(cm) {
        deleteNearSelection(cm, function(range) {
          if (range.empty()) {
            var len = getLine(cm.doc, range.head.line).text.length;
            if (range.head.ch == len && range.head.line < cm.lastLine())
              return {from: range.head, to: Pos(range.head.line + 1, 0)};
            else
              return {from: range.head, to: Pos(range.head.line, len)};
          } else {
            return {from: range.from(), to: range.to()};
          }
        });
      },
      deleteLine: function(cm) {
        deleteNearSelection(cm, function(range) {
          return {from: Pos(range.from().line, 0),
                  to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};
        });
      },
      delLineLeft: function(cm) {
        deleteNearSelection(cm, function(range) {
          return {from: Pos(range.from().line, 0), to: range.from()};
        });
      },
      delWrappedLineLeft: function(cm) {
        deleteNearSelection(cm, function(range) {
          var top = cm.charCoords(range.head, "div").top + 5;
          var leftPos = cm.coordsChar({left: 0, top: top}, "div");
          return {from: leftPos, to: range.from()};
        });
      },
      delWrappedLineRight: function(cm) {
        deleteNearSelection(cm, function(range) {
          var top = cm.charCoords(range.head, "div").top + 5;
          var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
          return {from: range.from(), to: rightPos };
        });
      },
      undo: function(cm) {cm.undo();},
      redo: function(cm) {cm.redo();},
      undoSelection: function(cm) {cm.undoSelection();},
      redoSelection: function(cm) {cm.redoSelection();},
      goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},
      goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},
      goLineStart: function(cm) {
        cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },
                              {origin: "+move", bias: 1});
      },
      goLineStartSmart: function(cm) {
        cm.extendSelectionsBy(function(range) {
          return lineStartSmart(cm, range.head);
        }, {origin: "+move", bias: 1});
      },
      goLineEnd: function(cm) {
        cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },
                              {origin: "+move", bias: -1});
      },
      goLineRight: function(cm) {
        cm.extendSelectionsBy(function(range) {
          var top = cm.charCoords(range.head, "div").top + 5;
          return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
        }, sel_move);
      },
      goLineLeft: function(cm) {
        cm.extendSelectionsBy(function(range) {
          var top = cm.charCoords(range.head, "div").top + 5;
          return cm.coordsChar({left: 0, top: top}, "div");
        }, sel_move);
      },
      goLineLeftSmart: function(cm) {
        cm.extendSelectionsBy(function(range) {
          var top = cm.charCoords(range.head, "div").top + 5;
          var pos = cm.coordsChar({left: 0, top: top}, "div");
          if (pos.ch < cm.getLine(pos.line).search(/\S/)) return lineStartSmart(cm, range.head);
          return pos;
        }, sel_move);
      },
      goLineUp: function(cm) {cm.moveV(-1, "line");},
      goLineDown: function(cm) {cm.moveV(1, "line");},
      goPageUp: function(cm) {cm.moveV(-1, "page");},
      goPageDown: function(cm) {cm.moveV(1, "page");},
      goCharLeft: function(cm) {cm.moveH(-1, "char");},
      goCharRight: function(cm) {cm.moveH(1, "char");},
      goColumnLeft: function(cm) {cm.moveH(-1, "column");},
      goColumnRight: function(cm) {cm.moveH(1, "column");},
      goWordLeft: function(cm) {cm.moveH(-1, "word");},
      goGroupRight: function(cm) {cm.moveH(1, "group");},
      goGroupLeft: function(cm) {cm.moveH(-1, "group");},
      goWordRight: function(cm) {cm.moveH(1, "word");},
      delCharBefore: function(cm) {cm.deleteH(-1, "char");},
      delCharAfter: function(cm) {cm.deleteH(1, "char");},
      delWordBefore: function(cm) {cm.deleteH(-1, "word");},
      delWordAfter: function(cm) {cm.deleteH(1, "word");},
      delGroupBefore: function(cm) {cm.deleteH(-1, "group");},
      delGroupAfter: function(cm) {cm.deleteH(1, "group");},
      indentAuto: function(cm) {cm.indentSelection("smart");},
      indentMore: function(cm) {cm.indentSelection("add");},
      indentLess: function(cm) {cm.indentSelection("subtract");},
      insertTab: function(cm) {cm.replaceSelection("\t");},
      insertSoftTab: function(cm) {
        var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
        for (var i = 0; i < ranges.length; i++) {
          var pos = ranges[i].from();
          var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
          spaces.push(new Array(tabSize - col % tabSize + 1).join(" "));
        }
        cm.replaceSelections(spaces);
      },
      defaultTab: function(cm) {
        if (cm.somethingSelected()) cm.indentSelection("add");
        else cm.execCommand("insertTab");
      },
      transposeChars: function(cm) {
        runInOp(cm, function() {
          var ranges = cm.listSelections(), newSel = [];
          for (var i = 0; i < ranges.length; i++) {
            var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
            if (line) {
              if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);
              if (cur.ch > 0) {
                cur = new Pos(cur.line, cur.ch + 1);
                cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                                Pos(cur.line, cur.ch - 2), cur, "+transpose");
              } else if (cur.line > cm.doc.first) {
                var prev = getLine(cm.doc, cur.line - 1).text;
                if (prev)
                  cm.replaceRange(line.charAt(0) + "\n" + prev.charAt(prev.length - 1),
                                  Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), "+transpose");
              }
            }
            newSel.push(new Range(cur, cur));
          }
          cm.setSelections(newSel);
        });
      },
      newlineAndIndent: function(cm) {
        runInOp(cm, function() {
          var len = cm.listSelections().length;
          for (var i = 0; i < len; i++) {
            var range = cm.listSelections()[i];
            cm.replaceRange("\n", range.anchor, range.head, "+input");
            cm.indentLine(range.from().line + 1, null, true);
            ensureCursorVisible(cm);
          }
        });
      },
      toggleOverwrite: function(cm) {cm.toggleOverwrite();}
    };

    // STANDARD KEYMAPS

    var keyMap = CodeMirror.keyMap = {};
    keyMap.basic = {
      "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
      "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
      "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
      "Tab": "defaultTab", "Shift-Tab": "indentAuto",
      "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
      "Esc": "singleSelection"
    };
    // Note that the save and find-related commands aren't defined by
    // default. User code or addons can define them. Unknown commands
    // are simply ignored.
    keyMap.pcDefault = {
      "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
      "Ctrl-Home": "goDocStart", "Ctrl-Up": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Down": "goDocEnd",
      "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
      "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
      "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
      "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
      "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
      fallthrough: "basic"
    };
    keyMap.macDefault = {
      "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
      "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
      "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
      "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
      "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
      "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
      "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection",
      fallthrough: ["basic", "emacsy"]
    };
    // Very basic readline/emacs-style bindings, which are standard on Mac.
    keyMap.emacsy = {
      "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
      "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
      "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
      "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars"
    };
    keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

    // KEYMAP DISPATCH

    function getKeyMap(val) {
      if (typeof val == "string") return keyMap[val];
      else return val;
    }

    // Given an array of keymaps and a key name, call handle on any
    // bindings found, until that returns a truthy value, at which point
    // we consider the key handled. Implements things like binding a key
    // to false stopping further handling and keymap fallthrough.
    var lookupKey = CodeMirror.lookupKey = function(name, maps, handle) {
      function lookup(map) {
        map = getKeyMap(map);
        var found = map[name];
        if (found === false) return "stop";
        if (found != null && handle(found)) return true;
        if (map.nofallthrough) return "stop";

        var fallthrough = map.fallthrough;
        if (fallthrough == null) return false;
        if (Object.prototype.toString.call(fallthrough) != "[object Array]")
          return lookup(fallthrough);
        for (var i = 0; i < fallthrough.length; ++i) {
          var done = lookup(fallthrough[i]);
          if (done) return done;
        }
        return false;
      }

      for (var i = 0; i < maps.length; ++i) {
        var done = lookup(maps[i]);
        if (done) return done != "stop";
      }
    };

    // Modifier key presses don't count as 'real' key presses for the
    // purpose of keymap fallthrough.
    var isModifierKey = CodeMirror.isModifierKey = function(event) {
      var name = keyNames[event.keyCode];
      return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
    };

    // Look up the name of a key as indicated by an event object.
    var keyName = CodeMirror.keyName = function(event, noShift) {
      if (presto && event.keyCode == 34 && event["char"]) return false;
      var name = keyNames[event.keyCode];
      if (name == null || event.altGraphKey) return false;
      if (event.altKey) name = "Alt-" + name;
      if (flipCtrlCmd ? event.metaKey : event.ctrlKey) name = "Ctrl-" + name;
      if (flipCtrlCmd ? event.ctrlKey : event.metaKey) name = "Cmd-" + name;
      if (!noShift && event.shiftKey) name = "Shift-" + name;
      return name;
    };

    // FROMTEXTAREA

    CodeMirror.fromTextArea = function(textarea, options) {
      if (!options) options = {};
      options.value = textarea.value;
      if (!options.tabindex && textarea.tabindex)
        options.tabindex = textarea.tabindex;
      if (!options.placeholder && textarea.placeholder)
        options.placeholder = textarea.placeholder;
      // Set autofocus to true if this textarea is focused, or if it has
      // autofocus and no other element is focused.
      if (options.autofocus == null) {
        var hasFocus = activeElt();
        options.autofocus = hasFocus == textarea ||
          textarea.getAttribute("autofocus") != null && hasFocus == document.body;
      }

      function save() {textarea.value = cm.getValue();}
      if (textarea.form) {
        on(textarea.form, "submit", save);
        // Deplorable hack to make the submit method do the right thing.
        if (!options.leaveSubmitMethodAlone) {
          var form = textarea.form, realSubmit = form.submit;
          try {
            var wrappedSubmit = form.submit = function() {
              save();
              form.submit = realSubmit;
              form.submit();
              form.submit = wrappedSubmit;
            };
          } catch(e) {}
        }
      }

      textarea.style.display = "none";
      var cm = CodeMirror(function(node) {
        textarea.parentNode.insertBefore(node, textarea.nextSibling);
      }, options);
      cm.save = save;
      cm.getTextArea = function() { return textarea; };
      cm.toTextArea = function() {
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (typeof textarea.form.submit == "function")
            textarea.form.submit = realSubmit;
        }
      };
      return cm;
    };

    // STRING STREAM

    // Fed to the mode parsers, provides helper functions to make
    // parsers more succinct.

    var StringStream = CodeMirror.StringStream = function(string, tabSize) {
      this.pos = this.start = 0;
      this.string = string;
      this.tabSize = tabSize || 8;
      this.lastColumnPos = this.lastColumnValue = 0;
      this.lineStart = 0;
    };

    StringStream.prototype = {
      eol: function() {return this.pos >= this.string.length;},
      sol: function() {return this.pos == this.lineStart;},
      peek: function() {return this.string.charAt(this.pos) || undefined;},
      next: function() {
        if (this.pos < this.string.length)
          return this.string.charAt(this.pos++);
      },
      eat: function(match) {
        var ch = this.string.charAt(this.pos);
        if (typeof match == "string") var ok = ch == match;
        else var ok = ch && (match.test ? match.test(ch) : match(ch));
        if (ok) {++this.pos; return ch;}
      },
      eatWhile: function(match) {
        var start = this.pos;
        while (this.eat(match)){}
        return this.pos > start;
      },
      eatSpace: function() {
        var start = this.pos;
        while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
        return this.pos > start;
      },
      skipToEnd: function() {this.pos = this.string.length;},
      skipTo: function(ch) {
        var found = this.string.indexOf(ch, this.pos);
        if (found > -1) {this.pos = found; return true;}
      },
      backUp: function(n) {this.pos -= n;},
      column: function() {
        if (this.lastColumnPos < this.start) {
          this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
          this.lastColumnPos = this.start;
        }
        return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
      },
      indentation: function() {
        return countColumn(this.string, null, this.tabSize) -
          (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
      },
      match: function(pattern, consume, caseInsensitive) {
        if (typeof pattern == "string") {
          var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};
          var substr = this.string.substr(this.pos, pattern.length);
          if (cased(substr) == cased(pattern)) {
            if (consume !== false) this.pos += pattern.length;
            return true;
          }
        } else {
          var match = this.string.slice(this.pos).match(pattern);
          if (match && match.index > 0) return null;
          if (match && consume !== false) this.pos += match[0].length;
          return match;
        }
      },
      current: function(){return this.string.slice(this.start, this.pos);},
      hideFirstChars: function(n, inner) {
        this.lineStart += n;
        try { return inner(); }
        finally { this.lineStart -= n; }
      }
    };

    // TEXTMARKERS

    // Created with markText and setBookmark methods. A TextMarker is a
    // handle that can be used to clear or find a marked position in the
    // document. Line objects hold arrays (markedSpans) containing
    // {from, to, marker} object pointing to such marker objects, and
    // indicating that such a marker is present on that line. Multiple
    // lines may point to the same marker when it spans across lines.
    // The spans will have null for their from/to properties when the
    // marker continues beyond the start/end of the line. Markers have
    // links back to the lines they currently touch.

    var TextMarker = CodeMirror.TextMarker = function(doc, type) {
      this.lines = [];
      this.type = type;
      this.doc = doc;
    };
    eventMixin(TextMarker);

    // Clear the marker.
    TextMarker.prototype.clear = function() {
      if (this.explicitlyCleared) return;
      var cm = this.doc.cm, withOp = cm && !cm.curOp;
      if (withOp) startOperation(cm);
      if (hasHandler(this, "clear")) {
        var found = this.find();
        if (found) signalLater(this, "clear", found.from, found.to);
      }
      var min = null, max = null;
      for (var i = 0; i < this.lines.length; ++i) {
        var line = this.lines[i];
        var span = getMarkedSpanFor(line.markedSpans, this);
        if (cm && !this.collapsed) regLineChange(cm, lineNo(line), "text");
        else if (cm) {
          if (span.to != null) max = lineNo(line);
          if (span.from != null) min = lineNo(line);
        }
        line.markedSpans = removeMarkedSpan(line.markedSpans, span);
        if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
          updateLineHeight(line, textHeight(cm.display));
      }
      if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {
        var visual = visualLine(this.lines[i]), len = lineLength(visual);
        if (len > cm.display.maxLineLength) {
          cm.display.maxLine = visual;
          cm.display.maxLineLength = len;
          cm.display.maxLineChanged = true;
        }
      }

      if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);
      this.lines.length = 0;
      this.explicitlyCleared = true;
      if (this.atomic && this.doc.cantEdit) {
        this.doc.cantEdit = false;
        if (cm) reCheckSelection(cm.doc);
      }
      if (cm) signalLater(cm, "markerCleared", cm, this);
      if (withOp) endOperation(cm);
      if (this.parent) this.parent.clear();
    };

    // Find the position of the marker in the document. Returns a {from,
    // to} object by default. Side can be passed to get a specific side
    // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
    // Pos objects returned contain a line object, rather than a line
    // number (used to prevent looking up the same line twice).
    TextMarker.prototype.find = function(side, lineObj) {
      if (side == null && this.type == "bookmark") side = 1;
      var from, to;
      for (var i = 0; i < this.lines.length; ++i) {
        var line = this.lines[i];
        var span = getMarkedSpanFor(line.markedSpans, this);
        if (span.from != null) {
          from = Pos(lineObj ? line : lineNo(line), span.from);
          if (side == -1) return from;
        }
        if (span.to != null) {
          to = Pos(lineObj ? line : lineNo(line), span.to);
          if (side == 1) return to;
        }
      }
      return from && {from: from, to: to};
    };

    // Signals that the marker's widget changed, and surrounding layout
    // should be recomputed.
    TextMarker.prototype.changed = function() {
      var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
      if (!pos || !cm) return;
      runInOp(cm, function() {
        var line = pos.line, lineN = lineNo(pos.line);
        var view = findViewForLine(cm, lineN);
        if (view) {
          clearLineMeasurementCacheFor(view);
          cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
        }
        cm.curOp.updateMaxLine = true;
        if (!lineIsHidden(widget.doc, line) && widget.height != null) {
          var oldHeight = widget.height;
          widget.height = null;
          var dHeight = widgetHeight(widget) - oldHeight;
          if (dHeight)
            updateLineHeight(line, line.height + dHeight);
        }
      });
    };

    TextMarker.prototype.attachLine = function(line) {
      if (!this.lines.length && this.doc.cm) {
        var op = this.doc.cm.curOp;
        if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
          (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
      }
      this.lines.push(line);
    };
    TextMarker.prototype.detachLine = function(line) {
      this.lines.splice(indexOf(this.lines, line), 1);
      if (!this.lines.length && this.doc.cm) {
        var op = this.doc.cm.curOp;
        (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
      }
    };

    // Collapsed markers have unique ids, in order to be able to order
    // them, which is needed for uniquely determining an outer marker
    // when they overlap (they may nest, but not partially overlap).
    var nextMarkerId = 0;

    // Create a marker, wire it up to the right lines, and
    function markText(doc, from, to, options, type) {
      // Shared markers (across linked documents) are handled separately
      // (markTextShared will call out to this again, once per
      // document).
      if (options && options.shared) return markTextShared(doc, from, to, options, type);
      // Ensure we are in an operation.
      if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);

      var marker = new TextMarker(doc, type), diff = cmp(from, to);
      if (options) copyObj(options, marker, false);
      // Don't connect empty markers unless clearWhenEmpty is false
      if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
        return marker;
      if (marker.replacedWith) {
        // Showing up as a widget implies collapsed (widget replaces text)
        marker.collapsed = true;
        marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget");
        if (!options.handleMouseEvents) marker.widgetNode.ignoreEvents = true;
        if (options.insertLeft) marker.widgetNode.insertLeft = true;
      }
      if (marker.collapsed) {
        if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
            from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
          throw new Error("Inserting collapsed marker partially overlapping an existing one");
        sawCollapsedSpans = true;
      }

      if (marker.addToHistory)
        addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN);

      var curLine = from.line, cm = doc.cm, updateMaxLine;
      doc.iter(curLine, to.line + 1, function(line) {
        if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
          updateMaxLine = true;
        if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);
        addMarkedSpan(line, new MarkedSpan(marker,
                                           curLine == from.line ? from.ch : null,
                                           curLine == to.line ? to.ch : null));
        ++curLine;
      });
      // lineIsHidden depends on the presence of the spans, so needs a second pass
      if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {
        if (lineIsHidden(doc, line)) updateLineHeight(line, 0);
      });

      if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });

      if (marker.readOnly) {
        sawReadOnlySpans = true;
        if (doc.history.done.length || doc.history.undone.length)
          doc.clearHistory();
      }
      if (marker.collapsed) {
        marker.id = ++nextMarkerId;
        marker.atomic = true;
      }
      if (cm) {
        // Sync editor state
        if (updateMaxLine) cm.curOp.updateMaxLine = true;
        if (marker.collapsed)
          regChange(cm, from.line, to.line + 1);
        else if (marker.className || marker.title || marker.startStyle || marker.endStyle)
          for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, "text");
        if (marker.atomic) reCheckSelection(cm.doc);
        signalLater(cm, "markerAdded", cm, marker);
      }
      return marker;
    }

    // SHARED TEXTMARKERS

    // A shared marker spans multiple linked documents. It is
    // implemented as a meta-marker-object controlling multiple normal
    // markers.
    var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {
      this.markers = markers;
      this.primary = primary;
      for (var i = 0; i < markers.length; ++i)
        markers[i].parent = this;
    };
    eventMixin(SharedTextMarker);

    SharedTextMarker.prototype.clear = function() {
      if (this.explicitlyCleared) return;
      this.explicitlyCleared = true;
      for (var i = 0; i < this.markers.length; ++i)
        this.markers[i].clear();
      signalLater(this, "clear");
    };
    SharedTextMarker.prototype.find = function(side, lineObj) {
      return this.primary.find(side, lineObj);
    };

    function markTextShared(doc, from, to, options, type) {
      options = copyObj(options);
      options.shared = false;
      var markers = [markText(doc, from, to, options, type)], primary = markers[0];
      var widget = options.widgetNode;
      linkedDocs(doc, function(doc) {
        if (widget) options.widgetNode = widget.cloneNode(true);
        markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
        for (var i = 0; i < doc.linked.length; ++i)
          if (doc.linked[i].isParent) return;
        primary = lst(markers);
      });
      return new SharedTextMarker(markers, primary);
    }

    function findSharedMarkers(doc) {
      return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),
                           function(m) { return m.parent; });
    }

    function copySharedMarkers(doc, markers) {
      for (var i = 0; i < markers.length; i++) {
        var marker = markers[i], pos = marker.find();
        var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
        if (cmp(mFrom, mTo)) {
          var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
          marker.markers.push(subMark);
          subMark.parent = marker;
        }
      }
    }

    function detachSharedMarkers(markers) {
      for (var i = 0; i < markers.length; i++) {
        var marker = markers[i], linked = [marker.primary.doc];;
        linkedDocs(marker.primary.doc, function(d) { linked.push(d); });
        for (var j = 0; j < marker.markers.length; j++) {
          var subMarker = marker.markers[j];
          if (indexOf(linked, subMarker.doc) == -1) {
            subMarker.parent = null;
            marker.markers.splice(j--, 1);
          }
        }
      }
    }

    // TEXTMARKER SPANS

    function MarkedSpan(marker, from, to) {
      this.marker = marker;
      this.from = from; this.to = to;
    }

    // Search an array of spans for a span matching the given marker.
    function getMarkedSpanFor(spans, marker) {
      if (spans) for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if (span.marker == marker) return span;
      }
    }
    // Remove a span from an array, returning undefined if no spans are
    // left (we don't store arrays for lines without spans).
    function removeMarkedSpan(spans, span) {
      for (var r, i = 0; i < spans.length; ++i)
        if (spans[i] != span) (r || (r = [])).push(spans[i]);
      return r;
    }
    // Add a span to a line.
    function addMarkedSpan(line, span) {
      line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
      span.marker.attachLine(line);
    }

    // Used for the algorithm that adjusts markers for a change in the
    // document. These functions cut an array of spans at a given
    // character position, returning an array of remaining chunks (or
    // undefined if nothing remains).
    function markedSpansBefore(old, startCh, isInsert) {
      if (old) for (var i = 0, nw; i < old.length; ++i) {
        var span = old[i], marker = span.marker;
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
        if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
          (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
        }
      }
      return nw;
    }
    function markedSpansAfter(old, endCh, isInsert) {
      if (old) for (var i = 0, nw; i < old.length; ++i) {
        var span = old[i], marker = span.marker;
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
        if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
          (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                                span.to == null ? null : span.to - endCh));
        }
      }
      return nw;
    }

    // Given a change object, compute the new set of marker spans that
    // cover the line in which the change took place. Removes spans
    // entirely within the change, reconnects spans belonging to the
    // same marker that appear on both sides of the change, and cuts off
    // spans partially within the change. Returns an array of span
    // arrays with one element for each line in (after) the change.
    function stretchSpansOverChange(doc, change) {
      var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
      var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
      if (!oldFirst && !oldLast) return null;

      var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
      // Get the spans that 'stick out' on both sides
      var first = markedSpansBefore(oldFirst, startCh, isInsert);
      var last = markedSpansAfter(oldLast, endCh, isInsert);

      // Next, merge those two ends
      var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
      if (first) {
        // Fix up .to properties of first
        for (var i = 0; i < first.length; ++i) {
          var span = first[i];
          if (span.to == null) {
            var found = getMarkedSpanFor(last, span.marker);
            if (!found) span.to = startCh;
            else if (sameLine) span.to = found.to == null ? null : found.to + offset;
          }
        }
      }
      if (last) {
        // Fix up .from in last (or move them into first in case of sameLine)
        for (var i = 0; i < last.length; ++i) {
          var span = last[i];
          if (span.to != null) span.to += offset;
          if (span.from == null) {
            var found = getMarkedSpanFor(first, span.marker);
            if (!found) {
              span.from = offset;
              if (sameLine) (first || (first = [])).push(span);
            }
          } else {
            span.from += offset;
            if (sameLine) (first || (first = [])).push(span);
          }
        }
      }
      // Make sure we didn't create any zero-length spans
      if (first) first = clearEmptySpans(first);
      if (last && last != first) last = clearEmptySpans(last);

      var newMarkers = [first];
      if (!sameLine) {
        // Fill gap with whole-line-spans
        var gap = change.text.length - 2, gapMarkers;
        if (gap > 0 && first)
          for (var i = 0; i < first.length; ++i)
            if (first[i].to == null)
              (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));
        for (var i = 0; i < gap; ++i)
          newMarkers.push(gapMarkers);
        newMarkers.push(last);
      }
      return newMarkers;
    }

    // Remove spans that are empty and don't have a clearWhenEmpty
    // option of false.
    function clearEmptySpans(spans) {
      for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
          spans.splice(i--, 1);
      }
      if (!spans.length) return null;
      return spans;
    }

    // Used for un/re-doing changes from the history. Combines the
    // result of computing the existing spans with the set of spans that
    // existed in the history (so that deleting around a span and then
    // undoing brings back the span).
    function mergeOldSpans(doc, change) {
      var old = getOldSpans(doc, change);
      var stretched = stretchSpansOverChange(doc, change);
      if (!old) return stretched;
      if (!stretched) return old;

      for (var i = 0; i < old.length; ++i) {
        var oldCur = old[i], stretchCur = stretched[i];
        if (oldCur && stretchCur) {
          spans: for (var j = 0; j < stretchCur.length; ++j) {
            var span = stretchCur[j];
            for (var k = 0; k < oldCur.length; ++k)
              if (oldCur[k].marker == span.marker) continue spans;
            oldCur.push(span);
          }
        } else if (stretchCur) {
          old[i] = stretchCur;
        }
      }
      return old;
    }

    // Used to 'clip' out readOnly ranges when making a change.
    function removeReadOnlyRanges(doc, from, to) {
      var markers = null;
      doc.iter(from.line, to.line + 1, function(line) {
        if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
          var mark = line.markedSpans[i].marker;
          if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
            (markers || (markers = [])).push(mark);
        }
      });
      if (!markers) return null;
      var parts = [{from: from, to: to}];
      for (var i = 0; i < markers.length; ++i) {
        var mk = markers[i], m = mk.find(0);
        for (var j = 0; j < parts.length; ++j) {
          var p = parts[j];
          if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;
          var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
          if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
            newParts.push({from: p.from, to: m.from});
          if (dto > 0 || !mk.inclusiveRight && !dto)
            newParts.push({from: m.to, to: p.to});
          parts.splice.apply(parts, newParts);
          j += newParts.length - 1;
        }
      }
      return parts;
    }

    // Connect or disconnect spans from a line.
    function detachMarkedSpans(line) {
      var spans = line.markedSpans;
      if (!spans) return;
      for (var i = 0; i < spans.length; ++i)
        spans[i].marker.detachLine(line);
      line.markedSpans = null;
    }
    function attachMarkedSpans(line, spans) {
      if (!spans) return;
      for (var i = 0; i < spans.length; ++i)
        spans[i].marker.attachLine(line);
      line.markedSpans = spans;
    }

    // Helpers used when computing which overlapping collapsed span
    // counts as the larger one.
    function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }
    function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }

    // Returns a number indicating which of two overlapping collapsed
    // spans is larger (and thus includes the other). Falls back to
    // comparing ids when the spans cover exactly the same range.
    function compareCollapsedMarkers(a, b) {
      var lenDiff = a.lines.length - b.lines.length;
      if (lenDiff != 0) return lenDiff;
      var aPos = a.find(), bPos = b.find();
      var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
      if (fromCmp) return -fromCmp;
      var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
      if (toCmp) return toCmp;
      return b.id - a.id;
    }

    // Find out whether a line ends or starts in a collapsed span. If
    // so, return the marker for that span.
    function collapsedSpanAtSide(line, start) {
      var sps = sawCollapsedSpans && line.markedSpans, found;
      if (sps) for (var sp, i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
            (!found || compareCollapsedMarkers(found, sp.marker) < 0))
          found = sp.marker;
      }
      return found;
    }
    function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }
    function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }

    // Test whether there exists a collapsed span that partially
    // overlaps (covers the start or end, but not both) of a new span.
    // Such overlap is not allowed.
    function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
      var line = getLine(doc, lineNo);
      var sps = sawCollapsedSpans && line.markedSpans;
      if (sps) for (var i = 0; i < sps.length; ++i) {
        var sp = sps[i];
        if (!sp.marker.collapsed) continue;
        var found = sp.marker.find(0);
        var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
        var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
        if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;
        if (fromCmp <= 0 && (cmp(found.to, from) > 0 || (sp.marker.inclusiveRight && marker.inclusiveLeft)) ||
            fromCmp >= 0 && (cmp(found.from, to) < 0 || (sp.marker.inclusiveLeft && marker.inclusiveRight)))
          return true;
      }
    }

    // A visual line is a line as drawn on the screen. Folding, for
    // example, can cause multiple logical lines to appear on the same
    // visual line. This finds the start of the visual line that the
    // given line is part of (usually that is the line itself).
    function visualLine(line) {
      var merged;
      while (merged = collapsedSpanAtStart(line))
        line = merged.find(-1, true).line;
      return line;
    }

    // Returns an array of logical lines that continue the visual line
    // started by the argument, or undefined if there are no such lines.
    function visualLineContinued(line) {
      var merged, lines;
      while (merged = collapsedSpanAtEnd(line)) {
        line = merged.find(1, true).line;
        (lines || (lines = [])).push(line);
      }
      return lines;
    }

    // Get the line number of the start of the visual line that the
    // given line number is part of.
    function visualLineNo(doc, lineN) {
      var line = getLine(doc, lineN), vis = visualLine(line);
      if (line == vis) return lineN;
      return lineNo(vis);
    }
    // Get the line number of the start of the next visual line after
    // the given line.
    function visualLineEndNo(doc, lineN) {
      if (lineN > doc.lastLine()) return lineN;
      var line = getLine(doc, lineN), merged;
      if (!lineIsHidden(doc, line)) return lineN;
      while (merged = collapsedSpanAtEnd(line))
        line = merged.find(1, true).line;
      return lineNo(line) + 1;
    }

    // Compute whether a line is hidden. Lines count as hidden when they
    // are part of a visual line that starts with another line, or when
    // they are entirely covered by collapsed, non-widget span.
    function lineIsHidden(doc, line) {
      var sps = sawCollapsedSpans && line.markedSpans;
      if (sps) for (var sp, i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (!sp.marker.collapsed) continue;
        if (sp.from == null) return true;
        if (sp.marker.widgetNode) continue;
        if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
          return true;
      }
    }
    function lineIsHiddenInner(doc, line, span) {
      if (span.to == null) {
        var end = span.marker.find(1, true);
        return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
      }
      if (span.marker.inclusiveRight && span.to == line.text.length)
        return true;
      for (var sp, i = 0; i < line.markedSpans.length; ++i) {
        sp = line.markedSpans[i];
        if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
            (sp.to == null || sp.to != span.from) &&
            (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
            lineIsHiddenInner(doc, line, sp)) return true;
      }
    }

    // LINE WIDGETS

    // Line widgets are block elements displayed above or below a line.

    var LineWidget = CodeMirror.LineWidget = function(cm, node, options) {
      if (options) for (var opt in options) if (options.hasOwnProperty(opt))
        this[opt] = options[opt];
      this.cm = cm;
      this.node = node;
    };
    eventMixin(LineWidget);

    function adjustScrollWhenAboveVisible(cm, line, diff) {
      if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
        addToScrollPos(cm, null, diff);
    }

    LineWidget.prototype.clear = function() {
      var cm = this.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
      if (no == null || !ws) return;
      for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);
      if (!ws.length) line.widgets = null;
      var height = widgetHeight(this);
      runInOp(cm, function() {
        adjustScrollWhenAboveVisible(cm, line, -height);
        regLineChange(cm, no, "widget");
        updateLineHeight(line, Math.max(0, line.height - height));
      });
    };
    LineWidget.prototype.changed = function() {
      var oldH = this.height, cm = this.cm, line = this.line;
      this.height = null;
      var diff = widgetHeight(this) - oldH;
      if (!diff) return;
      runInOp(cm, function() {
        cm.curOp.forceUpdate = true;
        adjustScrollWhenAboveVisible(cm, line, diff);
        updateLineHeight(line, line.height + diff);
      });
    };

    function widgetHeight(widget) {
      if (widget.height != null) return widget.height;
      if (!contains(document.body, widget.node)) {
        var parentStyle = "position: relative;";
        if (widget.coverGutter)
          parentStyle += "margin-left: -" + widget.cm.getGutterElement().offsetWidth + "px;";
        removeChildrenAndAdd(widget.cm.display.measure, elt("div", [widget.node], null, parentStyle));
      }
      return widget.height = widget.node.offsetHeight;
    }

    function addLineWidget(cm, handle, node, options) {
      var widget = new LineWidget(cm, node, options);
      if (widget.noHScroll) cm.display.alignWidgets = true;
      changeLine(cm.doc, handle, "widget", function(line) {
        var widgets = line.widgets || (line.widgets = []);
        if (widget.insertAt == null) widgets.push(widget);
        else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
        widget.line = line;
        if (!lineIsHidden(cm.doc, line)) {
          var aboveVisible = heightAtLine(line) < cm.doc.scrollTop;
          updateLineHeight(line, line.height + widgetHeight(widget));
          if (aboveVisible) addToScrollPos(cm, null, widget.height);
          cm.curOp.forceUpdate = true;
        }
        return true;
      });
      return widget;
    }

    // LINE DATA STRUCTURE

    // Line objects. These hold state related to a line, including
    // highlighting info (the styles array).
    var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {
      this.text = text;
      attachMarkedSpans(this, markedSpans);
      this.height = estimateHeight ? estimateHeight(this) : 1;
    };
    eventMixin(Line);
    Line.prototype.lineNo = function() { return lineNo(this); };

    // Change the content (text, markers) of a line. Automatically
    // invalidates cached information and tries to re-estimate the
    // line's height.
    function updateLine(line, text, markedSpans, estimateHeight) {
      line.text = text;
      if (line.stateAfter) line.stateAfter = null;
      if (line.styles) line.styles = null;
      if (line.order != null) line.order = null;
      detachMarkedSpans(line);
      attachMarkedSpans(line, markedSpans);
      var estHeight = estimateHeight ? estimateHeight(line) : 1;
      if (estHeight != line.height) updateLineHeight(line, estHeight);
    }

    // Detach a line from the document tree and its markers.
    function cleanUpLine(line) {
      line.parent = null;
      detachMarkedSpans(line);
    }

    function extractLineClasses(type, output) {
      if (type) for (;;) {
        var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
        if (!lineClass) break;
        type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
        var prop = lineClass[1] ? "bgClass" : "textClass";
        if (output[prop] == null)
          output[prop] = lineClass[2];
        else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
          output[prop] += " " + lineClass[2];
      }
      return type;
    }

    function callBlankLine(mode, state) {
      if (mode.blankLine) return mode.blankLine(state);
      if (!mode.innerMode) return;
      var inner = CodeMirror.innerMode(mode, state);
      if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);
    }

    function readToken(mode, stream, state) {
      for (var i = 0; i < 10; i++) {
        var style = mode.token(stream, state);
        if (stream.pos > stream.start) return style;
      }
      throw new Error("Mode " + mode.name + " failed to advance stream.");
    }

    // Run the given mode's parser over a line, calling f for each token.
    function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
      var flattenSpans = mode.flattenSpans;
      if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;
      var curStart = 0, curStyle = null;
      var stream = new StringStream(text, cm.options.tabSize), style;
      if (text == "") extractLineClasses(callBlankLine(mode, state), lineClasses);
      while (!stream.eol()) {
        if (stream.pos > cm.options.maxHighlightLength) {
          flattenSpans = false;
          if (forceToEnd) processLine(cm, text, state, stream.pos);
          stream.pos = text.length;
          style = null;
        } else {
          style = extractLineClasses(readToken(mode, stream, state), lineClasses);
        }
        if (cm.options.addModeClass) {
          var mName = CodeMirror.innerMode(mode, state).mode.name;
          if (mName) style = "m-" + (style ? mName + " " + style : mName);
        }
        if (!flattenSpans || curStyle != style) {
          if (curStart < stream.start) f(stream.start, curStyle);
          curStart = stream.start; curStyle = style;
        }
        stream.start = stream.pos;
      }
      while (curStart < stream.pos) {
        // Webkit seems to refuse to render text nodes longer than 57444 characters
        var pos = Math.min(stream.pos, curStart + 50000);
        f(pos, curStyle);
        curStart = pos;
      }
    }

    // Compute a style array (an array starting with a mode generation
    // -- for invalidation -- followed by pairs of end positions and
    // style strings), which is used to highlight the tokens on the
    // line.
    function highlightLine(cm, line, state, forceToEnd) {
      // A styles array always starts with a number identifying the
      // mode/overlays that it is based on (for easy invalidation).
      var st = [cm.state.modeGen], lineClasses = {};
      // Compute the base array of styles
      runMode(cm, line.text, cm.doc.mode, state, function(end, style) {
        st.push(end, style);
      }, lineClasses, forceToEnd);

      // Run overlays, adjust style array.
      for (var o = 0; o < cm.state.overlays.length; ++o) {
        var overlay = cm.state.overlays[o], i = 1, at = 0;
        runMode(cm, line.text, overlay.mode, true, function(end, style) {
          var start = i;
          // Ensure there's a token end at the current position, and that i points at it
          while (at < end) {
            var i_end = st[i];
            if (i_end > end)
              st.splice(i, 1, end, st[i+1], i_end);
            i += 2;
            at = Math.min(end, i_end);
          }
          if (!style) return;
          if (overlay.opaque) {
            st.splice(start, i - start, end, "cm-overlay " + style);
            i = start + 2;
          } else {
            for (; start < i; start += 2) {
              var cur = st[start+1];
              st[start+1] = (cur ? cur + " " : "") + "cm-overlay " + style;
            }
          }
        }, lineClasses);
      }

      return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};
    }

    function getLineStyles(cm, line) {
      if (!line.styles || line.styles[0] != cm.state.modeGen) {
        var result = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
        line.styles = result.styles;
        if (result.classes) line.styleClasses = result.classes;
        else if (line.styleClasses) line.styleClasses = null;
      }
      return line.styles;
    }

    // Lightweight form of highlight -- proceed over this line and
    // update state, but don't save a style array. Used for lines that
    // aren't currently visible.
    function processLine(cm, text, state, startAt) {
      var mode = cm.doc.mode;
      var stream = new StringStream(text, cm.options.tabSize);
      stream.start = stream.pos = startAt || 0;
      if (text == "") callBlankLine(mode, state);
      while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {
        readToken(mode, stream, state);
        stream.start = stream.pos;
      }
    }

    // Convert a style as returned by a mode (either null, or a string
    // containing one or more styles) to a CSS style. This is cached,
    // and also looks for line-wide styles.
    var styleToClassCache = {}, styleToClassCacheWithMode = {};
    function interpretTokenStyle(style, options) {
      if (!style || /^\s*$/.test(style)) return null;
      var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
      return cache[style] ||
        (cache[style] = style.replace(/\S+/g, "cm-$&"));
    }

    // Render the DOM representation of the text of a line. Also builds
    // up a 'line map', which points at the DOM nodes that represent
    // specific stretches of text, and is used by the measuring code.
    // The returned object contains the DOM node, this map, and
    // information about line-wide styles that were set by the mode.
    function buildLineContent(cm, lineView) {
      // The padding-right forces the element to have a 'border', which
      // is needed on Webkit to be able to get line-level bounding
      // rectangles for it (in measureChar).
      var content = elt("span", null, null, webkit ? "padding-right: .1px" : null);
      var builder = {pre: elt("pre", [content]), content: content, col: 0, pos: 0, cm: cm};
      lineView.measure = {};

      // Iterate over the logical lines that make up this visual line.
      for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
        var line = i ? lineView.rest[i - 1] : lineView.line, order;
        builder.pos = 0;
        builder.addToken = buildToken;
        // Optionally wire in some hacks into the token-rendering
        // algorithm, to deal with browser quirks.
        if ((ie || webkit) && cm.getOption("lineWrapping"))
          builder.addToken = buildTokenSplitSpaces(builder.addToken);
        if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))
          builder.addToken = buildTokenBadBidi(builder.addToken, order);
        builder.map = [];
        insertLineContent(line, builder, getLineStyles(cm, line));
        if (line.styleClasses) {
          if (line.styleClasses.bgClass)
            builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
          if (line.styleClasses.textClass)
            builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
        }

        // Ensure at least a single node is present, for measuring.
        if (builder.map.length == 0)
          builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));

        // Store the map and a cache object for the current logical line
        if (i == 0) {
          lineView.measure.map = builder.map;
          lineView.measure.cache = {};
        } else {
          (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
          (lineView.measure.caches || (lineView.measure.caches = [])).push({});
        }
      }

      signal(cm, "renderLine", cm, lineView.line, builder.pre);
      if (builder.pre.className)
        builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
      return builder;
    }

    function defaultSpecialCharPlaceholder(ch) {
      var token = elt("span", "\u2022", "cm-invalidchar");
      token.title = "\\u" + ch.charCodeAt(0).toString(16);
      return token;
    }

    // Build up the DOM representation for a single token, and add it to
    // the line map. Takes care to render special characters separately.
    function buildToken(builder, text, style, startStyle, endStyle, title) {
      if (!text) return;
      var special = builder.cm.options.specialChars, mustWrap = false;
      if (!special.test(text)) {
        builder.col += text.length;
        var content = document.createTextNode(text);
        builder.map.push(builder.pos, builder.pos + text.length, content);
        if (ie && ie_version < 9) mustWrap = true;
        builder.pos += text.length;
      } else {
        var content = document.createDocumentFragment(), pos = 0;
        while (true) {
          special.lastIndex = pos;
          var m = special.exec(text);
          var skipped = m ? m.index - pos : text.length - pos;
          if (skipped) {
            var txt = document.createTextNode(text.slice(pos, pos + skipped));
            if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
            else content.appendChild(txt);
            builder.map.push(builder.pos, builder.pos + skipped, txt);
            builder.col += skipped;
            builder.pos += skipped;
          }
          if (!m) break;
          pos += skipped + 1;
          if (m[0] == "\t") {
            var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
            var txt = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
            builder.col += tabWidth;
          } else {
            var txt = builder.cm.options.specialCharPlaceholder(m[0]);
            if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
            else content.appendChild(txt);
            builder.col += 1;
          }
          builder.map.push(builder.pos, builder.pos + 1, txt);
          builder.pos++;
        }
      }
      if (style || startStyle || endStyle || mustWrap) {
        var fullStyle = style || "";
        if (startStyle) fullStyle += startStyle;
        if (endStyle) fullStyle += endStyle;
        var token = elt("span", [content], fullStyle);
        if (title) token.title = title;
        return builder.content.appendChild(token);
      }
      builder.content.appendChild(content);
    }

    function buildTokenSplitSpaces(inner) {
      function split(old) {
        var out = " ";
        for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? " " : "\u00a0";
        out += " ";
        return out;
      }
      return function(builder, text, style, startStyle, endStyle, title) {
        inner(builder, text.replace(/ {3,}/g, split), style, startStyle, endStyle, title);
      };
    }

    // Work around nonsense dimensions being reported for stretches of
    // right-to-left text.
    function buildTokenBadBidi(inner, order) {
      return function(builder, text, style, startStyle, endStyle, title) {
        style = style ? style + " cm-force-border" : "cm-force-border";
        var start = builder.pos, end = start + text.length;
        for (;;) {
          // Find the part that overlaps with the start of this text
          for (var i = 0; i < order.length; i++) {
            var part = order[i];
            if (part.to > start && part.from <= start) break;
          }
          if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title);
          inner(builder, text.slice(0, part.to - start), style, startStyle, null, title);
          startStyle = null;
          text = text.slice(part.to - start);
          start = part.to;
        }
      };
    }

    function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
      var widget = !ignoreWidget && marker.widgetNode;
      if (widget) {
        builder.map.push(builder.pos, builder.pos + size, widget);
        builder.content.appendChild(widget);
      }
      builder.pos += size;
    }

    // Outputs a number of spans to make up a line, taking highlighting
    // and marked text into account.
    function insertLineContent(line, builder, styles) {
      var spans = line.markedSpans, allText = line.text, at = 0;
      if (!spans) {
        for (var i = 1; i < styles.length; i+=2)
          builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));
        return;
      }

      var len = allText.length, pos = 0, i = 1, text = "", style;
      var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
      for (;;) {
        if (nextChange == pos) { // Update current marker set
          spanStyle = spanEndStyle = spanStartStyle = title = "";
          collapsed = null; nextChange = Infinity;
          var foundBookmarks = [];
          for (var j = 0; j < spans.length; ++j) {
            var sp = spans[j], m = sp.marker;
            if (sp.from <= pos && (sp.to == null || sp.to > pos)) {
              if (sp.to != null && nextChange > sp.to) { nextChange = sp.to; spanEndStyle = ""; }
              if (m.className) spanStyle += " " + m.className;
              if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;
              if (m.endStyle && sp.to == nextChange) spanEndStyle += " " + m.endStyle;
              if (m.title && !title) title = m.title;
              if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
                collapsed = sp;
            } else if (sp.from > pos && nextChange > sp.from) {
              nextChange = sp.from;
            }
            if (m.type == "bookmark" && sp.from == pos && m.widgetNode) foundBookmarks.push(m);
          }
          if (collapsed && (collapsed.from || 0) == pos) {
            buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                               collapsed.marker, collapsed.from == null);
            if (collapsed.to == null) return;
          }
          if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j)
            buildCollapsedSpan(builder, 0, foundBookmarks[j]);
        }
        if (pos >= len) break;

        var upto = Math.min(len, nextChange);
        while (true) {
          if (text) {
            var end = pos + text.length;
            if (!collapsed) {
              var tokenText = end > upto ? text.slice(0, upto - pos) : text;
              builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                               spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title);
            }
            if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}
            pos = end;
            spanStartStyle = "";
          }
          text = allText.slice(at, at = styles[i++]);
          style = interpretTokenStyle(styles[i++], builder.cm.options);
        }
      }
    }

    // DOCUMENT DATA STRUCTURE

    // By default, updates that start and end at the beginning of a line
    // are treated specially, in order to make the association of line
    // widgets and marker elements with the text behave more intuitive.
    function isWholeLineUpdate(doc, change) {
      return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
        (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
    }

    // Perform a change on the document data structure.
    function updateDoc(doc, change, markedSpans, estimateHeight) {
      function spansFor(n) {return markedSpans ? markedSpans[n] : null;}
      function update(line, text, spans) {
        updateLine(line, text, spans, estimateHeight);
        signalLater(line, "change", line, change);
      }

      var from = change.from, to = change.to, text = change.text;
      var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
      var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

      // Adjust the line structure
      if (isWholeLineUpdate(doc, change)) {
        // This is a whole-line replace. Treated specially to make
        // sure line objects move the way they are supposed to.
        for (var i = 0, added = []; i < text.length - 1; ++i)
          added.push(new Line(text[i], spansFor(i), estimateHeight));
        update(lastLine, lastLine.text, lastSpans);
        if (nlines) doc.remove(from.line, nlines);
        if (added.length) doc.insert(from.line, added);
      } else if (firstLine == lastLine) {
        if (text.length == 1) {
          update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
        } else {
          for (var added = [], i = 1; i < text.length - 1; ++i)
            added.push(new Line(text[i], spansFor(i), estimateHeight));
          added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
          update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
          doc.insert(from.line + 1, added);
        }
      } else if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
        doc.remove(from.line + 1, nlines);
      } else {
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
        for (var i = 1, added = []; i < text.length - 1; ++i)
          added.push(new Line(text[i], spansFor(i), estimateHeight));
        if (nlines > 1) doc.remove(from.line + 1, nlines - 1);
        doc.insert(from.line + 1, added);
      }

      signalLater(doc, "change", doc, change);
    }

    // The document is represented as a BTree consisting of leaves, with
    // chunk of lines in them, and branches, with up to ten leaves or
    // other branch nodes below them. The top node is always a branch
    // node, and is the document object itself (meaning it has
    // additional methods and properties).
    //
    // All nodes have parent links. The tree is used both to go from
    // line numbers to line objects, and to go from objects to numbers.
    // It also indexes by height, and is used to convert between height
    // and line object, and to find the total height of the document.
    //
    // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

    function LeafChunk(lines) {
      this.lines = lines;
      this.parent = null;
      for (var i = 0, height = 0; i < lines.length; ++i) {
        lines[i].parent = this;
        height += lines[i].height;
      }
      this.height = height;
    }

    LeafChunk.prototype = {
      chunkSize: function() { return this.lines.length; },
      // Remove the n lines at offset 'at'.
      removeInner: function(at, n) {
        for (var i = at, e = at + n; i < e; ++i) {
          var line = this.lines[i];
          this.height -= line.height;
          cleanUpLine(line);
          signalLater(line, "delete");
        }
        this.lines.splice(at, n);
      },
      // Helper used to collapse a small branch into a single leaf.
      collapse: function(lines) {
        lines.push.apply(lines, this.lines);
      },
      // Insert the given array of lines at offset 'at', count them as
      // having the given height.
      insertInner: function(at, lines, height) {
        this.height += height;
        this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
        for (var i = 0; i < lines.length; ++i) lines[i].parent = this;
      },
      // Used to iterate over a part of the tree.
      iterN: function(at, n, op) {
        for (var e = at + n; at < e; ++at)
          if (op(this.lines[at])) return true;
      }
    };

    function BranchChunk(children) {
      this.children = children;
      var size = 0, height = 0;
      for (var i = 0; i < children.length; ++i) {
        var ch = children[i];
        size += ch.chunkSize(); height += ch.height;
        ch.parent = this;
      }
      this.size = size;
      this.height = height;
      this.parent = null;
    }

    BranchChunk.prototype = {
      chunkSize: function() { return this.size; },
      removeInner: function(at, n) {
        this.size -= n;
        for (var i = 0; i < this.children.length; ++i) {
          var child = this.children[i], sz = child.chunkSize();
          if (at < sz) {
            var rm = Math.min(n, sz - at), oldHeight = child.height;
            child.removeInner(at, rm);
            this.height -= oldHeight - child.height;
            if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
            if ((n -= rm) == 0) break;
            at = 0;
          } else at -= sz;
        }
        // If the result is smaller than 25 lines, ensure that it is a
        // single leaf node.
        if (this.size - n < 25 &&
            (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
          var lines = [];
          this.collapse(lines);
          this.children = [new LeafChunk(lines)];
          this.children[0].parent = this;
        }
      },
      collapse: function(lines) {
        for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);
      },
      insertInner: function(at, lines, height) {
        this.size += lines.length;
        this.height += height;
        for (var i = 0; i < this.children.length; ++i) {
          var child = this.children[i], sz = child.chunkSize();
          if (at <= sz) {
            child.insertInner(at, lines, height);
            if (child.lines && child.lines.length > 50) {
              while (child.lines.length > 50) {
                var spilled = child.lines.splice(child.lines.length - 25, 25);
                var newleaf = new LeafChunk(spilled);
                child.height -= newleaf.height;
                this.children.splice(i + 1, 0, newleaf);
                newleaf.parent = this;
              }
              this.maybeSpill();
            }
            break;
          }
          at -= sz;
        }
      },
      // When a node has grown, check whether it should be split.
      maybeSpill: function() {
        if (this.children.length <= 10) return;
        var me = this;
        do {
          var spilled = me.children.splice(me.children.length - 5, 5);
          var sibling = new BranchChunk(spilled);
          if (!me.parent) { // Become the parent node
            var copy = new BranchChunk(me.children);
            copy.parent = me;
            me.children = [copy, sibling];
            me = copy;
          } else {
            me.size -= sibling.size;
            me.height -= sibling.height;
            var myIndex = indexOf(me.parent.children, me);
            me.parent.children.splice(myIndex + 1, 0, sibling);
          }
          sibling.parent = me.parent;
        } while (me.children.length > 10);
        me.parent.maybeSpill();
      },
      iterN: function(at, n, op) {
        for (var i = 0; i < this.children.length; ++i) {
          var child = this.children[i], sz = child.chunkSize();
          if (at < sz) {
            var used = Math.min(n, sz - at);
            if (child.iterN(at, used, op)) return true;
            if ((n -= used) == 0) break;
            at = 0;
          } else at -= sz;
        }
      }
    };

    var nextDocId = 0;
    var Doc = CodeMirror.Doc = function(text, mode, firstLine) {
      if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);
      if (firstLine == null) firstLine = 0;

      BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
      this.first = firstLine;
      this.scrollTop = this.scrollLeft = 0;
      this.cantEdit = false;
      this.cleanGeneration = 1;
      this.frontier = firstLine;
      var start = Pos(firstLine, 0);
      this.sel = simpleSelection(start);
      this.history = new History(null);
      this.id = ++nextDocId;
      this.modeOption = mode;

      if (typeof text == "string") text = splitLines(text);
      updateDoc(this, {from: start, to: start, text: text});
      setSelection(this, simpleSelection(start), sel_dontScroll);
    };

    Doc.prototype = createObj(BranchChunk.prototype, {
      constructor: Doc,
      // Iterate over the document. Supports two forms -- with only one
      // argument, it calls that for each line in the document. With
      // three, it iterates over the range given by the first two (with
      // the second being non-inclusive).
      iter: function(from, to, op) {
        if (op) this.iterN(from - this.first, to - from, op);
        else this.iterN(this.first, this.first + this.size, from);
      },

      // Non-public interface for adding and removing lines.
      insert: function(at, lines) {
        var height = 0;
        for (var i = 0; i < lines.length; ++i) height += lines[i].height;
        this.insertInner(at - this.first, lines, height);
      },
      remove: function(at, n) { this.removeInner(at - this.first, n); },

      // From here, the methods are part of the public interface. Most
      // are also available from CodeMirror (editor) instances.

      getValue: function(lineSep) {
        var lines = getLines(this, this.first, this.first + this.size);
        if (lineSep === false) return lines;
        return lines.join(lineSep || "\n");
      },
      setValue: docMethodOp(function(code) {
        var top = Pos(this.first, 0), last = this.first + this.size - 1;
        makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                          text: splitLines(code), origin: "setValue"}, true);
        setSelection(this, simpleSelection(top));
      }),
      replaceRange: function(code, from, to, origin) {
        from = clipPos(this, from);
        to = to ? clipPos(this, to) : from;
        replaceRange(this, code, from, to, origin);
      },
      getRange: function(from, to, lineSep) {
        var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
        if (lineSep === false) return lines;
        return lines.join(lineSep || "\n");
      },

      getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},

      getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},
      getLineNumber: function(line) {return lineNo(line);},

      getLineHandleVisualStart: function(line) {
        if (typeof line == "number") line = getLine(this, line);
        return visualLine(line);
      },

      lineCount: function() {return this.size;},
      firstLine: function() {return this.first;},
      lastLine: function() {return this.first + this.size - 1;},

      clipPos: function(pos) {return clipPos(this, pos);},

      getCursor: function(start) {
        var range = this.sel.primary(), pos;
        if (start == null || start == "head") pos = range.head;
        else if (start == "anchor") pos = range.anchor;
        else if (start == "end" || start == "to" || start === false) pos = range.to();
        else pos = range.from();
        return pos;
      },
      listSelections: function() { return this.sel.ranges; },
      somethingSelected: function() {return this.sel.somethingSelected();},

      setCursor: docMethodOp(function(line, ch, options) {
        setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
      }),
      setSelection: docMethodOp(function(anchor, head, options) {
        setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
      }),
      extendSelection: docMethodOp(function(head, other, options) {
        extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
      }),
      extendSelections: docMethodOp(function(heads, options) {
        extendSelections(this, clipPosArray(this, heads, options));
      }),
      extendSelectionsBy: docMethodOp(function(f, options) {
        extendSelections(this, map(this.sel.ranges, f), options);
      }),
      setSelections: docMethodOp(function(ranges, primary, options) {
        if (!ranges.length) return;
        for (var i = 0, out = []; i < ranges.length; i++)
          out[i] = new Range(clipPos(this, ranges[i].anchor),
                             clipPos(this, ranges[i].head));
        if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);
        setSelection(this, normalizeSelection(out, primary), options);
      }),
      addSelection: docMethodOp(function(anchor, head, options) {
        var ranges = this.sel.ranges.slice(0);
        ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
        setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
      }),

      getSelection: function(lineSep) {
        var ranges = this.sel.ranges, lines;
        for (var i = 0; i < ranges.length; i++) {
          var sel = getBetween(this, ranges[i].from(), ranges[i].to());
          lines = lines ? lines.concat(sel) : sel;
        }
        if (lineSep === false) return lines;
        else return lines.join(lineSep || "\n");
      },
      getSelections: function(lineSep) {
        var parts = [], ranges = this.sel.ranges;
        for (var i = 0; i < ranges.length; i++) {
          var sel = getBetween(this, ranges[i].from(), ranges[i].to());
          if (lineSep !== false) sel = sel.join(lineSep || "\n");
          parts[i] = sel;
        }
        return parts;
      },
      replaceSelection: function(code, collapse, origin) {
        var dup = [];
        for (var i = 0; i < this.sel.ranges.length; i++)
          dup[i] = code;
        this.replaceSelections(dup, collapse, origin || "+input");
      },
      replaceSelections: docMethodOp(function(code, collapse, origin) {
        var changes = [], sel = this.sel;
        for (var i = 0; i < sel.ranges.length; i++) {
          var range = sel.ranges[i];
          changes[i] = {from: range.from(), to: range.to(), text: splitLines(code[i]), origin: origin};
        }
        var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
        for (var i = changes.length - 1; i >= 0; i--)
          makeChange(this, changes[i]);
        if (newSel) setSelectionReplaceHistory(this, newSel);
        else if (this.cm) ensureCursorVisible(this.cm);
      }),
      undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
      redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
      undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
      redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

      setExtending: function(val) {this.extend = val;},
      getExtending: function() {return this.extend;},

      historySize: function() {
        var hist = this.history, done = 0, undone = 0;
        for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;
        for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;
        return {undo: done, redo: undone};
      },
      clearHistory: function() {this.history = new History(this.history.maxGeneration);},

      markClean: function() {
        this.cleanGeneration = this.changeGeneration(true);
      },
      changeGeneration: function(forceSplit) {
        if (forceSplit)
          this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
        return this.history.generation;
      },
      isClean: function (gen) {
        return this.history.generation == (gen || this.cleanGeneration);
      },

      getHistory: function() {
        return {done: copyHistoryArray(this.history.done),
                undone: copyHistoryArray(this.history.undone)};
      },
      setHistory: function(histData) {
        var hist = this.history = new History(this.history.maxGeneration);
        hist.done = copyHistoryArray(histData.done.slice(0), null, true);
        hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
      },

      addLineClass: docMethodOp(function(handle, where, cls) {
        return changeLine(this, handle, "class", function(line) {
          var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";
          if (!line[prop]) line[prop] = cls;
          else if (new RegExp("(?:^|\\s)" + cls + "(?:$|\\s)").test(line[prop])) return false;
          else line[prop] += " " + cls;
          return true;
        });
      }),
      removeLineClass: docMethodOp(function(handle, where, cls) {
        return changeLine(this, handle, "class", function(line) {
          var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";
          var cur = line[prop];
          if (!cur) return false;
          else if (cls == null) line[prop] = null;
          else {
            var found = cur.match(new RegExp("(?:^|\\s+)" + cls + "(?:$|\\s+)"));
            if (!found) return false;
            var end = found.index + found[0].length;
            line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
          }
          return true;
        });
      }),

      markText: function(from, to, options) {
        return markText(this, clipPos(this, from), clipPos(this, to), options, "range");
      },
      setBookmark: function(pos, options) {
        var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                        insertLeft: options && options.insertLeft,
                        clearWhenEmpty: false, shared: options && options.shared};
        pos = clipPos(this, pos);
        return markText(this, pos, pos, realOpts, "bookmark");
      },
      findMarksAt: function(pos) {
        pos = clipPos(this, pos);
        var markers = [], spans = getLine(this, pos.line).markedSpans;
        if (spans) for (var i = 0; i < spans.length; ++i) {
          var span = spans[i];
          if ((span.from == null || span.from <= pos.ch) &&
              (span.to == null || span.to >= pos.ch))
            markers.push(span.marker.parent || span.marker);
        }
        return markers;
      },
      findMarks: function(from, to, filter) {
        from = clipPos(this, from); to = clipPos(this, to);
        var found = [], lineNo = from.line;
        this.iter(from.line, to.line + 1, function(line) {
          var spans = line.markedSpans;
          if (spans) for (var i = 0; i < spans.length; i++) {
            var span = spans[i];
            if (!(lineNo == from.line && from.ch > span.to ||
                  span.from == null && lineNo != from.line||
                  lineNo == to.line && span.from > to.ch) &&
                (!filter || filter(span.marker)))
              found.push(span.marker.parent || span.marker);
          }
          ++lineNo;
        });
        return found;
      },
      getAllMarks: function() {
        var markers = [];
        this.iter(function(line) {
          var sps = line.markedSpans;
          if (sps) for (var i = 0; i < sps.length; ++i)
            if (sps[i].from != null) markers.push(sps[i].marker);
        });
        return markers;
      },

      posFromIndex: function(off) {
        var ch, lineNo = this.first;
        this.iter(function(line) {
          var sz = line.text.length + 1;
          if (sz > off) { ch = off; return true; }
          off -= sz;
          ++lineNo;
        });
        return clipPos(this, Pos(lineNo, ch));
      },
      indexFromPos: function (coords) {
        coords = clipPos(this, coords);
        var index = coords.ch;
        if (coords.line < this.first || coords.ch < 0) return 0;
        this.iter(this.first, coords.line, function (line) {
          index += line.text.length + 1;
        });
        return index;
      },

      copy: function(copyHistory) {
        var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
        doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
        doc.sel = this.sel;
        doc.extend = false;
        if (copyHistory) {
          doc.history.undoDepth = this.history.undoDepth;
          doc.setHistory(this.getHistory());
        }
        return doc;
      },

      linkedDoc: function(options) {
        if (!options) options = {};
        var from = this.first, to = this.first + this.size;
        if (options.from != null && options.from > from) from = options.from;
        if (options.to != null && options.to < to) to = options.to;
        var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
        if (options.sharedHist) copy.history = this.history;
        (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
        copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
        copySharedMarkers(copy, findSharedMarkers(this));
        return copy;
      },
      unlinkDoc: function(other) {
        if (other instanceof CodeMirror) other = other.doc;
        if (this.linked) for (var i = 0; i < this.linked.length; ++i) {
          var link = this.linked[i];
          if (link.doc != other) continue;
          this.linked.splice(i, 1);
          other.unlinkDoc(this);
          detachSharedMarkers(findSharedMarkers(this));
          break;
        }
        // If the histories were shared, split them again
        if (other.history == this.history) {
          var splitIds = [other.id];
          linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);
          other.history = new History(null);
          other.history.done = copyHistoryArray(this.history.done, splitIds);
          other.history.undone = copyHistoryArray(this.history.undone, splitIds);
        }
      },
      iterLinkedDocs: function(f) {linkedDocs(this, f);},

      getMode: function() {return this.mode;},
      getEditor: function() {return this.cm;}
    });

    // Public alias.
    Doc.prototype.eachLine = Doc.prototype.iter;

    // Set up methods on CodeMirror's prototype to redirect to the editor's document.
    var dontDelegate = "iter insert remove copy getEditor".split(" ");
    for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
      CodeMirror.prototype[prop] = (function(method) {
        return function() {return method.apply(this.doc, arguments);};
      })(Doc.prototype[prop]);

    eventMixin(Doc);

    // Call f for all linked documents.
    function linkedDocs(doc, f, sharedHistOnly) {
      function propagate(doc, skip, sharedHist) {
        if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
          var rel = doc.linked[i];
          if (rel.doc == skip) continue;
          var shared = sharedHist && rel.sharedHist;
          if (sharedHistOnly && !shared) continue;
          f(rel.doc, shared);
          propagate(rel.doc, doc, shared);
        }
      }
      propagate(doc, null, true);
    }

    // Attach a document to an editor.
    function attachDoc(cm, doc) {
      if (doc.cm) throw new Error("This document is already in use.");
      cm.doc = doc;
      doc.cm = cm;
      estimateLineHeights(cm);
      loadMode(cm);
      if (!cm.options.lineWrapping) findMaxLine(cm);
      cm.options.mode = doc.modeOption;
      regChange(cm);
    }

    // LINE UTILITIES

    // Find the line object corresponding to the given line number.
    function getLine(doc, n) {
      n -= doc.first;
      if (n < 0 || n >= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");
      for (var chunk = doc; !chunk.lines;) {
        for (var i = 0;; ++i) {
          var child = chunk.children[i], sz = child.chunkSize();
          if (n < sz) { chunk = child; break; }
          n -= sz;
        }
      }
      return chunk.lines[n];
    }

    // Get the part of a document between two positions, as an array of
    // strings.
    function getBetween(doc, start, end) {
      var out = [], n = start.line;
      doc.iter(start.line, end.line + 1, function(line) {
        var text = line.text;
        if (n == end.line) text = text.slice(0, end.ch);
        if (n == start.line) text = text.slice(start.ch);
        out.push(text);
        ++n;
      });
      return out;
    }
    // Get the lines between from and to, as array of strings.
    function getLines(doc, from, to) {
      var out = [];
      doc.iter(from, to, function(line) { out.push(line.text); });
      return out;
    }

    // Update the height of a line, propagating the height change
    // upwards to parent nodes.
    function updateLineHeight(line, height) {
      var diff = height - line.height;
      if (diff) for (var n = line; n; n = n.parent) n.height += diff;
    }

    // Given a line object, find its line number by walking up through
    // its parent links.
    function lineNo(line) {
      if (line.parent == null) return null;
      var cur = line.parent, no = indexOf(cur.lines, line);
      for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
        for (var i = 0;; ++i) {
          if (chunk.children[i] == cur) break;
          no += chunk.children[i].chunkSize();
        }
      }
      return no + cur.first;
    }

    // Find the line at the given vertical position, using the height
    // information in the document tree.
    function lineAtHeight(chunk, h) {
      var n = chunk.first;
      outer: do {
        for (var i = 0; i < chunk.children.length; ++i) {
          var child = chunk.children[i], ch = child.height;
          if (h < ch) { chunk = child; continue outer; }
          h -= ch;
          n += child.chunkSize();
        }
        return n;
      } while (!chunk.lines);
      for (var i = 0; i < chunk.lines.length; ++i) {
        var line = chunk.lines[i], lh = line.height;
        if (h < lh) break;
        h -= lh;
      }
      return n + i;
    }


    // Find the height above the given line.
    function heightAtLine(lineObj) {
      lineObj = visualLine(lineObj);

      var h = 0, chunk = lineObj.parent;
      for (var i = 0; i < chunk.lines.length; ++i) {
        var line = chunk.lines[i];
        if (line == lineObj) break;
        else h += line.height;
      }
      for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
        for (var i = 0; i < p.children.length; ++i) {
          var cur = p.children[i];
          if (cur == chunk) break;
          else h += cur.height;
        }
      }
      return h;
    }

    // Get the bidi ordering for the given line (and cache it). Returns
    // false for lines that are fully left-to-right, and an array of
    // BidiSpan objects otherwise.
    function getOrder(line) {
      var order = line.order;
      if (order == null) order = line.order = bidiOrdering(line.text);
      return order;
    }

    // HISTORY

    function History(startGen) {
      // Arrays of change events and selections. Doing something adds an
      // event to done and clears undo. Undoing moves events from done
      // to undone, redoing moves them in the other direction.
      this.done = []; this.undone = [];
      this.undoDepth = Infinity;
      // Used to track when changes can be merged into a single undo
      // event
      this.lastModTime = this.lastSelTime = 0;
      this.lastOp = this.lastSelOp = null;
      this.lastOrigin = this.lastSelOrigin = null;
      // Used by the isClean() method
      this.generation = this.maxGeneration = startGen || 1;
    }

    // Create a history change event from an updateDoc-style change
    // object.
    function historyChangeFromChange(doc, change) {
      var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
      attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
      linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);
      return histChange;
    }

    // Pop all selection events off the end of a history array. Stop at
    // a change event.
    function clearSelectionEvents(array) {
      while (array.length) {
        var last = lst(array);
        if (last.ranges) array.pop();
        else break;
      }
    }

    // Find the top change event in the history. Pop off selection
    // events that are in the way.
    function lastChangeEvent(hist, force) {
      if (force) {
        clearSelectionEvents(hist.done);
        return lst(hist.done);
      } else if (hist.done.length && !lst(hist.done).ranges) {
        return lst(hist.done);
      } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
        hist.done.pop();
        return lst(hist.done);
      }
    }

    // Register a change in the history. Merges changes that are within
    // a single operation, ore are close together with an origin that
    // allows merging (starting with "+") into a single event.
    function addChangeToHistory(doc, change, selAfter, opId) {
      var hist = doc.history;
      hist.undone.length = 0;
      var time = +new Date, cur;

      if ((hist.lastOp == opId ||
           hist.lastOrigin == change.origin && change.origin &&
           ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||
            change.origin.charAt(0) == "*")) &&
          (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
        // Merge this change into the last event
        var last = lst(cur.changes);
        if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
          // Optimized case for simple insertion -- don't want to add
          // new changesets for every character typed
          last.to = changeEnd(change);
        } else {
          // Add new sub-event
          cur.changes.push(historyChangeFromChange(doc, change));
        }
      } else {
        // Can not be merged, start a new event.
        var before = lst(hist.done);
        if (!before || !before.ranges)
          pushSelectionToHistory(doc.sel, hist.done);
        cur = {changes: [historyChangeFromChange(doc, change)],
               generation: hist.generation};
        hist.done.push(cur);
        while (hist.done.length > hist.undoDepth) {
          hist.done.shift();
          if (!hist.done[0].ranges) hist.done.shift();
        }
      }
      hist.done.push(selAfter);
      hist.generation = ++hist.maxGeneration;
      hist.lastModTime = hist.lastSelTime = time;
      hist.lastOp = hist.lastSelOp = opId;
      hist.lastOrigin = hist.lastSelOrigin = change.origin;

      if (!last) signal(doc, "historyAdded");
    }

    function selectionEventCanBeMerged(doc, origin, prev, sel) {
      var ch = origin.charAt(0);
      return ch == "*" ||
        ch == "+" &&
        prev.ranges.length == sel.ranges.length &&
        prev.somethingSelected() == sel.somethingSelected() &&
        new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
    }

    // Called whenever the selection changes, sets the new selection as
    // the pending selection in the history, and pushes the old pending
    // selection into the 'done' array when it was significantly
    // different (in number of selected ranges, emptiness, or time).
    function addSelectionToHistory(doc, sel, opId, options) {
      var hist = doc.history, origin = options && options.origin;

      // A new event is started when the previous origin does not match
      // the current, or the origins don't allow matching. Origins
      // starting with * are always merged, those starting with + are
      // merged when similar and close together in time.
      if (opId == hist.lastSelOp ||
          (origin && hist.lastSelOrigin == origin &&
           (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
            selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
        hist.done[hist.done.length - 1] = sel;
      else
        pushSelectionToHistory(sel, hist.done);

      hist.lastSelTime = +new Date;
      hist.lastSelOrigin = origin;
      hist.lastSelOp = opId;
      if (options && options.clearRedo !== false)
        clearSelectionEvents(hist.undone);
    }

    function pushSelectionToHistory(sel, dest) {
      var top = lst(dest);
      if (!(top && top.ranges && top.equals(sel)))
        dest.push(sel);
    }

    // Used to store marked span information in the history.
    function attachLocalSpans(doc, change, from, to) {
      var existing = change["spans_" + doc.id], n = 0;
      doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
        if (line.markedSpans)
          (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
        ++n;
      });
    }

    // When un/re-doing restores text containing marked spans, those
    // that have been explicitly cleared should not be restored.
    function removeClearedSpans(spans) {
      if (!spans) return null;
      for (var i = 0, out; i < spans.length; ++i) {
        if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }
        else if (out) out.push(spans[i]);
      }
      return !out ? spans : out.length ? out : null;
    }

    // Retrieve and filter the old marked spans stored in a change event.
    function getOldSpans(doc, change) {
      var found = change["spans_" + doc.id];
      if (!found) return null;
      for (var i = 0, nw = []; i < change.text.length; ++i)
        nw.push(removeClearedSpans(found[i]));
      return nw;
    }

    // Used both to provide a JSON-safe object in .getHistory, and, when
    // detaching a document, to split the history in two
    function copyHistoryArray(events, newGroup, instantiateSel) {
      for (var i = 0, copy = []; i < events.length; ++i) {
        var event = events[i];
        if (event.ranges) {
          copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
          continue;
        }
        var changes = event.changes, newChanges = [];
        copy.push({changes: newChanges});
        for (var j = 0; j < changes.length; ++j) {
          var change = changes[j], m;
          newChanges.push({from: change.from, to: change.to, text: change.text});
          if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {
            if (indexOf(newGroup, Number(m[1])) > -1) {
              lst(newChanges)[prop] = change[prop];
              delete change[prop];
            }
          }
        }
      }
      return copy;
    }

    // Rebasing/resetting history to deal with externally-sourced changes

    function rebaseHistSelSingle(pos, from, to, diff) {
      if (to < pos.line) {
        pos.line += diff;
      } else if (from < pos.line) {
        pos.line = from;
        pos.ch = 0;
      }
    }

    // Tries to rebase an array of history events given a change in the
    // document. If the change touches the same lines as the event, the
    // event, and everything 'behind' it, is discarded. If the change is
    // before the event, the event's positions are updated. Uses a
    // copy-on-write scheme for the positions, to avoid having to
    // reallocate them all on every rebase, but also avoid problems with
    // shared position objects being unsafely updated.
    function rebaseHistArray(array, from, to, diff) {
      for (var i = 0; i < array.length; ++i) {
        var sub = array[i], ok = true;
        if (sub.ranges) {
          if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
          for (var j = 0; j < sub.ranges.length; j++) {
            rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
            rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
          }
          continue;
        }
        for (var j = 0; j < sub.changes.length; ++j) {
          var cur = sub.changes[j];
          if (to < cur.from.line) {
            cur.from = Pos(cur.from.line + diff, cur.from.ch);
            cur.to = Pos(cur.to.line + diff, cur.to.ch);
          } else if (from <= cur.to.line) {
            ok = false;
            break;
          }
        }
        if (!ok) {
          array.splice(0, i + 1);
          i = 0;
        }
      }
    }

    function rebaseHist(hist, change) {
      var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
      rebaseHistArray(hist.done, from, to, diff);
      rebaseHistArray(hist.undone, from, to, diff);
    }

    // EVENT UTILITIES

    // Due to the fact that we still support jurassic IE versions, some
    // compatibility wrappers are needed.

    var e_preventDefault = CodeMirror.e_preventDefault = function(e) {
      if (e.preventDefault) e.preventDefault();
      else e.returnValue = false;
    };
    var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {
      if (e.stopPropagation) e.stopPropagation();
      else e.cancelBubble = true;
    };
    function e_defaultPrevented(e) {
      return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
    }
    var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};

    function e_target(e) {return e.target || e.srcElement;}
    function e_button(e) {
      var b = e.which;
      if (b == null) {
        if (e.button & 1) b = 1;
        else if (e.button & 2) b = 3;
        else if (e.button & 4) b = 2;
      }
      if (mac && e.ctrlKey && b == 1) b = 3;
      return b;
    }

    // EVENT HANDLING

    // Lightweight event framework. on/off also work on DOM nodes,
    // registering native DOM handlers.

    var on = CodeMirror.on = function(emitter, type, f) {
      if (emitter.addEventListener)
        emitter.addEventListener(type, f, false);
      else if (emitter.attachEvent)
        emitter.attachEvent("on" + type, f);
      else {
        var map = emitter._handlers || (emitter._handlers = {});
        var arr = map[type] || (map[type] = []);
        arr.push(f);
      }
    };

    var off = CodeMirror.off = function(emitter, type, f) {
      if (emitter.removeEventListener)
        emitter.removeEventListener(type, f, false);
      else if (emitter.detachEvent)
        emitter.detachEvent("on" + type, f);
      else {
        var arr = emitter._handlers && emitter._handlers[type];
        if (!arr) return;
        for (var i = 0; i < arr.length; ++i)
          if (arr[i] == f) { arr.splice(i, 1); break; }
      }
    };

    var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {
      var arr = emitter._handlers && emitter._handlers[type];
      if (!arr) return;
      var args = Array.prototype.slice.call(arguments, 2);
      for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);
    };

    var orphanDelayedCallbacks = null;

    // Often, we want to signal events at a point where we are in the
    // middle of some work, but don't want the handler to start calling
    // other methods on the editor, which might be in an inconsistent
    // state or simply not expect any other events to happen.
    // signalLater looks whether there are any handlers, and schedules
    // them to be executed when the last operation ends, or, if no
    // operation is active, when a timeout fires.
    function signalLater(emitter, type /*, values...*/) {
      var arr = emitter._handlers && emitter._handlers[type];
      if (!arr) return;
      var args = Array.prototype.slice.call(arguments, 2), list;
      if (operationGroup) {
        list = operationGroup.delayedCallbacks;
      } else if (orphanDelayedCallbacks) {
        list = orphanDelayedCallbacks;
      } else {
        list = orphanDelayedCallbacks = [];
        setTimeout(fireOrphanDelayed, 0);
      }
      function bnd(f) {return function(){f.apply(null, args);};};
      for (var i = 0; i < arr.length; ++i)
        list.push(bnd(arr[i]));
    }

    function fireOrphanDelayed() {
      var delayed = orphanDelayedCallbacks;
      orphanDelayedCallbacks = null;
      for (var i = 0; i < delayed.length; ++i) delayed[i]();
    }

    // The DOM events that CodeMirror handles can be overridden by
    // registering a (non-DOM) handler on the editor for the event name,
    // and preventDefault-ing the event in that handler.
    function signalDOMEvent(cm, e, override) {
      signal(cm, override || e.type, cm, e);
      return e_defaultPrevented(e) || e.codemirrorIgnore;
    }

    function signalCursorActivity(cm) {
      var arr = cm._handlers && cm._handlers.cursorActivity;
      if (!arr) return;
      var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
      for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)
        set.push(arr[i]);
    }

    function hasHandler(emitter, type) {
      var arr = emitter._handlers && emitter._handlers[type];
      return arr && arr.length > 0;
    }

    // Add on and off methods to a constructor's prototype, to make
    // registering events on such objects more convenient.
    function eventMixin(ctor) {
      ctor.prototype.on = function(type, f) {on(this, type, f);};
      ctor.prototype.off = function(type, f) {off(this, type, f);};
    }

    // MISC UTILITIES

    // Number of pixels added to scroller and sizer to hide scrollbar
    var scrollerCutOff = 30;

    // Returned or thrown by various protocols to signal 'I'm not
    // handling this'.
    var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};

    // Reused option objects for setSelection & friends
    var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

    function Delayed() {this.id = null;}
    Delayed.prototype.set = function(ms, f) {
      clearTimeout(this.id);
      this.id = setTimeout(f, ms);
    };

    // Counts the column offset in a string, taking tabs into account.
    // Used mostly to find indentation.
    var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {
      if (end == null) {
        end = string.search(/[^\s\u00a0]/);
        if (end == -1) end = string.length;
      }
      for (var i = startIndex || 0, n = startValue || 0;;) {
        var nextTab = string.indexOf("\t", i);
        if (nextTab < 0 || nextTab >= end)
          return n + (end - i);
        n += nextTab - i;
        n += tabSize - (n % tabSize);
        i = nextTab + 1;
      }
    };

    // The inverse of countColumn -- find the offset that corresponds to
    // a particular column.
    function findColumn(string, goal, tabSize) {
      for (var pos = 0, col = 0;;) {
        var nextTab = string.indexOf("\t", pos);
        if (nextTab == -1) nextTab = string.length;
        var skipped = nextTab - pos;
        if (nextTab == string.length || col + skipped >= goal)
          return pos + Math.min(skipped, goal - col);
        col += nextTab - pos;
        col += tabSize - (col % tabSize);
        pos = nextTab + 1;
        if (col >= goal) return pos;
      }
    }

    var spaceStrs = [""];
    function spaceStr(n) {
      while (spaceStrs.length <= n)
        spaceStrs.push(lst(spaceStrs) + " ");
      return spaceStrs[n];
    }

    function lst(arr) { return arr[arr.length-1]; }

    var selectInput = function(node) { node.select(); };
    if (ios) // Mobile Safari apparently has a bug where select() is broken.
      selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };
    else if (ie) // Suppress mysterious IE10 errors
      selectInput = function(node) { try { node.select(); } catch(_e) {} };

    function indexOf(array, elt) {
      for (var i = 0; i < array.length; ++i)
        if (array[i] == elt) return i;
      return -1;
    }
    if ([].indexOf) indexOf = function(array, elt) { return array.indexOf(elt); };
    function map(array, f) {
      var out = [];
      for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);
      return out;
    }
    if ([].map) map = function(array, f) { return array.map(f); };

    function createObj(base, props) {
      var inst;
      if (Object.create) {
        inst = Object.create(base);
      } else {
        var ctor = function() {};
        ctor.prototype = base;
        inst = new ctor();
      }
      if (props) copyObj(props, inst);
      return inst;
    };

    function copyObj(obj, target, overwrite) {
      if (!target) target = {};
      for (var prop in obj)
        if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
          target[prop] = obj[prop];
      return target;
    }

    function bind(f) {
      var args = Array.prototype.slice.call(arguments, 1);
      return function(){return f.apply(null, args);};
    }

    var nonASCIISingleCaseWordChar = /[\u00df\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
    var isWordCharBasic = CodeMirror.isWordChar = function(ch) {
      return /\w/.test(ch) || ch > "\x80" &&
        (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
    };
    function isWordChar(ch, helper) {
      if (!helper) return isWordCharBasic(ch);
      if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) return true;
      return helper.test(ch);
    }

    function isEmpty(obj) {
      for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;
      return true;
    }

    // Extending unicode characters. A series of a non-extending char +
    // any number of extending chars is treated as a single unit as far
    // as editing and measuring is concerned. This is not fully correct,
    // since some scripts/fonts/browsers also treat other configurations
    // of code points as a group.
    var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
    function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }

    // DOM UTILITIES

    function elt(tag, content, className, style) {
      var e = document.createElement(tag);
      if (className) e.className = className;
      if (style) e.style.cssText = style;
      if (typeof content == "string") e.appendChild(document.createTextNode(content));
      else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
      return e;
    }

    var range;
    if (document.createRange) range = function(node, start, end) {
      var r = document.createRange();
      r.setEnd(node, end);
      r.setStart(node, start);
      return r;
    };
    else range = function(node, start, end) {
      var r = document.body.createTextRange();
      r.moveToElementText(node.parentNode);
      r.collapse(true);
      r.moveEnd("character", end);
      r.moveStart("character", start);
      return r;
    };

    function removeChildren(e) {
      for (var count = e.childNodes.length; count > 0; --count)
        e.removeChild(e.firstChild);
      return e;
    }

    function removeChildrenAndAdd(parent, e) {
      return removeChildren(parent).appendChild(e);
    }

    function contains(parent, child) {
      if (parent.contains)
        return parent.contains(child);
      while (child = child.parentNode)
        if (child == parent) return true;
    }

    function activeElt() { return document.activeElement; }
    // Older versions of IE throws unspecified error when touching
    // document.activeElement in some cases (during loading, in iframe)
    if (ie && ie_version < 11) activeElt = function() {
      try { return document.activeElement; }
      catch(e) { return document.body; }
    };

    function classTest(cls) { return new RegExp("\\b" + cls + "\\b\\s*"); }
    function rmClass(node, cls) {
      var test = classTest(cls);
      if (test.test(node.className)) node.className = node.className.replace(test, "");
    }
    function addClass(node, cls) {
      if (!classTest(cls).test(node.className)) node.className += " " + cls;
    }
    function joinClasses(a, b) {
      var as = a.split(" ");
      for (var i = 0; i < as.length; i++)
        if (as[i] && !classTest(as[i]).test(b)) b += " " + as[i];
      return b;
    }

    // WINDOW-WIDE EVENTS

    // These must be handled carefully, because naively registering a
    // handler for each editor will cause the editors to never be
    // garbage collected.

    function forEachCodeMirror(f) {
      if (!document.body.getElementsByClassName) return;
      var byClass = document.body.getElementsByClassName("CodeMirror");
      for (var i = 0; i < byClass.length; i++) {
        var cm = byClass[i].CodeMirror;
        if (cm) f(cm);
      }
    }

    var globalsRegistered = false;
    function ensureGlobalHandlers() {
      if (globalsRegistered) return;
      registerGlobalHandlers();
      globalsRegistered = true;
    }
    function registerGlobalHandlers() {
      // When the window resizes, we need to refresh active editors.
      var resizeTimer;
      on(window, "resize", function() {
        if (resizeTimer == null) resizeTimer = setTimeout(function() {
          resizeTimer = null;
          knownScrollbarWidth = null;
          forEachCodeMirror(onResize);
        }, 100);
      });
      // When the window loses focus, we want to show the editor as blurred
      on(window, "blur", function() {
        forEachCodeMirror(onBlur);
      });
    }

    // FEATURE DETECTION

    // Detect drag-and-drop
    var dragAndDrop = function() {
      // There is *some* kind of drag-and-drop support in IE6-8, but I
      // couldn't get it to work yet.
      if (ie && ie_version < 9) return false;
      var div = elt('div');
      return "draggable" in div || "dragDrop" in div;
    }();

    var knownScrollbarWidth;
    function scrollbarWidth(measure) {
      if (knownScrollbarWidth != null) return knownScrollbarWidth;
      var test = elt("div", null, null, "width: 50px; height: 50px; overflow-x: scroll");
      removeChildrenAndAdd(measure, test);
      if (test.offsetWidth)
        knownScrollbarWidth = test.offsetHeight - test.clientHeight;
      return knownScrollbarWidth || 0;
    }

    var zwspSupported;
    function zeroWidthElement(measure) {
      if (zwspSupported == null) {
        var test = elt("span", "\u200b");
        removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
        if (measure.firstChild.offsetHeight != 0)
          zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
      }
      if (zwspSupported) return elt("span", "\u200b");
      else return elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
    }

    // Feature-detect IE's crummy client rect reporting for bidi text
    var badBidiRects;
    function hasBadBidiRects(measure) {
      if (badBidiRects != null) return badBidiRects;
      var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
      var r0 = range(txt, 0, 1).getBoundingClientRect();
      if (r0.left == r0.right) return false;
      var r1 = range(txt, 1, 2).getBoundingClientRect();
      return badBidiRects = (r1.right - r0.right < 3);
    }

    // See if "".split is the broken IE version, if so, provide an
    // alternative way to split lines.
    var splitLines = CodeMirror.splitLines = "\n\nb".split(/\n/).length != 3 ? function(string) {
      var pos = 0, result = [], l = string.length;
      while (pos <= l) {
        var nl = string.indexOf("\n", pos);
        if (nl == -1) nl = string.length;
        var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
        var rt = line.indexOf("\r");
        if (rt != -1) {
          result.push(line.slice(0, rt));
          pos += rt + 1;
        } else {
          result.push(line);
          pos = nl + 1;
        }
      }
      return result;
    } : function(string){return string.split(/\r\n?|\n/);};

    var hasSelection = window.getSelection ? function(te) {
      try { return te.selectionStart != te.selectionEnd; }
      catch(e) { return false; }
    } : function(te) {
      try {var range = te.ownerDocument.selection.createRange();}
      catch(e) {}
      if (!range || range.parentElement() != te) return false;
      return range.compareEndPoints("StartToEnd", range) != 0;
    };

    var hasCopyEvent = (function() {
      var e = elt("div");
      if ("oncopy" in e) return true;
      e.setAttribute("oncopy", "return;");
      return typeof e.oncopy == "function";
    })();

    var badZoomedRects = null;
    function hasBadZoomedRects(measure) {
      if (badZoomedRects != null) return badZoomedRects;
      var node = removeChildrenAndAdd(measure, elt("span", "x"));
      var normal = node.getBoundingClientRect();
      var fromRange = range(node, 0, 1).getBoundingClientRect();
      return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
    }

    // KEY NAMES

    var keyNames = {3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
                    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
                    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
                    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod", 107: "=", 109: "-", 127: "Delete",
                    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
                    221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
                    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"};
    CodeMirror.keyNames = keyNames;
    (function() {
      // Number keys
      for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);
      // Alphabetic keys
      for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);
      // Function keys
      for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
    })();

    // BIDI HELPERS

    function iterateBidiSections(order, from, to, f) {
      if (!order) return f(from, to, "ltr");
      var found = false;
      for (var i = 0; i < order.length; ++i) {
        var part = order[i];
        if (part.from < to && part.to > from || from == to && part.to == from) {
          f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
          found = true;
        }
      }
      if (!found) f(from, to, "ltr");
    }

    function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }
    function bidiRight(part) { return part.level % 2 ? part.from : part.to; }

    function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }
    function lineRight(line) {
      var order = getOrder(line);
      if (!order) return line.text.length;
      return bidiRight(lst(order));
    }

    function lineStart(cm, lineN) {
      var line = getLine(cm.doc, lineN);
      var visual = visualLine(line);
      if (visual != line) lineN = lineNo(visual);
      var order = getOrder(visual);
      var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
      return Pos(lineN, ch);
    }
    function lineEnd(cm, lineN) {
      var merged, line = getLine(cm.doc, lineN);
      while (merged = collapsedSpanAtEnd(line)) {
        line = merged.find(1, true).line;
        lineN = null;
      }
      var order = getOrder(line);
      var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
      return Pos(lineN == null ? lineNo(line) : lineN, ch);
    }
    function lineStartSmart(cm, pos) {
      var start = lineStart(cm, pos.line);
      var line = getLine(cm.doc, start.line);
      var order = getOrder(line);
      if (!order || order[0].level == 0) {
        var firstNonWS = Math.max(0, line.text.search(/\S/));
        var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
        return Pos(start.line, inWS ? 0 : firstNonWS);
      }
      return start;
    }

    function compareBidiLevel(order, a, b) {
      var linedir = order[0].level;
      if (a == linedir) return true;
      if (b == linedir) return false;
      return a < b;
    }
    var bidiOther;
    function getBidiPartAt(order, pos) {
      bidiOther = null;
      for (var i = 0, found; i < order.length; ++i) {
        var cur = order[i];
        if (cur.from < pos && cur.to > pos) return i;
        if ((cur.from == pos || cur.to == pos)) {
          if (found == null) {
            found = i;
          } else if (compareBidiLevel(order, cur.level, order[found].level)) {
            if (cur.from != cur.to) bidiOther = found;
            return i;
          } else {
            if (cur.from != cur.to) bidiOther = i;
            return found;
          }
        }
      }
      return found;
    }

    function moveInLine(line, pos, dir, byUnit) {
      if (!byUnit) return pos + dir;
      do pos += dir;
      while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
      return pos;
    }

    // This is needed in order to move 'visually' through bi-directional
    // text -- i.e., pressing left should make the cursor go left, even
    // when in RTL text. The tricky part is the 'jumps', where RTL and
    // LTR text touch each other. This often requires the cursor offset
    // to move more than one unit, in order to visually move one unit.
    function moveVisually(line, start, dir, byUnit) {
      var bidi = getOrder(line);
      if (!bidi) return moveLogically(line, start, dir, byUnit);
      var pos = getBidiPartAt(bidi, start), part = bidi[pos];
      var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);

      for (;;) {
        if (target > part.from && target < part.to) return target;
        if (target == part.from || target == part.to) {
          if (getBidiPartAt(bidi, target) == pos) return target;
          part = bidi[pos += dir];
          return (dir > 0) == part.level % 2 ? part.to : part.from;
        } else {
          part = bidi[pos += dir];
          if (!part) return null;
          if ((dir > 0) == part.level % 2)
            target = moveInLine(line, part.to, -1, byUnit);
          else
            target = moveInLine(line, part.from, 1, byUnit);
        }
      }
    }

    function moveLogically(line, start, dir, byUnit) {
      var target = start + dir;
      if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;
      return target < 0 || target > line.text.length ? null : target;
    }

    // Bidirectional ordering algorithm
    // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
    // that this (partially) implements.

    // One-char codes used for character types:
    // L (L):   Left-to-Right
    // R (R):   Right-to-Left
    // r (AL):  Right-to-Left Arabic
    // 1 (EN):  European Number
    // + (ES):  European Number Separator
    // % (ET):  European Number Terminator
    // n (AN):  Arabic Number
    // , (CS):  Common Number Separator
    // m (NSM): Non-Spacing Mark
    // b (BN):  Boundary Neutral
    // s (B):   Paragraph Separator
    // t (S):   Segment Separator
    // w (WS):  Whitespace
    // N (ON):  Other Neutrals

    // Returns null if characters are ordered as they appear
    // (left-to-right), or an array of sections ({from, to, level}
    // objects) in the order in which they occur visually.
    var bidiOrdering = (function() {
      // Character types for codepoints 0 to 0xff
      var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
      // Character types for codepoints 0x600 to 0x6ff
      var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm";
      function charType(code) {
        if (code <= 0xf7) return lowTypes.charAt(code);
        else if (0x590 <= code && code <= 0x5f4) return "R";
        else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);
        else if (0x6ee <= code && code <= 0x8ac) return "r";
        else if (0x2000 <= code && code <= 0x200b) return "w";
        else if (code == 0x200c) return "b";
        else return "L";
      }

      var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
      var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
      // Browsers seem to always treat the boundaries of block elements as being L.
      var outerType = "L";

      function BidiSpan(level, from, to) {
        this.level = level;
        this.from = from; this.to = to;
      }

      return function(str) {
        if (!bidiRE.test(str)) return false;
        var len = str.length, types = [];
        for (var i = 0, type; i < len; ++i)
          types.push(type = charType(str.charCodeAt(i)));

        // W1. Examine each non-spacing mark (NSM) in the level run, and
        // change the type of the NSM to the type of the previous
        // character. If the NSM is at the start of the level run, it will
        // get the type of sor.
        for (var i = 0, prev = outerType; i < len; ++i) {
          var type = types[i];
          if (type == "m") types[i] = prev;
          else prev = type;
        }

        // W2. Search backwards from each instance of a European number
        // until the first strong type (R, L, AL, or sor) is found. If an
        // AL is found, change the type of the European number to Arabic
        // number.
        // W3. Change all ALs to R.
        for (var i = 0, cur = outerType; i < len; ++i) {
          var type = types[i];
          if (type == "1" && cur == "r") types[i] = "n";
          else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }
        }

        // W4. A single European separator between two European numbers
        // changes to a European number. A single common separator between
        // two numbers of the same type changes to that type.
        for (var i = 1, prev = types[0]; i < len - 1; ++i) {
          var type = types[i];
          if (type == "+" && prev == "1" && types[i+1] == "1") types[i] = "1";
          else if (type == "," && prev == types[i+1] &&
                   (prev == "1" || prev == "n")) types[i] = prev;
          prev = type;
        }

        // W5. A sequence of European terminators adjacent to European
        // numbers changes to all European numbers.
        // W6. Otherwise, separators and terminators change to Other
        // Neutral.
        for (var i = 0; i < len; ++i) {
          var type = types[i];
          if (type == ",") types[i] = "N";
          else if (type == "%") {
            for (var end = i + 1; end < len && types[end] == "%"; ++end) {}
            var replace = (i && types[i-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
            for (var j = i; j < end; ++j) types[j] = replace;
            i = end - 1;
          }
        }

        // W7. Search backwards from each instance of a European number
        // until the first strong type (R, L, or sor) is found. If an L is
        // found, then change the type of the European number to L.
        for (var i = 0, cur = outerType; i < len; ++i) {
          var type = types[i];
          if (cur == "L" && type == "1") types[i] = "L";
          else if (isStrong.test(type)) cur = type;
        }

        // N1. A sequence of neutrals takes the direction of the
        // surrounding strong text if the text on both sides has the same
        // direction. European and Arabic numbers act as if they were R in
        // terms of their influence on neutrals. Start-of-level-run (sor)
        // and end-of-level-run (eor) are used at level run boundaries.
        // N2. Any remaining neutrals take the embedding direction.
        for (var i = 0; i < len; ++i) {
          if (isNeutral.test(types[i])) {
            for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}
            var before = (i ? types[i-1] : outerType) == "L";
            var after = (end < len ? types[end] : outerType) == "L";
            var replace = before || after ? "L" : "R";
            for (var j = i; j < end; ++j) types[j] = replace;
            i = end - 1;
          }
        }

        // Here we depart from the documented algorithm, in order to avoid
        // building up an actual levels array. Since there are only three
        // levels (0, 1, 2) in an implementation that doesn't take
        // explicit embedding into account, we can build up the order on
        // the fly, without following the level-based algorithm.
        var order = [], m;
        for (var i = 0; i < len;) {
          if (countsAsLeft.test(types[i])) {
            var start = i;
            for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}
            order.push(new BidiSpan(0, start, i));
          } else {
            var pos = i, at = order.length;
            for (++i; i < len && types[i] != "L"; ++i) {}
            for (var j = pos; j < i;) {
              if (countsAsNum.test(types[j])) {
                if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));
                var nstart = j;
                for (++j; j < i && countsAsNum.test(types[j]); ++j) {}
                order.splice(at, 0, new BidiSpan(2, nstart, j));
                pos = j;
              } else ++j;
            }
            if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));
          }
        }
        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
          order[0].from = m[0].length;
          order.unshift(new BidiSpan(0, 0, m[0].length));
        }
        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
          lst(order).to -= m[0].length;
          order.push(new BidiSpan(0, len - m[0].length, len));
        }
        if (order[0].level != lst(order).level)
          order.push(new BidiSpan(order[0].level, len, len));

        return order;
      };
    })();

    // THE END

    CodeMirror.version = "4.5.0";

    return CodeMirror;
  });

  </script>


  <style type="text/css">
  /* BASICS */

  .CodeMirror {
    /* Set height, width, borders, and global font properties here */
    font-family: monospace;
    height: 300px;
  }
  .CodeMirror-scroll {
    /* Set scrolling behaviour here */
    overflow: auto;
  }

  /* PADDING */

  .CodeMirror-lines {
    padding: 4px 0; /* Vertical padding around content */
  }
  .CodeMirror pre {
    padding: 0 4px; /* Horizontal padding of content */
  }

  .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {
    background-color: white; /* The little square between H and V scrollbars */
  }

  /* GUTTER */

  .CodeMirror-gutters {
    border-right: 1px solid #ddd;
    background-color: #f7f7f7;
    white-space: nowrap;
  }
  .CodeMirror-linenumbers {}
  .CodeMirror-linenumber {
    padding: 0 3px 0 5px;
    min-width: 20px;
    text-align: right;
    color: #999;
    -moz-box-sizing: content-box;
    box-sizing: content-box;
  }

  .CodeMirror-guttermarker { color: black; }
  .CodeMirror-guttermarker-subtle { color: #999; }

  /* CURSOR */

  .CodeMirror div.CodeMirror-cursor {
    border-left: 1px solid black;
  }
  /* Shown when moving in bi-directional text */
  .CodeMirror div.CodeMirror-secondarycursor {
    border-left: 1px solid silver;
  }
  .CodeMirror.cm-keymap-fat-cursor div.CodeMirror-cursor {
    width: auto;
    border: 0;
    background: #7e7;
  }
  .cm-animate-fat-cursor {
    width: auto;
    border: 0;
    -webkit-animation: blink 1.06s steps(1) infinite;
    -moz-animation: blink 1.06s steps(1) infinite;
    animation: blink 1.06s steps(1) infinite;
  }
  @-moz-keyframes blink {
    0% { background: #7e7; }
    50% { background: none; }
    100% { background: #7e7; }
  }
  @-webkit-keyframes blink {
    0% { background: #7e7; }
    50% { background: none; }
    100% { background: #7e7; }
  }
  @keyframes blink {
    0% { background: #7e7; }
    50% { background: none; }
    100% { background: #7e7; }
  }

  /* Can style cursor different in overwrite (non-insert) mode */
  div.CodeMirror-overwrite div.CodeMirror-cursor {}

  .cm-tab { display: inline-block; }

  .CodeMirror-ruler {
    border-left: 1px solid #ccc;
    position: absolute;
  }

  /* DEFAULT THEME */

  .cm-s-default .cm-keyword {color: #708;}
  .cm-s-default .cm-atom {color: #219;}
  .cm-s-default .cm-number {color: #164;}
  .cm-s-default .cm-def {color: #00f;}
  .cm-s-default .cm-variable,
  .cm-s-default .cm-punctuation,
  .cm-s-default .cm-property,
  .cm-s-default .cm-operator {}
  .cm-s-default .cm-variable-2 {color: #05a;}
  .cm-s-default .cm-variable-3 {color: #085;}
  .cm-s-default .cm-comment {color: #a50;}
  .cm-s-default .cm-string {color: #a11;}
  .cm-s-default .cm-string-2 {color: #f50;}
  .cm-s-default .cm-meta {color: #555;}
  .cm-s-default .cm-qualifier {color: #555;}
  .cm-s-default .cm-builtin {color: #30a;}
  .cm-s-default .cm-bracket {color: #997;}
  .cm-s-default .cm-tag {color: #170;}
  .cm-s-default .cm-attribute {color: #00c;}
  .cm-s-default .cm-header {color: blue;}
  .cm-s-default .cm-quote {color: #090;}
  .cm-s-default .cm-hr {color: #999;}
  .cm-s-default .cm-link {color: #00c;}

  .cm-negative {color: #d44;}
  .cm-positive {color: #292;}
  .cm-header, .cm-strong {font-weight: bold;}
  .cm-em {font-style: italic;}
  .cm-link {text-decoration: underline;}

  .cm-s-default .cm-error {color: #f00;}
  .cm-invalidchar {color: #f00;}

  /* Default styles for common addons */

  div.CodeMirror span.CodeMirror-matchingbracket {color: #0f0;}
  div.CodeMirror span.CodeMirror-nonmatchingbracket {color: #f22;}
  .CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }
  .CodeMirror-activeline-background {background: #e8f2ff;}

  /* STOP */

  /* The rest of this file contains styles related to the mechanics of
     the editor. You probably shouldn't touch them. */

  .CodeMirror {
    line-height: 1;
    position: relative;
    overflow: hidden;
    background: white;
    color: black;
  }

  .CodeMirror-scroll {
    /* 30px is the magic margin used to hide the element's real scrollbars */
    /* See overflow: hidden in .CodeMirror */
    margin-bottom: -30px; margin-right: -30px;
    padding-bottom: 30px;
    height: 100%;
    outline: none; /* Prevent dragging from highlighting the element */
    position: relative;
    -moz-box-sizing: content-box;
    box-sizing: content-box;
  }
  .CodeMirror-sizer {
    position: relative;
    border-right: 30px solid transparent;
    -moz-box-sizing: content-box;
    box-sizing: content-box;
  }

  /* The fake, visible scrollbars. Used to force redraw during scrolling
     before actuall scrolling happens, thus preventing shaking and
     flickering artifacts. */
  .CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {
    position: absolute;
    z-index: 6;
    display: none;
  }
  .CodeMirror-vscrollbar {
    right: 0; top: 0;
    overflow-x: hidden;
    overflow-y: scroll;
  }
  .CodeMirror-hscrollbar {
    bottom: 0; left: 0;
    overflow-y: hidden;
    overflow-x: scroll;
  }
  .CodeMirror-scrollbar-filler {
    right: 0; bottom: 0;
  }
  .CodeMirror-gutter-filler {
    left: 0; bottom: 0;
  }

  .CodeMirror-gutters {
    position: absolute; left: 0; top: 0;
    padding-bottom: 30px;
    z-index: 3;
  }
  .CodeMirror-gutter {
    white-space: normal;
    height: 100%;
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    padding-bottom: 30px;
    margin-bottom: -32px;
    display: inline-block;
    /* Hack to make IE7 behave */
    *zoom:1;
    *display:inline;
  }
  .CodeMirror-gutter-elt {
    position: absolute;
    cursor: default;
    z-index: 4;
  }

  .CodeMirror-lines {
    cursor: text;
  }
  .CodeMirror pre {
    /* Reset some styles that the rest of the page might have set */
    -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;
    border-width: 0;
    background: transparent;
    font-family: inherit;
    font-size: inherit;
    margin: 0;
    white-space: pre;
    word-wrap: normal;
    line-height: inherit;
    color: inherit;
    z-index: 2;
    position: relative;
    overflow: visible;
  }
  .CodeMirror-wrap pre {
    word-wrap: break-word;
    white-space: pre-wrap;
    word-break: normal;
  }

  .CodeMirror-linebackground {
    position: absolute;
    left: 0; right: 0; top: 0; bottom: 0;
    z-index: 0;
  }

  .CodeMirror-linewidget {
    position: relative;
    z-index: 2;
    overflow: auto;
  }

  .CodeMirror-widget {}

  .CodeMirror-wrap .CodeMirror-scroll {
    overflow-x: hidden;
  }

  .CodeMirror-measure {
    position: absolute;
    width: 100%;
    height: 0;
    overflow: hidden;
    visibility: hidden;
  }
  .CodeMirror-measure pre { position: static; }

  .CodeMirror div.CodeMirror-cursor {
    position: absolute;
    border-right: none;
    width: 0;
  }

  div.CodeMirror-cursors {
    visibility: hidden;
    position: relative;
    z-index: 1;
  }
  .CodeMirror-focused div.CodeMirror-cursors {
    visibility: visible;
  }

  .CodeMirror-selected { background: #d9d9d9; }
  .CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }
  .CodeMirror-crosshair { cursor: crosshair; }

  .cm-searching {
    background: #ffa;
    background: rgba(255, 255, 0, .4);
  }

  /* IE7 hack to prevent it from returning funny offsetTops on the spans */
  .CodeMirror span { *vertical-align: text-bottom; }

  /* Used to force a border model for a node */
  .cm-force-border { padding-right: .1px; }

  @media print {
    /* Hide the cursor when printing */
    .CodeMirror div.CodeMirror-cursors {
      visibility: hidden;
    }
  }

  </style>

  <script type="text/javascript">
  // CodeMirror, copyright (c) by Marijn Haverbeke and others
  // Distributed under an MIT license: http://codemirror.net/LICENSE

  // TODO actually recognize syntax of TypeScript constructs

  (function(mod) {
    if (typeof exports == "object" && typeof module == "object") // CommonJS
      mod(require("../../lib/codemirror"));
    else if (typeof define == "function" && define.amd) // AMD
      define(["../../lib/codemirror"], mod);
    else // Plain browser env
      mod(CodeMirror);

  })(function(CodeMirror) {
  "use strict";

  CodeMirror.defineMode("javascript", function(config, parserConfig) {
    var indentUnit = config.indentUnit;
    var statementIndent = parserConfig.statementIndent;
    var jsonldMode = parserConfig.jsonld;
    var jsonMode = parserConfig.json || jsonldMode;
    var isTS = parserConfig.typescript;
    var wordRE = parserConfig.wordCharacters || /[\w$]/;

    // Tokenizer

    var keywords = function(){
      function kw(type) {return {type: type, style: "keyword"};}
      var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");
      var operator = kw("operator"), atom = {type: "atom", style: "atom"};

      var jsKeywords = {
        "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
        "return": C, "break": C, "continue": C, "new": C, "delete": C, "throw": C, "debugger": C,
        "var": kw("var"), "const": kw("var"), "let": kw("var"),
        "function": kw("function"), "catch": kw("catch"),
        "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
        "in": operator, "typeof": operator, "instanceof": operator,
        "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
        "this": kw("this"), "module": kw("module"), "class": kw("class"), "super": kw("atom"),
        "yield": C, "export": kw("export"), "import": kw("import"), "extends": C
      };

      // Extend the 'normal' keywords with the TypeScript language extensions
      if (isTS) {
        var type = {type: "variable", style: "variable-3"};
        var tsKeywords = {
          // object-like things
          "interface": kw("interface"),
          "extends": kw("extends"),
          "constructor": kw("constructor"),

          // scope modifiers
          "public": kw("public"),
          "private": kw("private"),
          "protected": kw("protected"),
          "static": kw("static"),

          // types
          "string": type, "number": type, "bool": type, "any": type
        };

        for (var attr in tsKeywords) {
          jsKeywords[attr] = tsKeywords[attr];
        }
      }

      return jsKeywords;
    }();

    var isOperatorChar = /[+\-*&%=<>!?|~^]/;
    var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

    function readRegexp(stream) {
      var escaped = false, next, inSet = false;
      while ((next = stream.next()) != null) {
        if (!escaped) {
          if (next == "/" && !inSet) return;
          if (next == "[") inSet = true;
          else if (inSet && next == "]") inSet = false;
        }
        escaped = !escaped && next == "\\";
      }
    }

    // Used as scratch variables to communicate multiple values without
    // consing up tons of objects.
    var type, content;
    function ret(tp, style, cont) {
      type = tp; content = cont;
      return style;
    }
    function tokenBase(stream, state) {
      var ch = stream.next();
      if (ch == '"' || ch == "'") {
        state.tokenize = tokenString(ch);
        return state.tokenize(stream, state);
      } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
        return ret("number", "number");
      } else if (ch == "." && stream.match("..")) {
        return ret("spread", "meta");
      } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
        return ret(ch);
      } else if (ch == "=" && stream.eat(">")) {
        return ret("=>", "operator");
      } else if (ch == "0" && stream.eat(/x/i)) {
        stream.eatWhile(/[\da-f]/i);
        return ret("number", "number");
      } else if (/\d/.test(ch)) {
        stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
        return ret("number", "number");
      } else if (ch == "/") {
        if (stream.eat("*")) {
          state.tokenize = tokenComment;
          return tokenComment(stream, state);
        } else if (stream.eat("/")) {
          stream.skipToEnd();
          return ret("comment", "comment");
        } else if (state.lastType == "operator" || state.lastType == "keyword c" ||
                 state.lastType == "sof" || /^[\[{}\(,;:]$/.test(state.lastType)) {
          readRegexp(stream);
          stream.eatWhile(/[gimy]/); // 'y' is "sticky" option in Mozilla
          return ret("regexp", "string-2");
        } else {
          stream.eatWhile(isOperatorChar);
          return ret("operator", "operator", stream.current());
        }
      } else if (ch == "`") {
        state.tokenize = tokenQuasi;
        return tokenQuasi(stream, state);
      } else if (ch == "#") {
        stream.skipToEnd();
        return ret("error", "error");
      } else if (isOperatorChar.test(ch)) {
        stream.eatWhile(isOperatorChar);
        return ret("operator", "operator", stream.current());
      } else if (wordRE.test(ch)) {
        stream.eatWhile(wordRE);
        var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
        return (known && state.lastType != ".") ? ret(known.type, known.style, word) :
                       ret("variable", "variable", word);
      }
    }

    function tokenString(quote) {
      return function(stream, state) {
        var escaped = false, next;
        if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){
          state.tokenize = tokenBase;
          return ret("jsonld-keyword", "meta");
        }
        while ((next = stream.next()) != null) {
          if (next == quote && !escaped) break;
          escaped = !escaped && next == "\\";
        }
        if (!escaped) state.tokenize = tokenBase;
        return ret("string", "string");
      };
    }

    function tokenComment(stream, state) {
      var maybeEnd = false, ch;
      while (ch = stream.next()) {
        if (ch == "/" && maybeEnd) {
          state.tokenize = tokenBase;
          break;
        }
        maybeEnd = (ch == "*");
      }
      return ret("comment", "comment");
    }

    function tokenQuasi(stream, state) {
      var escaped = false, next;
      while ((next = stream.next()) != null) {
        if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
          state.tokenize = tokenBase;
          break;
        }
        escaped = !escaped && next == "\\";
      }
      return ret("quasi", "string-2", stream.current());
    }

    var brackets = "([{}])";
    // This is a crude lookahead trick to try and notice that we're
    // parsing the argument patterns for a fat-arrow function before we
    // actually hit the arrow token. It only works if the arrow is on
    // the same line as the arguments and there's no strange noise
    // (comments) in between. Fallback is to only notice when we hit the
    // arrow, and not declare the arguments as locals for the arrow
    // body.
    function findFatArrow(stream, state) {
      if (state.fatArrowAt) state.fatArrowAt = null;
      var arrow = stream.string.indexOf("=>", stream.start);
      if (arrow < 0) return;

      var depth = 0, sawSomething = false;
      for (var pos = arrow - 1; pos >= 0; --pos) {
        var ch = stream.string.charAt(pos);
        var bracket = brackets.indexOf(ch);
        if (bracket >= 0 && bracket < 3) {
          if (!depth) { ++pos; break; }
          if (--depth == 0) break;
        } else if (bracket >= 3 && bracket < 6) {
          ++depth;
        } else if (wordRE.test(ch)) {
          sawSomething = true;
        } else if (sawSomething && !depth) {
          ++pos;
          break;
        }
      }
      if (sawSomething && !depth) state.fatArrowAt = pos;
    }

    // Parser

    var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true};

    function JSLexical(indented, column, type, align, prev, info) {
      this.indented = indented;
      this.column = column;
      this.type = type;
      this.prev = prev;
      this.info = info;
      if (align != null) this.align = align;
    }

    function inScope(state, varname) {
      for (var v = state.localVars; v; v = v.next)
        if (v.name == varname) return true;
      for (var cx = state.context; cx; cx = cx.prev) {
        for (var v = cx.vars; v; v = v.next)
          if (v.name == varname) return true;
      }
    }

    function parseJS(state, style, type, content, stream) {
      var cc = state.cc;
      // Communicate our context to the combinators.
      // (Less wasteful than consing up a hundred closures on every call.)
      cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;

      if (!state.lexical.hasOwnProperty("align"))
        state.lexical.align = true;

      while(true) {
        var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
        if (combinator(type, content)) {
          while(cc.length && cc[cc.length - 1].lex)
            cc.pop()();
          if (cx.marked) return cx.marked;
          if (type == "variable" && inScope(state, content)) return "variable-2";
          return style;
        }
      }
    }

    // Combinator utils

    var cx = {state: null, column: null, marked: null, cc: null};
    function pass() {
      for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
    }
    function cont() {
      pass.apply(null, arguments);
      return true;
    }
    function register(varname) {
      function inList(list) {
        for (var v = list; v; v = v.next)
          if (v.name == varname) return true;
        return false;
      }
      var state = cx.state;
      if (state.context) {
        cx.marked = "def";
        if (inList(state.localVars)) return;
        state.localVars = {name: varname, next: state.localVars};
      } else {
        if (inList(state.globalVars)) return;
        if (parserConfig.globalVars)
          state.globalVars = {name: varname, next: state.globalVars};
      }
    }

    // Combinators

    var defaultVars = {name: "this", next: {name: "arguments"}};
    function pushcontext() {
      cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
      cx.state.localVars = defaultVars;
    }
    function popcontext() {
      cx.state.localVars = cx.state.context.vars;
      cx.state.context = cx.state.context.prev;
    }
    function pushlex(type, info) {
      var result = function() {
        var state = cx.state, indent = state.indented;
        if (state.lexical.type == "stat") indent = state.lexical.indented;
        else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
          indent = outer.indented;
        state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
      };
      result.lex = true;
      return result;
    }
    function poplex() {
      var state = cx.state;
      if (state.lexical.prev) {
        if (state.lexical.type == ")")
          state.indented = state.lexical.indented;
        state.lexical = state.lexical.prev;
      }
    }
    poplex.lex = true;

    function expect(wanted) {
      function exp(type) {
        if (type == wanted) return cont();
        else if (wanted == ";") return pass();
        else return cont(exp);
      };
      return exp;
    }

    function statement(type, value) {
      if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);
      if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);
      if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
      if (type == "{") return cont(pushlex("}"), block, poplex);
      if (type == ";") return cont();
      if (type == "if") {
        if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
          cx.state.cc.pop()();
        return cont(pushlex("form"), expression, statement, poplex, maybeelse);
      }
      if (type == "function") return cont(functiondef);
      if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);
      if (type == "variable") return cont(pushlex("stat"), maybelabel);
      if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"),
                                        block, poplex, poplex);
      if (type == "case") return cont(expression, expect(":"));
      if (type == "default") return cont(expect(":"));
      if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
                                       statement, poplex, popcontext);
      if (type == "module") return cont(pushlex("form"), pushcontext, afterModule, popcontext, poplex);
      if (type == "class") return cont(pushlex("form"), className, poplex);
      if (type == "export") return cont(pushlex("form"), afterExport, poplex);
      if (type == "import") return cont(pushlex("form"), afterImport, poplex);
      return pass(pushlex("stat"), expression, expect(";"), poplex);
    }
    function expression(type) {
      return expressionInner(type, false);
    }
    function expressionNoComma(type) {
      return expressionInner(type, true);
    }
    function expressionInner(type, noComma) {
      if (cx.state.fatArrowAt == cx.stream.start) {
        var body = noComma ? arrowBodyNoComma : arrowBody;
        if (type == "(") return cont(pushcontext, pushlex(")"), commasep(pattern, ")"), poplex, expect("=>"), body, popcontext);
        else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
      }

      var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
      if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
      if (type == "function") return cont(functiondef, maybeop);
      if (type == "keyword c") return cont(noComma ? maybeexpressionNoComma : maybeexpression);
      if (type == "(") return cont(pushlex(")"), maybeexpression, comprehension, expect(")"), poplex, maybeop);
      if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
      if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
      if (type == "{") return contCommasep(objprop, "}", null, maybeop);
      if (type == "quasi") { return pass(quasi, maybeop); }
      return cont();
    }
    function maybeexpression(type) {
      if (type.match(/[;\}\)\],]/)) return pass();
      return pass(expression);
    }
    function maybeexpressionNoComma(type) {
      if (type.match(/[;\}\)\],]/)) return pass();
      return pass(expressionNoComma);
    }

    function maybeoperatorComma(type, value) {
      if (type == ",") return cont(expression);
      return maybeoperatorNoComma(type, value, false);
    }
    function maybeoperatorNoComma(type, value, noComma) {
      var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
      var expr = noComma == false ? expression : expressionNoComma;
      if (value == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
      if (type == "operator") {
        if (/\+\+|--/.test(value)) return cont(me);
        if (value == "?") return cont(expression, expect(":"), expr);
        return cont(expr);
      }
      if (type == "quasi") { return pass(quasi, me); }
      if (type == ";") return;
      if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
      if (type == ".") return cont(property, me);
      if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
    }
    function quasi(type, value) {
      if (type != "quasi") return pass();
      if (value.slice(value.length - 2) != "${") return cont(quasi);
      return cont(expression, continueQuasi);
    }
    function continueQuasi(type) {
      if (type == "}") {
        cx.marked = "string-2";
        cx.state.tokenize = tokenQuasi;
        return cont(quasi);
      }
    }
    function arrowBody(type) {
      findFatArrow(cx.stream, cx.state);
      if (type == "{") return pass(statement);
      return pass(expression);
    }
    function arrowBodyNoComma(type) {
      findFatArrow(cx.stream, cx.state);
      if (type == "{") return pass(statement);
      return pass(expressionNoComma);
    }
    function maybelabel(type) {
      if (type == ":") return cont(poplex, statement);
      return pass(maybeoperatorComma, expect(";"), poplex);
    }
    function property(type) {
      if (type == "variable") {cx.marked = "property"; return cont();}
    }
    function objprop(type, value) {
      if (type == "variable" || cx.style == "keyword") {
        cx.marked = "property";
        if (value == "get" || value == "set") return cont(getterSetter);
        return cont(afterprop);
      } else if (type == "number" || type == "string") {
        cx.marked = jsonldMode ? "property" : (cx.style + " property");
        return cont(afterprop);
      } else if (type == "jsonld-keyword") {
        return cont(afterprop);
      } else if (type == "[") {
        return cont(expression, expect("]"), afterprop);
      }
    }
    function getterSetter(type) {
      if (type != "variable") return pass(afterprop);
      cx.marked = "property";
      return cont(functiondef);
    }
    function afterprop(type) {
      if (type == ":") return cont(expressionNoComma);
      if (type == "(") return pass(functiondef);
    }
    function commasep(what, end) {
      function proceed(type) {
        if (type == ",") {
          var lex = cx.state.lexical;
          if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
          return cont(what, proceed);
        }
        if (type == end) return cont();
        return cont(expect(end));
      }
      return function(type) {
        if (type == end) return cont();
        return pass(what, proceed);
      };
    }
    function contCommasep(what, end, info) {
      for (var i = 3; i < arguments.length; i++)
        cx.cc.push(arguments[i]);
      return cont(pushlex(end, info), commasep(what, end), poplex);
    }
    function block(type) {
      if (type == "}") return cont();
      return pass(statement, block);
    }
    function maybetype(type) {
      if (isTS && type == ":") return cont(typedef);
    }
    function typedef(type) {
      if (type == "variable"){cx.marked = "variable-3"; return cont();}
    }
    function vardef() {
      return pass(pattern, maybetype, maybeAssign, vardefCont);
    }
    function pattern(type, value) {
      if (type == "variable") { register(value); return cont(); }
      if (type == "[") return contCommasep(pattern, "]");
      if (type == "{") return contCommasep(proppattern, "}");
    }
    function proppattern(type, value) {
      if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
        register(value);
        return cont(maybeAssign);
      }
      if (type == "variable") cx.marked = "property";
      return cont(expect(":"), pattern, maybeAssign);
    }
    function maybeAssign(_type, value) {
      if (value == "=") return cont(expressionNoComma);
    }
    function vardefCont(type) {
      if (type == ",") return cont(vardef);
    }
    function maybeelse(type, value) {
      if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
    }
    function forspec(type) {
      if (type == "(") return cont(pushlex(")"), forspec1, expect(")"), poplex);
    }
    function forspec1(type) {
      if (type == "var") return cont(vardef, expect(";"), forspec2);
      if (type == ";") return cont(forspec2);
      if (type == "variable") return cont(formaybeinof);
      return pass(expression, expect(";"), forspec2);
    }
    function formaybeinof(_type, value) {
      if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
      return cont(maybeoperatorComma, forspec2);
    }
    function forspec2(type, value) {
      if (type == ";") return cont(forspec3);
      if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
      return pass(expression, expect(";"), forspec3);
    }
    function forspec3(type) {
      if (type != ")") cont(expression);
    }
    function functiondef(type, value) {
      if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}
      if (type == "variable") {register(value); return cont(functiondef);}
      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, statement, popcontext);
    }
    function funarg(type) {
      if (type == "spread") return cont(funarg);
      return pass(pattern, maybetype);
    }
    function className(type, value) {
      if (type == "variable") {register(value); return cont(classNameAfter);}
    }
    function classNameAfter(type, value) {
      if (value == "extends") return cont(expression, classNameAfter);
      if (type == "{") return cont(pushlex("}"), classBody, poplex);
    }
    function classBody(type, value) {
      if (type == "variable" || cx.style == "keyword") {
        cx.marked = "property";
        if (value == "get" || value == "set") return cont(classGetterSetter, functiondef, classBody);
        return cont(functiondef, classBody);
      }
      if (value == "*") {
        cx.marked = "keyword";
        return cont(classBody);
      }
      if (type == ";") return cont(classBody);
      if (type == "}") return cont();
    }
    function classGetterSetter(type) {
      if (type != "variable") return pass();
      cx.marked = "property";
      return cont();
    }
    function afterModule(type, value) {
      if (type == "string") return cont(statement);
      if (type == "variable") { register(value); return cont(maybeFrom); }
    }
    function afterExport(_type, value) {
      if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
      if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
      return pass(statement);
    }
    function afterImport(type) {
      if (type == "string") return cont();
      return pass(importSpec, maybeFrom);
    }
    function importSpec(type, value) {
      if (type == "{") return contCommasep(importSpec, "}");
      if (type == "variable") register(value);
      return cont();
    }
    function maybeFrom(_type, value) {
      if (value == "from") { cx.marked = "keyword"; return cont(expression); }
    }
    function arrayLiteral(type) {
      if (type == "]") return cont();
      return pass(expressionNoComma, maybeArrayComprehension);
    }
    function maybeArrayComprehension(type) {
      if (type == "for") return pass(comprehension, expect("]"));
      if (type == ",") return cont(commasep(expressionNoComma, "]"));
      return pass(commasep(expressionNoComma, "]"));
    }
    function comprehension(type) {
      if (type == "for") return cont(forspec, comprehension);
      if (type == "if") return cont(expression, comprehension);
    }

    // Interface

    return {
      startState: function(basecolumn) {
        var state = {
          tokenize: tokenBase,
          lastType: "sof",
          cc: [],
          lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
          localVars: parserConfig.localVars,
          context: parserConfig.localVars && {vars: parserConfig.localVars},
          indented: 0
        };
        if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
          state.globalVars = parserConfig.globalVars;
        return state;
      },

      token: function(stream, state) {
        if (stream.sol()) {
          if (!state.lexical.hasOwnProperty("align"))
            state.lexical.align = false;
          state.indented = stream.indentation();
          findFatArrow(stream, state);
        }
        if (state.tokenize != tokenComment && stream.eatSpace()) return null;
        var style = state.tokenize(stream, state);
        if (type == "comment") return style;
        state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
        return parseJS(state, style, type, content, stream);
      },

      indent: function(state, textAfter) {
        if (state.tokenize == tokenComment) return CodeMirror.Pass;
        if (state.tokenize != tokenBase) return 0;
        var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;
        // Kludge to prevent 'maybelse' from blocking lexical scope pops
        if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
          var c = state.cc[i];
          if (c == poplex) lexical = lexical.prev;
          else if (c != maybeelse) break;
        }
        if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev;
        if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
          lexical = lexical.prev;
        var type = lexical.type, closing = firstChar == type;

        if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);
        else if (type == "form" && firstChar == "{") return lexical.indented;
        else if (type == "form") return lexical.indented + indentUnit;
        else if (type == "stat")
          return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? statementIndent || indentUnit : 0);
        else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
          return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
        else if (lexical.align) return lexical.column + (closing ? 0 : 1);
        else return lexical.indented + (closing ? 0 : indentUnit);
      },

      electricChars: ":{}",
      blockCommentStart: jsonMode ? null : "/*",
      blockCommentEnd: jsonMode ? null : "*/",
      lineComment: jsonMode ? null : "//",
      fold: "brace",

      helperType: jsonMode ? "json" : "javascript",
      jsonldMode: jsonldMode,
      jsonMode: jsonMode
    };
  });

  CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);

  CodeMirror.defineMIME("text/javascript", "javascript");
  CodeMirror.defineMIME("text/ecmascript", "javascript");
  CodeMirror.defineMIME("application/javascript", "javascript");
  CodeMirror.defineMIME("application/x-javascript", "javascript");
  CodeMirror.defineMIME("application/ecmascript", "javascript");
  CodeMirror.defineMIME("application/json", {name: "javascript", json: true});
  CodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});
  CodeMirror.defineMIME("application/ld+json", {name: "javascript", jsonld: true});
  CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
  CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });

  });

  </script>
  <style type="text/css">
  /* Based on Sublime Text's Monokai theme */

  .CodeMirror {background: #272822; color: #f8f8f2;}
   div.CodeMirror-selected {background: #49483E !important;}
   .CodeMirror-gutters {background: #272822; border-right: 0px;}
   .CodeMirror-guttermarker { color: white; }
   .CodeMirror-guttermarker-subtle { color: #d0d0d0; }
   .CodeMirror-linenumber {color: #d0d0d0;}
   .CodeMirror-cursor {border-left: 1px solid #f8f8f0 !important;}

   span.cm-comment {color: #75715e;}
   span.cm-atom {color: #ae81ff;}
   span.cm-number {color: #ae81ff;}

   span.cm-property,  span.cm-attribute {color: #a6e22e;}
   span.cm-keyword {color: #f92672;}
   span.cm-string {color: #e6db74;}

   span.cm-variable {color: #a6e22e;}
   span.cm-variable-2 {color: #9effff;}
   span.cm-def {color: #fd971f;}
   span.cm-bracket {color: #f8f8f2;}
   span.cm-tag {color: #f92672;}
   span.cm-link {color: #ae81ff;}
   span.cm-error {background: #f92672; color: #f8f8f0;}

   .CodeMirror-activeline-background {background: #373831 !important;}
   .CodeMirror-matchingbracket {
    text-decoration: underline;
    color: white !important;
  }

  </style>
</html>


